<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trial and Error Reading</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }

    span { unicode-bidi: embed; }

    .container.normal-size {
      max-width: 768px;
      margin: 0 auto;
    }

    .container.max-size {
      max-width: 100%;
      margin: 0 auto;
    }

    #input-container, #marquee-container, #control-container, #other-settings-container {
      text-align: center;
    }

    label {
      font-weight: bold;
      display: block;
    }

    #marquee-input {
      width: 100%;
      min-height: 300px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #color-input {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #delay-input {
      width: 100px;
      padding: 5px;
      font-size: 16px;
      text-align: center;
    }

    #marquee-container {
      width: 100%;
      height: 60px;
      overflow: hidden;
      position: relative;
      border: 2px solid;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      direction: ltr;
    }

    #marquee-text {
      position: absolute;
      white-space: nowrap;
      line-height: 60px;
      text-align: right;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin: 2px;
    }

    #colors-info {
      font-size: 22px;
      font-weight: bold;
    }

    #start-pause-button, #stop-button {
      background-color: rgb(25, 135, 84);
      color: white;
      min-width: 100px;
    }

    #start-pause-button.pause {
      background-color: rgb(218, 104, 11);
    }

    #start-pause-button:hover:not(.pause) {
      background-color: rgb(21, 115, 71);
    }

    #start-pause-button.pause:hover {
      background-color: rgb(194, 93, 10);
    }

    #stop-button {
      background-color: rgb(187, 45, 59);
    }

    #stop-button:hover {
      background-color: rgb(180, 25, 46);
    }

    #theme-button, #color-boxes-theme-button, #max-size-button {
      background-color: rgb(11, 166, 197);
      color: white;
    }

    #theme-button:hover, #color-boxes-theme-button:hover, #max-size-button:hover {
      background-color: rgb(9, 130, 153);
    }

    body.light #back-button, body.light #forward-button, body.light #update-text-button, body.light #update-colors-button, body.light #copy-text-button {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
      min-width: 70px;
    }

    body.light #back-button:hover, body.light #forward-button:hover, body.light #update-text-button:hover, body.light #update-colors-button:hover, body.light #copy-text-button:hover {
      background-color: rgb(210, 210, 210);
      color: rgb(0, 0, 0);
    }

    body.light #back-button:disabled, body.light #forward-button:disabled, body.light #update-text-button:disabled, body.light #update-colors-button:disabled, body.light #copy-text-button:disabled {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
    }

    body.dark #back-button, body.dark #forward-button, body.dark #update-text-button, body.dark #update-colors-button, body.dark #copy-text-button {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
      min-width: 70px;
    }

    body.dark #back-button:hover, body.dark #forward-button:hover, body.dark #update-text-button:hover, body.dark #update-colors-button:hover, body.dark #copy-text-button:hover {
      background-color: rgb(80, 80, 80);
      color: rgb(255, 255, 255);
    }

    body.dark #back-button:disabled, body.dark #forward-button:disabled, body.dark #update-text-button:disabled, body.dark #update-colors-button:disabled, body.dark #copy-text-button:disabled {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
    }

    #dump-colors-button, #clear-button, #fetch-1-button, #fetch-2-button, #fetch-3-button, #load-from-file-button {
      background-color: rgb(108, 117, 125);
      color: white;
    }

    #dump-colors-button:hover, #clear-button:hover, #fetch-1-button:hover, #fetch-2-button:hover, #fetch-3-button:hover, #load-from-file-button:hover {
      background-color: rgb(92, 99, 106);
    }

    .span-in-marquee {
      box-sizing: border-box;
      -moz-box-sizing: border-box;
      -webkit-box-sizing: border-box;
    }

    body.light.color-boxes-theme-1 .span-in-marquee {
      border: 1px dashed white;
    }

    body.dark.color-boxes-theme-1 .span-in-marquee {
      border: 1px dashed black;
    }

    body.light.color-boxes-theme-2 .span-in-marquee {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-2 .span-in-marquee {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-3 .span-in-marquee {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-3 .span-in-marquee {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-3 .span-in-marquee-for-word {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-3 .span-in-marquee-for-word {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-4 .span-in-marquee {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-4 .span-in-marquee {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-4 .span-in-marquee-for-word {
      border: 2px solid black;
    }

    body.dark.color-boxes-theme-4 .span-in-marquee-for-word {
      border: 2px solid white;
    }

    body.light #marquee-text {
      letter-spacing: 1px;
      word-spacing: 1px;
    }

    body.dark #marquee-text {
      letter-spacing: 1px;
      word-spacing: 1px;
    }

    body.light.color-boxes-theme-2 #marquee-text {
      letter-spacing: 2px;
    }

    body.dark.color-boxes-theme-2 #marquee-text {
      letter-spacing: 2px;
    }

    body.light.color-boxes-theme-3 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 5px;
    }

    body.dark.color-boxes-theme-3 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 5px;
    }

    body.light.color-boxes-theme-4 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 15px;
    }

    body.dark.color-boxes-theme-4 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 15px;
    }

    #delay-info, #text-size-info {
      text-align: center;
    }

    #save-button {
      background-color: rgb(13, 110, 253);
      color: white;
    }

    #save-button:hover {
      background-color: rgb(11, 94, 215);
    }

    #reset-button {
      background-color: rgb(33, 37, 41);
      color: white;
    }

    #reset-button:hover {
      background-color: rgb(66, 70, 73);
    }

    input[type=text], input[type=number], select {
      padding: 8px 4px 8px 4px;
      text-align: center;
    }

    .cursor-pointer {
      cursor: pointer;
    }

    #difficulty-select, #eliminating-select, #shuffling-words-select {
      min-width: 150px;
    }

    .before-select {
      min-width: 150px;
      display: inline-block;
    }

    input[type=range] {
      padding: 0px 4px 0px 4px;
      width: 225px;
      margin: auto auto;
      text-align: center;
    }

    input[type=number] {
      width: 70px;
    }

    input[type=checkbox] {
      -ms-transform: scale(1.4); /* IE */
      -moz-transform: scale(1.4); /* FF */
      -webkit-transform: scale(1.4); /* Safari and Chrome */
      -o-transform: scale(1.4); /* Opera */
      transform: scale(1.4);
      padding: 0px 4px 0px 4px;
      margin-top: 7px;
      margin-bottom: 7px;
    }

    kbd {
      border: 1px solid;
      border-radius: 3px;
      padding: 1px 4px;
      font-size: 12px;
      font-family: monospace;
      font-weight: normal;
    }

    a {
      text-decoration: none;
      color: #333;
      font-weight: bold;
    }

    a:hover {
      color: #888;
    }

    .margin-top-10px {
      margin-top: 10px;
    }

    .margin-top-20px {
      margin-top: 20px;
    }
    
    body.light kbd {
      background-color: rgb(200, 200, 200); 
      border-color: rgb(90, 90, 90); 
      color: #333; 
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    body.dark kbd {
      background-color: rgb(60, 60, 60); 
      border-color: rgb(200, 200, 200); 
      color: #e0e0e0; 
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    body.light {
      background-color: #eeeeee;
      color: #333;
    }

    body.light #marquee-container {
      background-color: #efefef;
      border-color: #333;
    }

    body.light #marquee-input, body.light #color-input {
      background-color: #eeeeee;
      border-color: #333;
      color: black;
    }

    body.dark {
      background-color: #1a1a1a;
      color: #e0e0e0;
    }

    body.dark #marquee-container {
      background-color: #2a2a2a;
      border-color: #e0e0e0;
    }

    body.dark #marquee-input, body.dark #color-input {
      background-color: #2a2a2a;
      border-color: #e0e0e0;
      color: white;
    }

    body.light #loop-button {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
      min-width: 70px;
    }

    body.light #loop-button.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark #loop-button {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
      min-width: 70px;
    }

    body.dark #loop-button.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    @media (max-width: 600px) {
      button {
        width: 100%;
        margin: 10px 0px 10px 0px;
      }
      kbd {
        display: none;
      }
      input[type=range] {
        width: 30%;
        margin: auto auto;
        text-align: center;
      }
      input[type=number] {
        width: 30%;
        margin-left: 30%;
      }
    }
  </style>
</head>
<body class="">
  <div class="container normal-size">

    <div id="marquee-container">
      <span id="marquee-text"></span>
    </div>

    <div id="control-container" class="margin-top-20px">
      <span>
        <button id="back-button">&lt;&lt; <kbd>←</kbd></button>
        <button id="start-pause-button">Start <kbd>Space</kbd></button>
        <button id="stop-button">Stop <kbd>S</kbd></button>
        <button id="forward-button">&gt;&gt; <kbd>→</kbd></button>
      </span>
      <div>
        <button id="loop-button">Loop <kbd>L</kbd></button>
        <div id="duration-info" class="margin-top-20px" style="display: none;"></div>
        <div id="colors-info" class="margin-top-20px" style="display: none;"></div>
      </div>
    </div>
    <div id="input-container" class="margin-top-20px">
      <div>
        <button id="update-text-button">&#8635; Text &#8635;</button>
        <button id="update-colors-button">&#8635; Colors &#8635;</button>
      </div>
      <div>
        <button id="copy-text-button">&#9167; Copy text &#9167;</button>
      </div>
      <div class="margin-top-20px">
        <div>Text size</div>
        <input type="range" id="text-size-slider" min="8" max="50" value="50">
        <input type="number" id="text-size-info" min="8" max="50" value="50">
      </div>
      <div class="margin-top-20px">
        <div>Speed <kbd>+</kbd><kbd>-</kbd></div>
        <input type="number" id="speed-input" min="-1000" max="1000" value="10" style="display: none;">
        <input type="range" id="delay-slider" min="1" max="250" value="100">
        <input type="number" id="delay-info" min="-1000" max="1000" value="100">
      </div>
      <div class="margin-top-20px">
        <span class="before-select">Shuffling letters:</span>
        <select id="difficulty-select">
          <option value="no">-</option>
          <option value="easy">Easy</option>
          <option value="medium">Medium</option>
          <option value="medium_plus">Medium+</option>
          <option value="hard">Hard</option>
          <option value="very-hard">Very Hard</option>
        </select>
      </div>
      <div class="margin-top-20px">
        <span class="before-select">Eliminating letters:</span>
        <select id="eliminating-select">
          <option value="no">-</option>
          <option value="20%_vowels">20% vowels</option>
          <option value="40%_vowels">40% vowels</option>
          <option value="60%_vowels">60% vowels</option>
          <option value="80%_vowels">80% vowels</option>
          <option value="100%_vowels">Almost all vowels</option>
          <option value="10%_random">10% smart-random</option>
          <option value="20%_random">20% smart-random</option>
          <option value="30%_random">30% smart-random</option>
          <option value="40%_random">40% smart-random</option>
        </select>
      </div>
      <div class="margin-top-20px">
        <span class="before-select">Shuffling words:</span>
        <select id="shuffling-words-select">
          <option value="no">-</option>
          <option value="2_words">Two words</option>
          <option value="3_words">Three words</option>
          <option value="4_words">Four words</option>
          <option value="5_words">Five words</option>
        </select>
      </div>
      <div class="margin-top-20px">
        <label><input type="checkbox" id="color-task-checkbox" checked> Color encoder task <kbd>C</kbd></label>
        <div id="color-task-letters-box">
          <span>Number of letters:</span>
          <input type="number" id="color-task-letters" min="0" max="32" value="1">
        </div>
        </label>
        <button id="dump-colors-button">Dump colors above</button>
        <textarea id="color-input" placeholder="&lt;letter&gt; &lt;color&gt;&#13;&#10;a rgb(0, 0, 0)&#13;&#10;b red&#13;&#10;..."></textarea>
      </div>
      <div class="margin-top-20px">
        <label for="marquee-input">Text</label>
        <textarea id="marquee-input" placeholder="Enter text here"></textarea>
      </div>
      <div class="margin-top-20px">
        <button id="fetch-1-button">Load [one of the 22831 sentences]</button>
        <button id="fetch-2-button">Load [random wiki summary]</button>
        <button id="load-from-file-button">Load [from file]</button>
        <button id="fetch-3-button" style="display: none;">Load [random sentence from metaphorpsum]</button>
      </div>
      <div>
        <button id="clear-button">Clear</button>
      </div>
      <div class="margin-top-20px">
        <label><input type="checkbox" id="append-checkbox" checked> Append text after loading/fetching (uncheck to clear and append)</label>
        <label class="margin-top-10px"><input type="checkbox" id="show-text-checkbox" checked> Show text <kbd>ESC</kbd></label>
        <label class="margin-top-10px"><input type="checkbox" id="show-table-checkbox" checked> Show letters-colors info <kbd>ESC</kbd></label>
      </div>
      <div class="margin-top-20px">
        <button id="save-button">Save text and settings</button>
      </div>
    </div>
    <div id="other-settings-container" class="margin-top-20px">
      <div>
        <button id="color-boxes-theme-button">Toggle Marquee Text Block Theme</button>
        <button id="theme-button">Toggle Theme</button>
        <button id="max-size-button">Toggle Full Size</button>
      </div>
      <div class="margin-top-20px">
      <button id="reset-button">Reset settings</button>
    </div>
    <div class="margin-top-20px">
      <a href="https://github.com/Quwarm/Trial-and-Error-Reading" target="_blank">GitHub</a>
    </div>
    </div>
  </div>

  <div id="view-helper" style="display: none;"></div>

  <script>
    function loadScript(url, headOrBody = 'head') {
        var script = document.createElement("script");
        script.src = url;
        if (headOrBody == 'head') {
            document.head.appendChild(script);
        }
        else {
            document.body.appendChild(script);
        }
    }

    let animationId = null;
    let lastPosition = null;
    let startTime = null, lastTime = null;
    let currentPallete = new Map(), currentPalleteList = [];
    let prevHtmlValue = '', prevDifficulty = '', prevShufflingWords = '', eliminatingSelect = '';
    let prevColorInputValue = '', prevColorTaskCheckboxChecked = null, isLooping = false;
    let numberOfWords = 0, lastSavedPosition = null;

    let eliminateVowelsRegex = null, eliminateRandomLettersRegex = null, punctuationRegex = null;
    try {
      // https://checkserp.com/encode/unicode/
      eliminateVowelsRegex = new RegExp('[\u0041\u0045\u0049\u004f\u0055\u0410\u0415\u0401\u0418\u041e\u0423\u042b\u042d\u042e\u042f\u0391\u0395\u0397\u0399\u039f\u03a5\u03a9\u0101\u012b\u016b\u0113\u014d]', 'uig');
    }
    catch (err) {
      console.log(err);
      eliminateVowelsRegex = null;
    }
    try {
      eliminateRandomLettersRegex = new RegExp(/\p{L}/, 'uig');
    }
    catch (err) {
      console.log(err);
      eliminateRandomLettersRegex = null;
    }
    try {
      punctuationRegex = new RegExp(/\p{S}|\p{Ps}|\p{Pe}|\p{Pi}|\p{Pf}|[!"#%&*,./:;?@^]|^-$/, 'ui');
    }
    catch (err) {
      console.log(err);
      punctuationRegex = null;
    }

    function changeColor(elem) {
      let text = prompt("Enter color:", elem.style.color);
      if (text) {
        currentPallete.set(elem.innerHTML.toLowerCase(), text);
        elem.style.color = text;
        elem.style.backgroundColor = text;
      }
    }

    function showWordInfo(shuffledWord, word) {
      alert(`${shuffledWord} -> ${word}`);
    }

    document.addEventListener('DOMContentLoaded', function() {
      loadScript('sentences.js?version=1');
      let sentences = [];
      const input = document.getElementById('marquee-input');
      const speedInput = document.getElementById('speed-input');
      const delaySlider = document.getElementById('delay-slider');
      const delayInfo = document.getElementById('delay-info');
      const durationInfo = document.getElementById('duration-info');
      const colorsInfo = document.getElementById('colors-info');
      const appendCheckbox = document.getElementById('append-checkbox');
      const difficultySelect = document.getElementById('difficulty-select');
      const shufflingWordsSelect = document.getElementById('shuffling-words-select');
      const eliminatingSelect = document.getElementById('eliminating-select');
      const textElement = document.getElementById('marquee-text');
      const inputContainer = document.getElementById('input-container');
      const otherSettingsContainer = document.getElementById('other-settings-container');
      const container = document.getElementById('marquee-container');
      const startPauseButton = document.getElementById('start-pause-button');
      const stopButton = document.getElementById('stop-button');
      const themeButton = document.getElementById('theme-button');
      const maxSizeButton = document.getElementById('max-size-button');
      const saveButton = document.getElementById('save-button');
      const resetButton = document.getElementById('reset-button');
      const clearButton = document.getElementById('clear-button');
      const fetch1Button = document.getElementById('fetch-1-button');
      const fetch2Button = document.getElementById('fetch-2-button');
      const fetch3Button = document.getElementById('fetch-3-button');
      const loadFromFileButton = document.getElementById('load-from-file-button');
      const colorTaskCheckbox = document.getElementById('color-task-checkbox');
      const colorTaskLettersBox = document.getElementById('color-task-letters-box');
      const colorTaskLettersInput = document.getElementById('color-task-letters');
      const backButton = document.getElementById('back-button');
      const forwardButton = document.getElementById('forward-button');
      const colorInput = document.getElementById('color-input');
      const dumpColorsButton = document.getElementById('dump-colors-button');
      const showTextCheckbox = document.getElementById('show-text-checkbox');
      const showTableCheckbox = document.getElementById('show-table-checkbox');
      const updateTextButton = document.getElementById('update-text-button');
      const updateColorsButton = document.getElementById('update-colors-button');
      const copyTextButton = document.getElementById('copy-text-button');
      const viewHelper = document.getElementById('view-helper');
      const colorBoxesThemeButton = document.getElementById('color-boxes-theme-button');
      const loopButton = document.getElementById('loop-button');
      const textSizeSlider = document.getElementById('text-size-slider');
      const textSizeInfo = document.getElementById('text-size-info');

      const savedText = localStorage.getItem('sle_text');
      if (savedText) input.value = savedText;
      const savedDelay = localStorage.getItem('sle_speed');
      if (savedDelay) speedInput.value = savedDelay;
      delayInfo.value = 100 - speedInput.value;
      delaySlider.value = delayInfo.value;
      const savedTheme = localStorage.getItem('sle_theme') || 'dark';
      document.body.classList.add(savedTheme);
      const savedColorBoxesTheme = localStorage.getItem('sle_color_boxes_theme') || 'color-boxes-theme-1';
      document.body.classList.add(savedColorBoxesTheme);
      colorBoxesThemeButton.innerHTML += ' [' + (savedColorBoxesTheme.at(-1) || '1') + ']';
      const savedAppend = localStorage.getItem('sle_append_text') || 'true';
      appendCheckbox.checked = savedAppend !== 'false';
      const colorTask = localStorage.getItem('sle_color_task') || 'false';
      colorTaskCheckbox.checked = colorTask == 'true';
      colorTaskLettersBox.style.display = colorTaskCheckbox.checked ? '' : 'none';
      dumpColorsButton.style.display = colorTaskCheckbox.checked ? '' : 'none';
      const colorInputValue = localStorage.getItem('sle_color_task_colors') || '';
      colorInput.value = colorInputValue;
      const colorTaskLetters = localStorage.getItem('sle_color_task_letters') || '1';
      colorTaskLettersInput.value = colorTaskLetters;
      const showTextBool = localStorage.getItem('sle_show_text') || 'true';
      showTextCheckbox.checked = showTextBool === 'true';
      input.style.display = showTextCheckbox.checked ? '' : 'none';
      const showTableBool = localStorage.getItem('sle_show_table') || 'true';
      showTableCheckbox.checked = showTableBool === 'true';
      colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
      colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
      dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
      const savedDifficulty = localStorage.getItem('sle_difficulty') || 'no';
      difficultySelect.value = savedDifficulty;
      const savedEliminating = localStorage.getItem('sle_eliminating') || 'no';
      eliminatingSelect.value = savedEliminating;
      const savedShufflingWords = localStorage.getItem('sle_shuffling_words') || 'no';
      shufflingWordsSelect.value = savedShufflingWords;
      const savedTextSize = localStorage.getItem('sle_text_size') || "42";
      textSizeSlider.value = savedTextSize;
      textSizeInfo.value = savedTextSize;
      textElement.style.fontSize = savedTextSize + 'px';

      isLooping = (localStorage.getItem('sle_loop') || 'false') == 'true';
      if (isLooping) {
        loopButton.classList.toggle('active');
      }
      {
        let elems = document.getElementsByClassName('container');
        let elem = elems.length > 0 ? elems[0] : null;
        let cls = localStorage.getItem('sle_max_size') || 'normal-size';
        if (elem && cls) {
          elem.classList.add(cls);
        }
      }
      backButton.disabled = true;
      forwardButton.disabled = true;
      updateTextButton.disabled = true;
      updateColorsButton.disabled = true;
      copyTextButton.disabled = true;

      loopButton.addEventListener('click', function() {
          isLooping = !isLooping;
          loopButton.classList.toggle('active');
          localStorage.setItem('sle_loop', isLooping);
      });

      updateTextButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let continueViewParam = animationId != null;
          if (continueViewParam) {
            pauseView();
          }
          prevDifficulty = '';
          let currentValue = colorInput.value;
          startView(false);
          pauseView();
          if (continueViewParam) {
            startView(true);
          }
        }
      });

      updateColorsButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let continueViewParam = animationId != null;
          if (continueViewParam) {
            pauseView();
          }
          currentPallete.clear();
          currentPalleteList = [];
          let currentValue = colorInput.value;
          startView(false);
          pauseView();
          if (continueViewParam) {
            startView(true);
          }
        }
      });

      copyTextButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let content = textElement.textContent || textElement.innerText || "";
          navigator.clipboard.writeText(content);
        }
      });

      showTextCheckbox.addEventListener('click', function() {
        input.style.display = showTextCheckbox.checked ? '' : 'none';
      });
      
      showTableCheckbox.addEventListener('click', function() {
        colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
        colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
      });

      colorTaskCheckbox.addEventListener('click', function() {
        colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        colorTaskLettersBox.style.display = colorTaskCheckbox.checked ? '' : 'none';
      });

      dumpColorsButton.addEventListener('click', function() {
        let currentPalleteInfo = '';
        for (let k of currentPalleteList) {
          let v = currentPallete.get(k);
          k = k.toUpperCase();
          v = hexToRgb(v);
          currentPalleteInfo = currentPalleteInfo.concat(`${k} ${v}`);
          if (colorInput.value.indexOf(currentPalleteInfo) < 0) {
            let last = colorInput.value.slice(-1);
            if (last.length > 0 && last != '\n') {
              colorInput.value = colorInput.value.concat('\n');
            }
            colorInput.value = colorInput.value.concat(currentPalleteInfo).concat('\n');
          }
          currentPalleteInfo = '';
        }
      });

      speedInput.addEventListener('input', function() {
        delaySlider.value = 100 - this.value;
        delayInfo.value = delaySlider.value;
      });
      delayInfo.addEventListener('input', function() {
        speedInput.value = 100 - this.value;
        delaySlider.value = this.value;
      });
      delaySlider.addEventListener('input', function() {
        speedInput.value = 100 - this.value;
        delayInfo.value = this.value;
      });

      textSizeSlider.addEventListener('input', function() {
        textSizeInfo.value = textSizeSlider.value;
        textElement.style.fontSize = textSizeSlider.value + 'px';
      });
      textSizeInfo.addEventListener('input', function() {
        textSizeSlider.value = textSizeInfo.value;
        textElement.style.fontSize = textSizeInfo.value + 'px';
      });

      themeButton.addEventListener('click', function() {
        let themes = [
          "light",
          "dark",
        ];
        let currentThemeIndex = -1, i;
        for (i = 0; i < themes.length; ++i) {
          if (document.body.classList.contains(themes[i])) {
            currentThemeIndex = i;
            break;
          }
        }
        if (i < 0) {
          document.body.classList.add(themes[0]);
          localStorage.setItem('sle_theme', themes[0]);
          return;
        }
        for (i = 0; i < themes.length; ++i) {
          document.body.classList.remove(themes[i]);
        }
        let nextTheme = themes[(currentThemeIndex + 1) % themes.length];
        document.body.classList.add(nextTheme);
        localStorage.setItem('sle_theme', nextTheme);
      });

      maxSizeButton.addEventListener('click', function() {
        let sizes = [
          "max-size",
          "normal-size",
        ];
        let currentSizeIndex = -1, i;
        let elems = document.getElementsByClassName('container');
        let elem = elems.length > 0 ? elems[0] : null;
        if (!elem) {
          return;
        }
        for (i = 0; i < sizes.length; ++i) {
          if (elem.classList.contains(sizes[i])) {
            currentSizeIndex = i;
            break;
          }
        }
        if (i < 0) {
          elem.classList.add(sizes[0]);
          localStorage.setItem('sle_max_size', sizes[0]);
          return;
        }
        for (i = 0; i < sizes.length; ++i) {
          elem.classList.remove(sizes[i]);
        }
        let nextSize = sizes[(currentSizeIndex + 1) % sizes.length];
        elem.classList.add(nextSize);
        localStorage.setItem('sle_max_size', nextSize);
      });

      colorBoxesThemeButton.addEventListener('click', function() {
        let themes = [
          "color-boxes-theme-1",
          "color-boxes-theme-2",
          "color-boxes-theme-3",
          "color-boxes-theme-4",
        ];
        let currentThemeIndex = -1, i;
        for (i = 0; i < themes.length; ++i) {
          if (document.body.classList.contains(themes[i])) {
            currentThemeIndex = i;
            break;
          }
        }
        if (i < 0) {
          document.body.classList.add(nextTheme);
          localStorage.setItem('sle_color_boxes_theme', nextTheme);
          colorBoxesThemeButton.innerHTML = colorBoxesThemeButton.innerHTML.slice(0, -4) + ' [' + (nextTheme.at(-1) || '1') + ']';
        return;
        }
        for (i = 0; i < themes.length; ++i) {
          document.body.classList.remove(themes[i]);
        }
        let nextTheme = themes[(currentThemeIndex + 1) % themes.length];
        document.body.classList.add(nextTheme);
        localStorage.setItem('sle_color_boxes_theme', nextTheme);
        colorBoxesThemeButton.innerHTML = colorBoxesThemeButton.innerHTML.slice(0, -4) + ' [' + (nextTheme.at(-1) || '1') + ']';
      });

      clearButton.addEventListener('click', function() {
        input.value = '';
      });

      fetch1Button.addEventListener('click', function() {
        loadSentence();
      });

      fetch2Button.addEventListener('click', function() {
        fetchWiki();
      });

      fetch3Button.addEventListener('click', function() {
        fetchMetaphorpsum();
      });

      loadFromFileButton.addEventListener('click', function() {
        uploadTextFile();
      });

      backButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let continueViewParam = animationId != null;
          if (continueViewParam) {
            pauseView();
          }
          const containerWidth = Math.ceil(container.getBoundingClientRect().width);
          const startPosition = containerWidth;
          const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
          const endPosition = -textWidth;
          lastPosition = Math.max(endPosition, Math.min(startPosition, parseInt(textElement.style.left, 10) + Math.floor(containerWidth / 4)));
          textElement.style.left = lastPosition + 'px';
          lastSavedPosition = lastPosition;
          if (continueViewParam) {
            startView(true);
          }
        }
      });

      forwardButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let continueViewParam = animationId != null;
          if (continueViewParam) {
            pauseView();
          }
          const containerWidth = Math.ceil(container.getBoundingClientRect().width);
          const startPosition = containerWidth;
          const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
          const endPosition = -textWidth;
          lastPosition = Math.max(endPosition, Math.min(startPosition, parseInt(textElement.style.left, 10) - Math.floor(containerWidth / 4)));
          textElement.style.left = lastPosition + 'px';
          lastSavedPosition = lastPosition;
          if (continueViewParam) {
            startView(true);
          }
        }
      });

      function hexToRgb(hex) {
        if (!hex.match(/^#[a-f0-9]{3}$/i) && !hex.match(/^#[a-f0-9]{6}$/i)) {
          return hex;
        }
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : hex;
      }

      function uploadTextFile(event) {
        let element = document.createElement('input');
        element.id = 'text_file_upload';
        element.type = 'file';
        element.onchange = function (event) {
            if (window.File && window.FileReader && window.FileList && window.Blob) {
                let f = event.target.files[0];
                if (f) {
                    let r = new FileReader;
                    r.addEventListener("load", (function(event) {
                        let text = event.target.result;
                        input.value += (input.value ? '\n\n' : '') + text;
                    }));
                    r.readAsText(f);
                }
            } else {
                alert("This functionality not supported by your browser.")
            }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
     }

      function loadSentence() {
        if (sentences.length == 0) {
            try {
              sentences = getSentences();
            }
            catch(err) {
              sentences = [];
              console.log(err);
            }
        }
        if (sentences.length == 0) {
            alert('[Sentences.js] Sentences not found!');
            return;
        }
        let text = sentences[Math.floor(Math.random() * sentences.length)];
        if (text) {
            if (!text.endsWith('.') && !text.endsWith('?') && !text.endsWith('!') && !text.endsWith(',')) {
                text += '.';
            }
            if (appendCheckbox.checked) {
                input.value += (input.value ? '\n\n' : '') + text;
            } else {
                input.value = text;
            }
        }
      }

      function fetchWiki() {
        fetch('https://en.wikipedia.org/api/rest_v1/page/random/summary', {
            method: 'GET',
            accept: "application/problem+json"
        })
        .then(response => response.text())
        .then(data => {
            data = JSON.parse(data);
            text = data['extract'];
            text = text.trim();
            if (text) {
                if (appendCheckbox.checked) {
                  input.value += (input.value ? '\n\n' : '') + text;
                } else {
                  input.value = text;
                }
            }
        })
        .catch(() => {
            alert('[Wiki] Data Fetching Error.');
        });
      }

      function fetchMetaphorpsum() {
        fetch('http://metaphorpsum.com/sentences/1', {
            method: 'GET',
        })
        .then(response => response.text())
        .then(data => {
            text = data.trim();
            if (text) {
                if (appendCheckbox.checked) {
                  input.value += (input.value ? '\n\n' : '') + text;
                } else {
                  input.value = text;
                }
            }
        })
        .catch(() => {
            alert('[Metaphorpsum] Data Fetching Error.');
        });
      }

      saveButton.addEventListener('click', saveSettings);
      function saveSettings() {
        localStorage.setItem('sle_text', input.value);
        localStorage.setItem('sle_color_task', colorTaskCheckbox.checked);
        localStorage.setItem('sle_color_task_letters', colorTaskLettersInput.value);
        localStorage.setItem('sle_color_task_colors', colorInput.value);
        localStorage.setItem('sle_show_text', showTextCheckbox.checked);
        localStorage.setItem('sle_show_table', showTableCheckbox.checked);
        localStorage.setItem('sle_speed', speedInput.value);
        localStorage.setItem('sle_append_text', '' + appendCheckbox.checked);
        localStorage.setItem('sle_difficulty', difficultySelect.value);
        localStorage.setItem('sle_shuffling_words', shufflingWordsSelect.value);
        localStorage.setItem('sle_eliminating', eliminatingSelect.value);
        localStorage.setItem('sle_loop', isLooping);
        localStorage.setItem('sle_text_size', textSizeInfo.value);
      }

      resetButton.addEventListener('click', resetSettings);
      function resetSettings() {
        if (confirm('Are you sure you want to reset the settings?')) {
            lastSavedPosition = null;
            localStorage.removeItem('sle_text');
            localStorage.removeItem('sle_color_task');
            localStorage.removeItem('sle_color_task_letters');
            localStorage.removeItem('sle_color_task_colors');
            localStorage.removeItem('sle_show_text');
            localStorage.removeItem('sle_show_table');
            localStorage.removeItem('sle_speed');
            localStorage.removeItem('sle_append_text');
            localStorage.removeItem('sle_difficulty');
            localStorage.removeItem('sle_shuffling_words');
            localStorage.removeItem('sle_eliminating');
            localStorage.removeItem('sle_loop');
            localStorage.removeItem('sle_text_size');
            localStorage.removeItem('sle_theme');
            localStorage.removeItem('sle_color_boxes_theme');
            localStorage.removeItem('sle_max_size');
            localStorage.removeItem('sle_last_position');
            location.reload();
        }
      }

      function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
          }
      }

      function eliminateChars(regex, word, percentOfLetters) {
        let pWord = word;
        try {
          pWord = word.replace(/[^\p{L}]/ug, '');
        }
        catch (err) {
          console.log(err);
        }
        regex.lastIndex = 0;
        let match, indexes = [], is_first = true, dt = 0;
        while ((match = regex.exec(word)) != null) {
          if (is_first) {
            is_first = false;
            if (pWord[0] === word[match.index]) {
              continue;
            }
          }
          indexes.push(match.index);
        }
        regex.lastIndex = 0;
        if (indexes.length > 0 && word.length >= 2 && regex === eliminateRandomLettersRegex) {
          let lastIndex = indexes[indexes.length - 1];
          eliminateVowelsRegex.lastIndex = 0;
          if (!eliminateVowelsRegex.test(word[lastIndex]) || lastIndex > 0 &&
              (eliminateVowelsRegex.lastIndex = 0) == 0 &&
               eliminateVowelsRegex.test(word[lastIndex - 1])) {
            indexes.pop();
          }
          eliminateVowelsRegex.lastIndex = 0;
        }
        let pWordLength = pWord.length;
        try {
          if (regex === eliminateVowelsRegex) {
            let c = 0;
            for (let i = 0; i < word.length; ++i) {
              eliminateVowelsRegex.lastIndex = 0;
              if (eliminateVowelsRegex.test(word[i])) {
                ++c;
              }
            }
            pWordLength = c;
            eliminateVowelsRegex.lastIndex = 0;
          }
        }
        catch (err) {
          console.log(err);
        }
        let toSelectN = Math.min(Math.floor(pWordLength * percentOfLetters), indexes.length);
        let toSelectArray = indexes;
        shuffleArray(toSelectArray);
        let part1 = [], part2 = [], part3 = [];
        for (let x of toSelectArray) {
          eliminateVowelsRegex.lastIndex = 0;
          if (eliminateVowelsRegex.test(word[x])) {
            part2.push(x);
          }
          else if (x > 0 && word[x - 1] == word[x]) {
            part1.push(x);
          }
          else {
            part3.push(x);
          }
        }
        part1.sort((a, b) => b - a);
        part2.sort((a, b) => b - a);
        part3.sort((a, b) => b - a);
        eliminateVowelsRegex.lastIndex = 0;
        toSelectArray = [...part1, ...part2, ...part3].slice(0, toSelectN).sort((a, b) => a - b);
        let newWordParts = [];
        let start = 0;
        for (let removeIndex of toSelectArray) {
          if (start < removeIndex) {
            newWordParts.push(word.slice(start, removeIndex));
          }
          start = removeIndex + 1;
        }
        if (start < word.length) {
          newWordParts.push(word.slice(start));
        }
        return newWordParts.join('');
      }

      function shuffleGroups(words, k) {
        let newWordsIndexes = [];
        for (let i = 0; i < words.length;) {
          let currentWords = words.slice(i, i + k), hWords = [];
          hWords.push(currentWords[0]);
          let b = punctuationRegex.test(currentWords[0]);
          for (let j = 1; j < currentWords.length; ++j) {
            if (b || punctuationRegex.test(currentWords[j])) {
              break;
            }
            hWords.push(currentWords[j]);
          }
          currentWords = hWords;
          let di = currentWords.length;
          let toShuffleIndexes = [], toRemainIndexes = new Set();
          for (let j = 0; j < currentWords.length; ++j) {
            if (punctuationRegex.test(currentWords[j])) {
              toRemainIndexes.add(j);
            }
            else {
              toShuffleIndexes.push(j);
            }
          }
          shuffleArray(toShuffleIndexes);
          for (let j = 0, j1 = 0; j < currentWords.length; ++j) {
            if (toRemainIndexes.has(j)) {
              newWordsIndexes.push(i + j);
              continue;
            }
            newWordsIndexes.push(i + toShuffleIndexes[j1]);
            ++j1;
          }
          i += di;
        }
        return newWordsIndexes;
      }

      function isLetter(ch) {
        try {
          if (/^[a-zA-Z]+$/.test(ch)) {
            return true;
          }
          if (ch.toLowerCase() !== ch.toUpperCase()) {
            return true;
          }
          if (/^\p{L}+$/u.test(ch)) {
            return true;
          }
        }
        catch (err) {
          console.log(err);
        }
        return false;
      }

      function shuffleLetters(editedText, helperText, bShuffle, translateFunction = null) {
        const escapeWord = function (word) {
          return word.replace(/\\/g, "").replace(/\"/g, "").replace(/\'/g, "\\\'");
        };
        const sentences = editedText.split('\n');
        const helperSentences = helperText.split('\n');
        const r = [];
        for (let slS = 0; slS < sentences.length; ++slS) {
            const sentence = sentences[slS];
            const helperSentence = helperSentences[slS];
            let words = sentence.split(/\s+/);
            let helperWords = helperSentence.split(/\s+/);
            let newWords = [], newHelperWords = [];
            if (shufflingWordsSelect.value != 'no') {
              try {
                let match = /(\d+)_words?/.exec(shufflingWordsSelect.value);
                if (match != null && match.length >= 2) {
                  const nWords = parseInt(match[1]);
                  let newWordsIndexes = shuffleGroups(words, nWords);
                  for (let c of newWordsIndexes) {
                    newWords.push(words[c]);
                    newHelperWords.push(helperWords[c]);
                  }
                }
              }
              catch (err) {
                console.log(err);
              }
            }
            if (newWords && newWords.length > 0) {
              words = newWords;
            }
            if (newHelperWords && newHelperWords.length > 0) {
              helperWords = newHelperWords;
            }
            let currentSentence = [];
            let skipWord = false;
            for (let slW = 0; slW < words.length; ++slW) {
                const word = words[slW];
                const helperWord = helperWords[slW];
                if (word.length == 0) {
                  continue;
                }
                let resultWord = word;
                if (/^[^a-zA-Z]*[A-Z]/.test(resultWord) || /\d|\'/.test(resultWord)) {
                  skipWord = true;
                }
                try {
                  if (/\u2032|\u2033|\u2034|\u2057|\u2019|\u0060|\u00B4|\uFF40|\u02F4/u.test(resultWord)) {
                    skipWord = true;
                  }
                  if (/^[^\p{L}]*\p{Lu}/u.test(resultWord) || /\p{N}/u.test(resultWord)) {
                    skipWord = true;
                  }
                }
                catch (err) {
                  console.log(err);
                }
                if (difficultySelect.value == "no") {
                  skipWord = true;
                }
                if (bShuffle && resultWord.length > 1 && eliminatingSelect.value != "no") {
                  let tmpWord = resultWord;
                  try {
                    let match = /(\d+)%_vowels?/.exec(eliminatingSelect.value);
                    if (match != null && match.length >= 2) {
                      tmpWord = eliminateChars(eliminateVowelsRegex, tmpWord, parseInt(match[1]) / 100);
                    }
                    else {
                      match = /(\d+)%_random/.exec(eliminatingSelect.value);
                      if (match != null && match.length >= 2) {
                        tmpWord = eliminateChars(eliminateRandomLettersRegex, tmpWord, parseInt(match[1]) / 100);
                      }
                    }
                    resultWord = tmpWord;
                  }
                  catch (err) {
                    console.log(err);
                  }
                }
                if (bShuffle && (difficultySelect.value == "easy" && resultWord.length > 3 || difficultySelect.value != "easy") && (skipWord == false || difficultySelect.value == "very-hard")) {
                    const wordParts = resultWord.split(/\-/);
                    let lettersList = [];
                    for (const wordPart of wordParts) {
                      const m = (difficultySelect.value == "hard" || difficultySelect.value == "very-hard") ? 0 : (difficultySelect.value == "medium" || difficultySelect.value == "medium_plus" ? 1 : Math.floor(wordPart.length / 3));
                      const chars = [];
                      for (const c of wordPart) {
                          if (isLetter(c)) {
                              chars.push(c);
                          }
                      }
                      const firstLetters = chars.slice(0, m);
                      const midLetters = chars.slice(m, chars.length - (difficultySelect.value == "medium_plus" ? 0 : m));
                      const lastLetters = chars.slice(chars.length - (difficultySelect.value == "medium_plus" ? 0 : m));
                      const origMidLetters = [...midLetters];
                      const uniqueMid = new Set(origMidLetters).size;
                      while (uniqueMid > 1 && midLetters.toString() == origMidLetters.toString()) {
                          shuffleArray(midLetters);
                      }
                      const allLetters = [...firstLetters, ...midLetters, ...lastLetters];
                      let lettersListPart = [];
                      let i = 0;
                      for (const c of wordPart) {
                          if (isLetter(c)) {
                            lettersListPart.push(allLetters[i]);
                            i++;
                          } else {
                            lettersListPart.push(c);
                          }
                      }
                      lettersList.push(lettersListPart.join(""));
                    }
                    resultWord = lettersList.join('-');
                }
                let result = resultWord;
                if (translateFunction) {
                  result = '';
                  for (let i = 0; i < resultWord.length; ++i) {
                    result = result.concat(translateFunction(resultWord[i]));
                  }
                  if (difficultySelect.value !== "no" || eliminatingSelect.value !== 'no') {
                    const helperWordEscaped = escapeWord(helperWord);
                    const shuffledWordEscaped = escapeWord(resultWord);
                    result = `<span class="span-in-marquee-for-word cursor-pointer" onclick="javascript:showWordInfo('${shuffledWordEscaped}', '${helperWordEscaped}')">${result}</span>`;
                  }
                  else {
                    result = `<span class="span-in-marquee-for-word">${result}</span>`;
                  }
                }
                currentSentence.push(result);
                skipWord = false;
                if (word.indexOf('.') >= 0) {
                    skipWord = true;
                }
            }
            r.push(currentSentence);
        }
        return r.map(sentence => sentence.join(' ')).join('\n');
      }

      function formatSeconds(seconds) {
        if (typeof seconds !== 'number' || seconds < 0) {
            return '00:00:00';
        }
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        const formatNumber = (num) => num < 10 ? `0${num}` : num;
        return `${formatNumber(hours)}:${formatNumber(minutes)}:${formatNumber(remainingSeconds)}`;
      }

      function generateColorPalette(n) {
        const colors = [];
        function isTooDarkOrLight(r, g, b) {
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance < 0.1 || luminance > 0.9;
        }
        for (let i = 0; i < n; i++) {
            let r, g, b, color;
            do {
                r = Math.floor(Math.random() * 256);
                g = Math.floor(Math.random() * 256);
                b = Math.floor(Math.random() * 256);
                
                color = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            } while (isTooDarkOrLight(r, g, b));
            colors.push(color);
        }
        return colors;
      }

      function startAnimation(continueViewParam = false) {
        let htmlValue = input.value.replace(/\s+/g, ' ').trim();
        try {
          htmlValue = htmlValue.replace(/\p{Z}+/ug, ' ');
          htmlValue = htmlValue.replace(/\p{C}+/ug, '');
        }
        catch (err) {
          console.log(err);
        }
        if (!htmlValue) {
          alert('Please add text');
          return false;
        }

        viewHelper.innerHTML = htmlValue;
        let textFromHtmlValue = viewHelper.textContent || viewHelper.innerText || "";
        let singleLineHtml = textElement.innerHTML;
        let singleLineText = textElement.textContent || textElement.innerText || "";
        viewHelper.innerHTML = '';

        if (prevHtmlValue !== textFromHtmlValue) {
          try {
            numberOfWords = textFromHtmlValue.split(/\s/).filter(word => word.length > 0).length;
            if (numberOfWords < 10) {
              numberOfWords = 0;
            }
          }
          catch (err) {
            console.log(err);
          }
        }

        let palleteChanged = false;

        if (continueViewParam == false && colorTaskCheckbox.checked) {
          palleteChanged = true;

          let newPalleteSize = parseInt(colorTaskLettersInput.value, 10);

          let preserveValues = colorInput.value.split('\n');
          let preserveMap = new Map();
          let preserveLetters = [];
          for (let x of preserveValues) {
            let xSplitted = x.split(/\s+/);
            if (xSplitted.length >= 2) {
              for (let letter of xSplitted[0].toLowerCase()) {
                preserveLetters.push(letter);
                preserveMap.set(letter, [...xSplitted.slice(1)].join(' '));
              }
            }
          }

          if (currentPallete.size < newPalleteSize || colorInput.value != prevColorInputValue) {
            let paletteColors = generateColorPalette(newPalleteSize);
            let letters = currentPalleteList.slice();

            for (let x of preserveLetters) {
              if (letters.length < newPalleteSize && textFromHtmlValue.indexOf(x) >= 0) {
                let currentLetter = x.toLowerCase();
                const currentLetterColor = preserveMap.get(currentLetter);
                if (letters.includes(currentLetter) == false && currentLetterColor) {
                  letters.push(currentLetter);
                }
              }
            }
            for (let i = 0, j = 0; i < textFromHtmlValue.length && letters.length < newPalleteSize; ++i) {
              let currentLetter = textFromHtmlValue[i].toLowerCase();
              const currentLetterColor = preserveMap.get(currentLetter);
              if (letters.includes(currentLetter) == false && currentLetterColor) {
                letters.push(currentLetter);
              }
            }
            for (let i = 0, j = 0; i < textFromHtmlValue.length && j < paletteColors.length && letters.length < newPalleteSize; ++i) {
              let currentLetter = textFromHtmlValue[i].toLowerCase();
              if (isLetter(currentLetter) && letters.includes(currentLetter) == false) {
                letters.push(currentLetter);
                ++j;
              }
            }
            letters.sort();
            let j = 0;
            for (let currentLetter of letters) {
              if (currentPallete.get(currentLetter) == null) {
                if (preserveMap.get(currentLetter) != null) {
                  currentPallete.set(currentLetter, preserveMap.get(currentLetter));
                  currentPalleteList.push(currentLetter);
                }
                else {
                  currentPallete.set(currentLetter, paletteColors[j]);
                  currentPalleteList.push(currentLetter);
                  ++j;
                }
              }
            }
          }
          currentPalleteList.reverse();
          for (let x of currentPalleteList.slice()) {
            if (currentPallete.size > newPalleteSize) {
              if (preserveMap.get(x) == null) {
                currentPallete.delete(x);
                currentPalleteList.splice(currentPalleteList.indexOf(x), 1);
              }
            }
            else {
              break;
            }
          }
          currentPalleteList.sort((a, b) => (preserveLetters.indexOf(a) - preserveLetters.indexOf(b)));
          currentPalleteList.reverse();
          for (let x of currentPalleteList.slice()) {
            if (currentPallete.size > newPalleteSize) {
              currentPallete.delete(x);
              currentPalleteList.splice(currentPalleteList.indexOf(x), 1);
            }
            else {
              break;
            }
          }
          currentPalleteList.sort();
          colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
        }
        else if (continueViewParam == false && !colorTaskCheckbox.checked) {
          colorsInfo.style.display = 'none';
        }

        let currentPalleteString = '';
        if (continueViewParam == false) {
          let g = 0;
          for (let k of currentPalleteList) {
            let v = currentPallete.get(k);
            k = k.toUpperCase();
            currentPalleteString = currentPalleteString.concat(`${k}<span style="background-color:${v};color:${v};" class="span-in-marquee cursor-pointer" onclick="javascript:changeColor(this)">${k}</span>`);
            ++g;
            if (g !== 0 && g % 5 == 0) {
              currentPalleteString = currentPalleteString.concat('<br><br>');
            }
            else {
              currentPalleteString = currentPalleteString.concat('  ');
            }
          }
        }

        if (palleteChanged || lastPosition == null || prevColorTaskCheckboxChecked != colorTaskCheckbox.checked || colorTaskCheckbox.checked && prevColorInputValue != colorInput.value || prevHtmlValue != textFromHtmlValue || prevDifficulty != difficultySelect.value || prevEliminating != eliminatingSelect.value || prevShufflingWords != shufflingWordsSelect.value) {
          let translateFunction = null;
          if (colorTaskCheckbox.checked) {
            translateFunction = function (symbol) {
              let currentSymbol = symbol.toLowerCase();
              let currentColor = currentPallete.get(currentSymbol);
              if (currentColor != null) {
                return `<span style="background-color:${currentColor};color:${currentColor};" class="span-in-marquee">${symbol}</span>`;
              }
              else {
                return symbol;
              }
            };
          }
          else {
            translateFunction = function (symbol) {
              return symbol;
            };
          }
          const bShuffle = (lastPosition == null || prevHtmlValue != textFromHtmlValue || prevDifficulty != difficultySelect.value || prevEliminating != eliminatingSelect.value || prevShufflingWords != shufflingWordsSelect.value);
          singleLineHtml = shuffleLetters(
            bShuffle ? textFromHtmlValue : singleLineText,
            textFromHtmlValue,
            bShuffle,
            translateFunction);
        }

        textElement.innerHTML = singleLineHtml;

        const containerWidth = Math.ceil(container.getBoundingClientRect().width);
        const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
        const startPosition = containerWidth;
        const endPosition = -textWidth;
        const oneStepSize = delayInfo.value > 100 ? ((delayInfo.value - 100) / 10 + 1) : 1;
        let stepTime = Math.max(0, Math.max(1, parseInt(speedInput.value, 10)));
        if (delayInfo.value < 20) {
          stepTime += (20 - Math.floor(delayInfo.value % 100)) * 20;
        }

        startTime = Date.now();
        lastTime = startTime;
        if (continueViewParam == false) {
          colorsInfo.innerHTML = currentPalleteString;
        }

        if (lastPosition == null || lastPosition <= endPosition) {
          lastPosition = startPosition;
        }
        textElement.style.left = lastPosition + 'px';
        let prevLastPosition = lastPosition;
        lastSavedPosition = lastPosition;

        prevHtmlValue = textFromHtmlValue;
        prevDifficulty = difficultySelect.value;
        prevShufflingWords = shufflingWordsSelect.value;
        prevEliminating = eliminatingSelect.value;
        prevColorInputValue = colorInput.value;
        prevColorTaskCheckboxChecked = colorTaskCheckbox.checked;

        let flag = continueViewParam;
        let curStartTime = continueViewParam ? startTime : Date.now();
        if (flag) {
          colorsInfo.style.display = 'none';
        }

        function animate() {
          const currentLeft = parseInt(textElement.style.left, 10) - oneStepSize;
          lastSavedPosition = currentLeft;

          lastTime = Date.now();
          let curStepTime = (lastTime - startTime) / Math.max(1e-9, prevLastPosition - currentLeft);
          if (!flag && lastTime - curStartTime >= 1000) {
            flag = true;
            colorsInfo.style.display = 'none';
          }
          let viewStepTime = Math.floor(curStepTime * 10) / 10, wpm = '';
          let seconds = Math.floor(viewStepTime * (currentLeft - endPosition) / 1000);
          let formattedSeconds = formatSeconds(seconds);
          durationInfo.innerHTML = formattedSeconds;
          if (numberOfWords > 5) {
            let sSeconds = Math.floor(viewStepTime * (startPosition - endPosition) / 1000);
            if (sSeconds >= 1) {
              wpm = '' + Math.max(1, Math.floor(numberOfWords / (sSeconds / 60)));
              durationInfo.innerHTML += `<br>WPM: ${wpm}`;
            }
          }
          let progress = Math.floor(100 * (1 - (currentLeft - endPosition) / (startPosition - endPosition)));
          durationInfo.innerHTML += `<br>Progress: ${progress}%`;

          if (currentLeft <= endPosition) {
            if (isLooping) {
              startTime = Date.now();
              lastPosition = startPosition;
              prevLastPosition = lastPosition;
              lastSavedPosition = null;
              textElement.style.left = lastPosition + 'px';
              if (animationId) {
                animationId = setTimeout(animate, stepTime);
              }
            }
            else {
              lastPosition = endPosition;
              prevLastPosition = lastPosition;
              lastSavedPosition = null;
              textElement.style.left = lastPosition + 'px';
              clearTimeout(animationId);
              animationId = null;
              startPauseButton.textContent = 'Start';
              startPauseButton.classList.remove('pause');
              inputContainer.style.display = '';
              otherSettingsContainer.style.display = '';
              //durationInfo.style.display = 'none';
              if (colorTaskCheckbox.checked) {
                colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
              }
              loopButton.style.display = '';
            }
          } else {
            textElement.style.left = currentLeft + 'px';
            lastPosition = currentLeft;
            lastSavedPosition = currentLeft;
            if (animationId) {
              animationId = setTimeout(animate, stepTime);
            }
          }
        }

        animationId = setTimeout(animate, stepTime);
        return true;
      }

      function startView(continueViewParam = false) {
        if (startAnimation(continueViewParam)) {
            loopButton.style.display = 'none';
            backButton.disabled = false;
            forwardButton.disabled = false;
            updateTextButton.disabled = false;
            updateColorsButton.disabled = false;
            copyTextButton.disabled = false;
            startPauseButton.textContent = 'Pause';
            startPauseButton.classList.add('pause');
            inputContainer.style.display = 'none';
            otherSettingsContainer.style.display = 'none';
            durationInfo.style.display = '';
          }
      }

      function pauseView() {
        if (animationId) {
          clearTimeout(animationId);
          animationId = null;
          startPauseButton.textContent = 'Start';
          startPauseButton.classList.remove('pause');
          inputContainer.style.display = '';
          otherSettingsContainer.style.display = '';
          //durationInfo.style.display = 'none';
          loopButton.style.display = '';
          if (colorTaskCheckbox.checked) {
            colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
          }
        }
      }

      function stopView() {
        const containerWidth = Math.ceil(container.getBoundingClientRect().width);
        if (animationId) {
          clearTimeout(animationId);
          animationId = null;
        }
        startPauseButton.textContent = 'Start';
        startPauseButton.classList.remove('pause');
        textElement.style.left = containerWidth + 'px';
        lastPosition = containerWidth;
        inputContainer.style.display = '';
        otherSettingsContainer.style.display = '';
        durationInfo.style.display = 'none';
        colorsInfo.style.display = 'none';
        loopButton.style.display = '';
        lastSavedPosition = null;
      }

      startPauseButton.addEventListener('click', function() {
        if (animationId) {
          pauseView();
        } else {
          startView();
        }
      });

      stopButton.addEventListener('click', function() {
        stopView();
      });

      document.addEventListener('keydown', function(e) {
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
        switch(e.key) {
          case ' ':  // Space bar toggles play/pause
            e.preventDefault();
            startPauseButton.dispatchEvent(new Event('click'));
            break;
          case 'ArrowLeft':  // Left arrow navigates backward
            e.preventDefault();
            if (lastPosition !== null) {
              backButton.dispatchEvent(new Event('click'));
            }
            break;
          case 'ArrowRight':  // Right arrow navigates forward
            e.preventDefault();
            if (lastPosition !== null) {
              forwardButton.dispatchEvent(new Event('click'));
            }
            break;
          case 'l':  // L toggles loop
          case 'L':
            e.preventDefault();
            loopButton.dispatchEvent(new Event('click'));
            break;
          case 'c':  // C toggles color encoder task
          case 'C':
            e.preventDefault();
            if (!animationId) {
              colorTaskCheckbox.checked = !colorTaskCheckbox.checked;
              colorTaskCheckbox.dispatchEvent(new Event('click'));
            }
            break;
          case 's':  // S toggles stop
          case 'S':
            e.preventDefault();
            stopButton.dispatchEvent(new Event('click'));
            break;
          case '+':  // + increases speed
            e.preventDefault();
            if (!animationId) {
              delayInfo.value = (parseInt(delayInfo.value) + 1);
              delayInfo.dispatchEvent(new Event('input'));
            }
            break;
          case '-':  // - decreases speed
            e.preventDefault();
            if (!animationId) {
              delayInfo.value = (parseInt(delayInfo.value) - 1);
              delayInfo.dispatchEvent(new Event('input'));
            }
            break;
          case 'Escape':  // ESC closes panels
            e.preventDefault();
            if (!animationId) {
              let checked = showTableCheckbox.checked || showTextCheckbox.checked;
              showTableCheckbox.checked = !checked;
              showTableCheckbox.dispatchEvent(new Event('click'));
              showTextCheckbox.checked = !checked;
              showTextCheckbox.dispatchEvent(new Event('click'));
            }
            break;
        }
      });

      try {
        lastSavedPosition = localStorage.getItem('sle_last_position');
        text = localStorage.getItem('sle_text');
        if (lastSavedPosition && text) {
          lastSavedPosition = parseInt(lastSavedPosition);
          if (confirm("Would you like to resume reading from your last position?")) {
            lastPosition = prevLastPosition = lastSavedPosition;
            setTimeout(function () {
              startView(false);
              pauseView();
            }, 1);
          }
          else {
            lastSavedPosition = null;
          }
        }
        else {
          lastSavedPosition = null;
        }
      } catch (err) {
        console.error(err);
        lastSavedPosition = null;
      }

      setInterval(function () {
        if (lastSavedPosition != null) {
          localStorage.setItem('sle_last_position', lastSavedPosition);
        }
        else if (localStorage.getItem('sle_last_position')) {
          localStorage.removeItem('sle_last_position');
        }
      }, 500);

    });

  </script>
</body>
</html>