<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trial and Error Reading</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <script src="sentences/merriam_webster.js" type="text/javascript"></script>
  <script src="sentences/wordsmyth1.js" type="text/javascript"></script>
  <script src="sentences/wordsmyth2.js" type="text/javascript"></script>
  <script src="sentences/wordsmyth3.js" type="text/javascript"></script>
  <style>
    :root {
      --background-color: #eeeeee;
      --text-color: #333;
      --container-background: #efefef;
      --border-color: rgb(90, 90, 90);
      --border-color-inv: #e0e0e0;
      --green-button-background: rgb(25, 135, 84);
      --green-button-hover: rgb(21, 115, 71);
      --purple-button-background: rgb(84, 25, 135);
      --purple-button-hover: rgb(71, 21, 115);
      --chocolate-button-background: rgb(102, 52, 46);
      --chocolate-button-hover: rgb(84, 43, 38);
      --dark-cyan-button-background: rgb(25, 103, 134);
      --dark-cyan-button-hover: rgb(21, 89, 116);
      --dark-blue-button-background: rgb(25, 48, 134);
      --dark-blue-button-hover: rgb(21, 42, 116);
      --orange-button-background: rgb(218, 104, 11);
      --orange-button-hover: rgb(194, 93, 10);
      --red-button-background: rgb(187, 45, 59);
      --red-button-hover: rgb(180, 25, 46);
      --cyan-button-background: rgb(11, 166, 197);
      --cyan-button-hover: rgb(9, 130, 153);
      --gray-button-background: rgb(200, 200, 200);
      --gray-button-text: rgb(0, 0, 0);
      --gray-button-hover: rgb(210, 210, 210);
      --gray-button-disabled-background: rgb(230, 230, 230);
      --gray-button-disabled-text: rgb(173, 173, 173);
      --blue-button-background: rgb(13, 110, 253);
      --blue-button-hover: rgb(11, 94, 215);
      --dark-button-background: rgb(55, 55, 55);
      --dark-button-hover: rgb(66, 70, 73);
    }

    body.dark {
      --background-color: #1a1a1a;
      --text-color: #e0e0e0;
      --container-background: #2a2a2a;
      --border-color: #e0e0e0;
      --border-color-inv: rgb(90, 90, 90);
      --gray-button-background: rgb(90, 90, 90);
      --gray-button-text: rgb(255, 255, 255);
      --gray-button-hover: rgb(80, 80, 80);
      --gray-button-disabled-background: rgb(90, 90, 90);
      --gray-button-disabled-text: rgb(70, 70, 70);
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    span {
      unicode-bidi: embed;
    }

    .container.normal-size {
      max-width: 1000px;
      margin: 0 auto;
    }

    .container.max-size {
      max-width: 100%;
      margin: 0 auto;
    }

    #marquee-controls-container,
    #marquee-container,
    #controls-container,
    #text-to-speech-container,
    #additional-settings-container {
      text-align: center;
    }

    label {
      display: block;
      padding-top: 5px;
      padding-bottom: 5px;
    }

    #text-input {
      width: 100%;
      min-height: 300px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: var(--container-background);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    #color-input {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: var(--container-background);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    #marquee-container {
      width: 100%;
      height: 60px;
      overflow: hidden;
      position: relative;
      border: 2px solid var(--border-color);
      padding-left: 2px;
      padding-right: 2px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      direction: ltr;
      background-color: var(--container-background);
    }

    #marquee-display {
      position: absolute;
      white-space: nowrap;
      line-height: 60px;
      text-align: right;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin: 2px;
      background-color: var(--gray-button-background);
      color: white;
    }

    .green-button {
      background-color: var(--green-button-background);
    }

    .green-button:hover {
      background-color: var(--green-button-hover);
    }

    .purple-button {
      background-color: var(--purple-button-background);
    }

    .purple-button:hover {
      background-color: var(--purple-button-hover);
    }

    .chocolate-button {
      background-color: var(--chocolate-button-background);
    }

    .chocolate-button:hover {
      background-color: var(--chocolate-button-hover);
    }

    .dark-cyan-button {
      background-color: var(--dark-cyan-button-background);
    }

    .dark-cyan-button:hover {
      background-color: var(--dark-cyan-button-hover);
    }

    .dark-blue-button {
      background-color: var(--dark-blue-button-background);
    }

    .dark-blue-button:hover {
      background-color: var(--dark-blue-button-hover);
    }

    .orange-button {
      background-color: var(--orange-button-background);
    }

    .orange-button:hover {
      background-color: var(--orange-button-hover);
    }

    .red-button {
      background-color: var(--red-button-background);
    }

    .red-button:hover {
      background-color: var(--red-button-hover);
    }

    .cyan-button {
      background-color: var(--cyan-button-background);
    }

    .cyan-button:hover {
      background-color: var(--cyan-button-hover);
    }

    .blue-button {
      background-color: var(--blue-button-background);
    }

    .blue-button:hover {
      background-color: var(--blue-button-hover);
    }

    .dark-button {
      background-color: var(--dark-button-background);
    }

    .dark-button:hover {
      background-color: var(--dark-button-hover);
    }

    .gray-button {
      background-color: var(--gray-button-background);
      color: var(--gray-button-text);
    }

    .gray-button:hover {
      background-color: var(--gray-button-hover);
    }

    .gray-button-disabled:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    #color-details {
      font-size: 22px;
    }

    #play-pause-button, #stop-button, #speak-button, #search-button, #bookmarks-button {
      min-width: 100px;
    }

    #play-pause-button {
      background-color: var(--green-button-background);
    }
    
    #play-pause-button:hover {
      background-color: var(--green-button-hover);
    }

    #play-pause-button.pause {
      background-color: var(--orange-button-background);
    }

    #play-pause-button.pause:hover {
      background-color: var(--orange-button-hover);
    }

    #play-pause-button:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    #stop-button {
      background-color: var(--red-button-background);
    }

    #stop-button:hover {
      background-color: var(--red-button-hover);
    }

    #stop-button:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    .marquee-letter-span {
      box-sizing: border-box;
      display: inline-block;
    }

    .marquee-word-span {
      display: inline-block;
    }

    body.marquee-theme-1 .marquee-letter-span {
      border-left: 1px dashed var(--border-color-inv);
      border-right: 1px dashed var(--border-color-inv);
    }

    body.marquee-theme-2 .marquee-letter-span,
    body.marquee-theme-3 .marquee-letter-span,
    body.marquee-theme-4 .marquee-letter-span {
      border-left: 1px solid var(--border-color-inv);
      border-right: 1px solid var(--border-color-inv);
    }

    body.marquee-theme-3 .marquee-word-span {
      border-left: 1px solid var(--border-color);
      border-right: 1px solid var(--border-color);
    }

    body.marquee-theme-4 .marquee-word-span {
      border-left: 2px solid var(--border-color);
      border-right: 2px solid var(--border-color);
    }

    body.marquee-theme-1 #marquee-display {
      letter-spacing: 1px;
      word-spacing: 1px;
    }

    body.marquee-theme-2 #marquee-display {
      letter-spacing: 3px;
      word-spacing: 20px;
    }

    body.marquee-theme-3 #marquee-display {
      letter-spacing: 5px;
      word-spacing: 25px;
    }

    body.marquee-theme-4 #marquee-display {
      letter-spacing: 5px;
      word-spacing: 30px;
    }

    #speed-display,
    #font-size-display {
      text-align: center;
    }

    input[type="text"],
    input[type="number"],
    select {
      padding: 8px 4px;
      text-align: center;
    }

    .clickable {
      cursor: pointer;
    }

    #letter-shuffle-select,
    #letter-skip-select,
    #letter-elimination-select,
    #word-shuffle-select,
    #word-skip-select {
      min-width: 150px;
    }

    .select-label {
      min-width: 150px;
      display: inline-block;
    }

    input[type="range"] {
      width: 225px;
      padding: 0 4px;
    }

    input[type="number"] {
      width: 70px;
    }

    input[type="checkbox"] {
      transform: scale(1.4);
      margin: 7px 4px;
    }

    kbd {
      border: 1px solid;
      border-radius: 3px;
      padding: 1px 4px;
      font-size: 12px;
      font-family: monospace;
    }

    body.light kbd {
      background-color: rgb(200, 200, 200);
      border-color: rgb(90, 90, 90);
      color: #333;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    body.dark kbd {
      background-color: rgb(60, 60, 60);
      border-color: rgb(200, 200, 200);
      color: #e0e0e0;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    a {
      text-decoration: none;
      font-weight: bold;
    }

    body.light a {
      color: #aaa;
    }

    body.light a:hover {
      color: #555;
    }

    body.dark a {
      color: #555;
    }

    body.dark a:hover {
      color: #aaa;
    }

    .mt-10 {
      margin-top: 10px;
    }

    .mt-20 {
      margin-top: 20px;
    }

    .mb-10 {
      margin-bottom: 10px;
    }

    .mb-20 {
      margin-bottom: 20px;
    }

    #tab-navigation {
      display: flex;
      justify-content: space-around;
    }

    .tab-button {
      flex: 1;
      padding: 10px;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    body.light .tab-button {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
    }

    body.light .tab-button.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark .tab-button {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
    }

    body.dark .tab-button.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    .tab-content {
      display: none;
      text-align: center;
    }

    .tab-content.active {
      display: block;
    }

    .items-border {
      border-radius: 10px;
      padding: 2px;
    }

    body.light .items-border {
      border: 2px solid rgb(230, 230, 230);
    }

    body.light .items-border.active {
      border: 2px solid rgb(200, 200, 200);
    }

    body.dark .items-border {
      border: 2px solid rgb(90, 90, 90);
    }

    body.dark .items-border.active {
      border: 2px solid rgb(90, 90, 90);
    }

    body.light #loop-toggle {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
      min-width: 70px;
    }

    body.light #loop-toggle.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark #loop-toggle {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
      min-width: 70px;
    }

    body.dark #loop-toggle.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    #progress-bar-container {
      width: 100%;
      height: 20px;
      background-color: var(--container-background);
      border: 1px solid var(--border-color);
      position: relative;
      cursor: pointer;
      margin-bottom: 5px;
    }

    #progress-bar {
      height: 100%;
      background-color: var(--green-button-background);
      width: 0%;
      transition: width 0.1s linear;
    }

    body.dark #progress-bar {
      background-color: var(--green-button-hover);
    }

    #info-tab ul {
      list-style-type: disc;
      padding-left: 20px;
      text-align: left;
      max-width: 600px;
      margin: 0 auto;
    }
    #info-tab li {
      margin-bottom: 10px;
    }

    #settings-profile-select, #text-select, #voice-select {
      min-width: 20%;
      max-width: 50%;
      padding: 8px;
      text-align: center;
    }

    .speak-mark {
      position: absolute;
      width: 3px;
      height: 100%;
      background-color: var(--border-color);
      z-index: 10;
    }

    .search-highlight {
      background-color: #ffff99;
      color: black;
    }

    .search-highlight.active {
      background-color: #ffcc00;
      font-weight: bold;
    }

    .search-mark {
      position: absolute;
      width: 2px;
      height: 100%;
      background-color: rgb(245,245,245);
      z-index: 10;
    }

    .search-mark.active {
      background-color: rgb(112,128,144);
      width: 3px;
    }

    .bookmark-item {
      align-items: center;
      display: block;
      margin-top: 10px;
      margin-bottom: 10px;
    }

    .bookmark-name {
      min-width: 70%;
      max-width: 100%;
      display: inline-block;
      word-wrap: break-word;
      vertical-align: middle;
    }
    
    .bookmark-remove-button {
      min-width: 25%;
      max-width: 100%;
      display: inline-block;
      vertical-align: middle;
    }

    .bookmark-mark {
      position: absolute;
      width: 2px;
      height: 100%;
      background-color: rgb(255, 127, 36);
      cursor: pointer;
    }

    #bookmarks-list {
      max-width: 400px;
      margin: 0 auto;
    }

    button:active {
      transform: scale(0.99);
    }

    hr {
      background-color: var(--border-color-inv);
      height: 1px;
      border: 0;
    }

    @media (max-width: 600px) {
      button {
        width: 100%;
        margin: 10px 0;
      }
      kbd {
        display: none;
      }
      #settings-profile-select, #text-select, #voice-select {
        min-width: 100%;
        max-width: 100%;
      }
      input[type="range"] {
        width: 30%;
        margin-right: 25%;
      }
      input[type="number"] {
        width: 30%;
      }
      select {
        width: 100%;
      }
      #tab-navigation {
        flex-direction: column;
        border: 5px solid var(--border-color-inv);
        border-radius: 10px;
        padding: 2px;
        margin-bottom: 10px;
      }
      .tab-button {
        margin-bottom: 5px;
      }
      .bookmark-name {
        margin-top: 10px;
      }
      .bookmark-remove-button {
        margin: 10px 0px 0px 0px;
        padding: 5px;
      }
      #bookmark-name-input {
        margin-top: 30px;
      }
    }
  </style>
</head>
<body class="dark">
  <div id="main-container" class="container normal-size">
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>

    <div id="marquee-container" class="mt-20">
      <span id="marquee-display"></span>
    </div>

    <div id="controls-container" class="mt-10">
      <div>
        <button id="rewind-button" class="gray-button gray-button-disabled" disabled>&lt;&lt; <kbd>←</kbd></button>
        <button id="play-pause-button">Start <kbd>Space</kbd></button>
        <button id="stop-button">Stop <kbd>S</kbd></button>
        <button id="fast-forward-button" class="gray-button gray-button-disabled" disabled>&gt;&gt; <kbd>→</kbd></button>
      </div>
      <div id="text-to-speech-container">
        <button id="speak-button" class="purple-button gray-button-disabled">Speak</button>
      </div>
      <div id="search-container">
        <button id="search-button" class="dark-blue-button gray-button-disabled">Search</button>
        <div id="search-controls" class="items-border" style="display: none;">
            <input type="text" id="search-input" class="mt-10 mb-10" placeholder="Enter search query...">
            <button id="search-prev-button" class="gray-button gray-button-disabled">Previous</button>
            <button id="search-next-button" class="gray-button gray-button-disabled">Next</button>
        </div>
      </div>
      <div id="bookmarks-container">
        <button id="bookmarks-button" class="chocolate-button gray-button-disabled">Bookmarks</button>
        <div id="bookmarks-controls" style="display: none;">
          <div>
            <button id="save-bookmarks-button" class="green-button gray-button-disabled">Save bookmarks</button>
            <button id="cancel-bookmarks-button" class="red-button gray-button-disabled">Cancel</button>
          </div>
          <div>
            <input type="text" id="bookmark-name-input" placeholder="Bookmark name">
            <button id="add-bookmark-button">Add Bookmark</button>
          </div>
          <div id="bookmarks-list"></div>
        </div>
      </div>
      <div id="under-controls-container">
        <button id="loop-toggle" class="gray-button gray-button-disabled">Loop <kbd>L</kbd></button>
        <div id="progress-display" class="mt-10" style="display: none;"></div>
        <div id="color-details" class="mt-10" style="display: none;"></div>
      </div>
    </div>

    <div id="tab-navigation" class="mt-10" role="tablist">
      <button class="tab-button active" data-tab="manipulations-tab" role="tab" aria-selected="true">Manipulations</button>
      <button class="tab-button" data-tab="texts-tab" role="tab" aria-selected="false">Texts</button>
      <button class="tab-button" data-tab="settings-tab" role="tab" aria-selected="false">Settings</button>
      <button class="tab-button" data-tab="info-tab" role="tab" aria-selected="false">Information</button>
    </div>

    <div id="tab-content">
      <div id="manipulations-tab" class="tab-content active items-border">
        <div class="mt-10">
          <select id="settings-profile-select"></select>
          <button id="new-settings-profile-button" class="green-button gray-button-disabled">New Settings</button>
          <button id="duplicate-settings-profile-button" class="dark-cyan-button gray-button-disabled">Duplicate Settings</button>
          <button id="save-settings-profile-button" class="blue-button gray-button-disabled">Save Settings</button>
          <button id="delete-settings-profile-button" class="dark-button gray-button-disabled">Delete Settings</button>
        </div>
        <div id="marquee-controls-container" class="mt-10">
          <button id="refresh-text" class="gray-button gray-button-disabled" disabled>↻ Text ↻ <kbd>T</kbd></button>
          <button id="refresh-colors" class="gray-button gray-button-disabled" disabled>↻ Colors ↻ <kbd>C</kbd></button>
          <button id="copy-marquee-text" class="gray-button gray-button-disabled" disabled>⏏ Copy text ⏏</button>
        </div>
        <div class="mt-10">
          <label>Text size</label>
          <input type="range" id="font-size-slider" min="8" max="50" value="50">
          <input type="number" id="font-size-display" min="8" max="50" value="50">
        </div>
        <div class="mt-10">
          <label>Speed <kbd>+</kbd><kbd>-</kbd></label>
          <input type="range" id="speed-slider" min="1" max="200" value="100">
          <input type="number" id="speed-display" min="1" max="200" value="100">
        </div>
        <div class="mt-10">
          <span class="select-label">Skipping letters:</span>
          <select id="letter-skip-select">
            <option value="no">-</option>
            <option value="10%_letters">10%</option>
            <option value="20%_letters">20%</option>
            <option value="30%_letters">30%</option>
            <option value="40%_letters">40%</option>
            <option value="50%_letters">50%</option>
            <option value="60%_letters">60%</option>
            <option value="70%_letters">70%</option>
            <option value="80%_letters">80%</option>
            <option value="90%_letters">90%</option>
            <option value="100%_letters">Almost all letters</option>
          </select>
        </div>
        <div class="mt-10">
          <span class="select-label">Shuffling letters:</span>
          <select id="letter-shuffle-select">
            <option value="no">-</option>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="medium_plus">Medium+</option>
            <option value="hard">Hard</option>
            <option value="very-hard">Very Hard</option>
          </select>
        </div>
        <div class="mt-10">
          <span class="select-label">Eliminating letters:</span>
          <select id="letter-elimination-select">
            <option value="no">-</option>
            <option value="20%_vowels">20% vowels</option>
            <option value="40%_vowels">40% vowels</option>
            <option value="60%_vowels">60% vowels</option>
            <option value="80%_vowels">80% vowels</option>
            <option value="100%_vowels">Almost all vowels</option>
            <option value="10%_random">10% smart-random</option>
            <option value="20%_random">20% smart-random</option>
            <option value="30%_random">30% smart-random</option>
            <option value="40%_random">40% smart-random</option>
            <option value="50%_random">50% smart-random</option>
          </select>
        </div>
        <div class="mt-10">
          <span class="select-label">Skipping words:</span>
          <select id="word-skip-select">
            <option value="no">-</option>
            <option value="5%_words">5%</option>
            <option value="10%_words">10%</option>
            <option value="15%_words">15%</option>
            <option value="20%_words">20%</option>
            <option value="25%_words">25%</option>
            <option value="30%_words">30%</option>
            <option value="35%_words">35%</option>
            <option value="40%_words">40%</option>
            <option value="45%_words">45%</option>
            <option value="50%_words">50%</option>
            <option value="55%_words">55%</option>
            <option value="60%_words">60%</option>
            <option value="65%_words">65%</option>
            <option value="70%_words">70%</option>
            <option value="75%_words">75%</option>
            <option value="80%_words">80%</option>
            <option value="85%_words">85%</option>
            <option value="90%_words">90%</option>
            <option value="95%_words">95%</option>
            <option value="100%_words">100%</option>
          </select>
        </div>
        <div class="mt-10">
          <span class="select-label">Shuffling words:</span>
          <select id="word-shuffle-select">
            <option value="no">-</option>
            <option value="2_words">Two words</option>
            <option value="3_words">Three words</option>
            <option value="4_words">Four words</option>
            <option value="5_words">Five words</option>
          </select>
        </div>
        <div id="color-encoder-div" class="mt-10">
          <label><input type="checkbox" id="color-encoder-toggle" checked> Color encoder task <kbd>E</kbd></label>
          <div id="color-encoder-options" class="mt-10">
            <span>Number of letters:</span>
            <input type="number" id="color-letter-count" min="0" max="32" value="1">
          </div>
          <button id="dump-colors" class="mt-10" class="gray-button gray-button-disabled">Dump colors</button>
          <textarea id="color-input" placeholder="&lt;letter&gt; &lt;color&gt;&#13;&#10;a rgb(0, 0, 0)&#13;&#10;b red&#13;&#10;..."></textarea>
        </div>
        <div class="mt-10">
        </div>
      </div>
      <div id="texts-tab" class="tab-content items-border">
        <div class="mt-10">
          <select id="text-select">
          </select>
          <button id="new-text-button" class="green-button gray-button-disabled">New Text</button>
          <button id="duplicate-text-button" class="dark-cyan-button gray-button-disabled">Duplicate Text</button>
          <button id="save-text-button" class="blue-button gray-button-disabled">Save Text</button>
          <button id="delete-text-button" class="dark-button gray-button-disabled">Delete Text</button>
        </div>
        <div class="mt-10">
          <label>Text</label>
          <textarea id="text-input" placeholder="Enter text here"></textarea>
        </div>
        <div class="mt-10">
          <div>
            <button id="load-file">Load text file</button>
            <button id="copy-current-text">Copy text</button>
          </div>
          <div>
            <button id="randomize-paragraphs" class="dark-button gray-button-disabled">Randomize paragraphs</button>
            <button id="randomize-sentences" class="dark-button gray-button-disabled">Randomize sentences</button>
          </div>
          <div class="mt-10 items-border">
            <label>English random sentences</label>
            <div>
              <label for="sentence-count-input">Number of sentences:<input type="number" id="sentence-count-input" min="1" max="10000" value="1"></label>
            </div>
            <div>
              <button id="load-sentence-wordsmyth-beginner">[En] Wordsmyth Beginner's dictionary [6153]</button>
            </div>
            <div>
              <button id="load-sentence-wordsmyth-intermediate">[En] Wordsmyth Intermediate dictionary [13438]</button>
            </div>
            <div>
              <button id="load-sentence-wordsmyth-advanced">[En] Wordsmyth Advanced dictionary [21394]</button>
            </div>
            <div>
              <button id="load-sentence-merriam-webster">[En] Merriam-Webster dictionary [10668]</button>
            </div>
            <hr>
            <div>
              <button id="load-wiki">[En] Wiki random summary</button>
            </div>
            <div>
              <button id="load-underthekey">[En] Underthekey random sentence</button>
            </div>
            <div>
              <button id="load-metaphorpsum" style="display: none;">[En] Metaphorpsum random sentence</button>
            </div>
          </div>
          <label><input type="checkbox" id="append-text-toggle" checked>Append text after loading/fetching</label>
        </div>
        <div class="mt-10">
          <button id="clear-text" class="dark-button gray-button-disabled">Clear</button>
        </div>
      </div>
      <div id="settings-tab" class="tab-content items-border">
        <div class="mt-10 items-border">
          <label>Appearance</label>
          <label id="show-color-info-element"><input type="checkbox" id="show-color-info-toggle" checked> Show Letters-Colors <kbd>ESC</kbd></label>
          <label id="show-speak-button-element"><input type="checkbox" id="show-speak-button-toggle" checked> Show Speak button</label>
          <label id="show-bookmarks-button-element"><input type="checkbox" id="show-bookmarks-button-toggle" checked> Show Bookmarks button</label>
          <label id="show-search-button-element"><input type="checkbox" id="show-search-button-toggle" checked> Show Search button</label>
          <div>
            <button id="marquee-theme-toggle" class="cyan-button gray-button-disabled">Toggle Marquee Text Block Theme</button>
            <button id="theme-toggle" class="cyan-button gray-button-disabled">Toggle Theme</button>
            <button id="full-size-toggle" class="cyan-button gray-button-disabled">Toggle Full Size</button>
          </div>
        </div>
        <div class="mt-10 items-border">
          <label>Text-to-Speech</label>
          <div>
            <select id="voice-select"></select>
          </div>
          <label class="mt-10">Speed</label>
          <input type="range" id="speech-rate-slider" min="1" max="300" step="1" value="100">
          <input type="number" id="speech-rate-display" min="1" max="300" step="1" value="100">
          <div>
            <label><input type="checkbox" id="faster-transitions-toggle" checked>Faster transitions between sentences</label>
          </div>
        </div>
        <div class="mt-10 items-border">
          <label>Import</label>
          <div>
            <label><input type="checkbox" id="import-replace-toggle" checked>Replace current data when provided</label>
          </div>
          <div>
            <button id="import-all-settings-profiles" class="dark-button gray-button-disabled">Import all settings profiles</button>
            <button id="import-all-texts" class="dark-button gray-button-disabled">Import all texts</button>
          </div>
          <div>
            <button id="import-all-settings-profiles-and-texts" class="dark-button gray-button-disabled">Import all settings profiles and texts</button>
            <button id="import-all" class="dark-button gray-button-disabled">Import all</button>
          </div>
        </div>
        <div class="mt-10 items-border">
          <label>Export</label>
          <div>
            <label><input type="checkbox" id="export-all-texts-with-bookmarks-toggle" checked>Export texts with bookmarks</label>
          </div>
          <div>
            <button id="export-all-settings-profiles" class="dark-button gray-button-disabled">Export all settings profiles</button>
            <button id="export-all-texts" class="dark-button gray-button-disabled">Export all texts</button>
          </div>
          <div>
            <button id="export-all-settings-profiles-and-texts" class="dark-button gray-button-disabled">Export all settings profiles and texts</button>
            <button id="export-all" class="dark-button gray-button-disabled">Export all</button>
          </div>
        </div>
        <div class="mt-10 items-border">
          <label>Delete</label>
          <div>
            <button id="delete-all-settings-profiles" class="dark-button gray-button-disabled">Delete all settings profiles</button>
            <button id="delete-all-texts" class="dark-button gray-button-disabled">Delete all texts</button>
          </div>
          <div>
            <button id="delete-database" class="dark-button gray-button-disabled">Delete the entire database</button>
          </div>
        </div>
      </div>
      <div id="info-tab" class="tab-content items-border">
        <div class="mt-20">
            <p>Here are some tips and recommendations to help you effectively use this website:</p>
            <ul>
                <li><strong>Resist checking answers too soon:</strong> Avoid looking up the solution until you're certain you don't know a word or have spent enough time trying to figure it out.</li>
                <li><strong>Take breaks:</strong> Regular breaks can improve your problem-solving efficiency and keep your mind fresh.</li>
                <li><strong>Be patient with progress:</strong> Improvements may take months and depends on how often you train, as well as your diet and sleep quality.</li>
                <li><strong>Short sessions are key:</strong> Training twice a day in short bursts is more effective than one long session daily.</li>
                <li><strong>Quality over quantity:</strong> Fully solving a few sentences per day is better than partially solving many.</li>
                <li><strong>Challenge yourself:</strong> Solving without changing the text combination on the go (via "↻ Text ↻" button) is harder and more beneficial than adjusting it mid-session.</li>
                <li><strong>Increase difficulty:</strong> Continuously ramp up the exercise difficulty to maintain progress, rather than staying at an easy level for too long.</li>
            </ul>
        </div>
        <div class="mb-20"></div>
        <a href="https://github.com/Quwarm/Trial-and-Error-Reading" target="_blank">GitHub</a>
      </div>
    </div>
  </div>

  <div id="text-helper" style="display: none;"></div>

  <script>
    const MarqueeReader = {
      animationTimer: null,
      currentPosition: null,
      animationStartTime: null,
      lastUpdateTime: null,
      colorMap: new Map(),
      colorList: [],

      previousText: null,
      previousLetterShuffle: '',
      previousLetterSkip: '',
      previousWordShuffle: '',
      previousWordSkip: '',
      previousLetterElimination: '',
      previousColorInput: '',
      previousPosition: null,

      wasColorTaskEnabled: null,
      wasColorTaskChecked: true,
      isLoopEnabled: false,
      wordCount: 0,
      lastSavedPosition: null,
      lastSavedPositionUpdateDelay: 500,

      elements: {},

      databaseName: 'TrialAndErrorReadingDB',
      databaseVersion: 2,
      database: null,
      defaultTextName: 'Default',
      currentTextName: 'Default',
      currentTextBookmarks: [],
      textIsModified: false,
      defaultSettingsProfileName: 'Default',
      currentSettingsProfileName: 'Default',
      settingsProfileIsModified: false,
      deleteDatabaseViewCounter: 0,
      deleteDatabaseViewMax: 3,

      vowelPattern: null,
      letterPattern: null,
      punctuationPattern: null,

      cachedContainerWidth: null,
      cachedTextWidth: null,

      isSpeaking: false,
      speechSynthesis: null,
      currentVoice: null,
      voices: [],
      speechRate: 100,

      isSearchActive: false,
      searchQuery: '',
      searchMatches: [],
      currentMatchIndex: -1,
      textToSearch: '',

      isBookmarksActive: false,
      tmpBookmarks: [],

      themes: [
        'dark',
        'light'
      ],

      marqueeThemes: [
        'marquee-theme-1',
        'marquee-theme-2',
        'marquee-theme-3',
        'marquee-theme-4'
      ],

      sentenceWordsmyth1Generator: null,
      sentenceWordsmyth2Generator: null,
      sentenceWordsmyth3Generator: null,
      sentenceMerriamWebsterGenerator: null,

      settingsNames: {
        // texts
        currentTextName: 'sle_current_text_name',
        text: 'sle_text',
        textBookmarks: 'sle_text_bookmarks',
        texts: 'sle_texts',

        // settings profiles
        currentSettingsProfile: 'sle_current_settings_profile',
        settingsProfile: 'sle_settings_profile',
        settingsProfiles: 'sle_settings_profiles',

        // profile settings
        colorTaskToggle: 'sle_color_task_toggle',
        colorTaskLetters: 'sle_color_task_letters',
        colorTaskColors: 'sle_color_task_colors',
        speed: 'sle_speed',
        shufflingLetters: 'sle_shuffling_letters',
        skippingLetters: 'sle_skipping_letters',
        shufflingWords: 'sle_shuffling_words',
        skippingWords: 'sle_skipping_words',
        eliminatingLetters: 'sle_eliminating_letters',
        textSize: 'sle_text_size',

        // non-profile settings
        showColorInfoToggle: 'sle_show_color_info_toggle',
        appendTextToggle: 'sle_append_text_toggle',
        importReplaceToggle: 'sle_import_replace_toggle',
        fasterTransitionsToggle: 'sle_faster_transitions_toggle',
        exportTextsWithBookmarksToggle: 'sle_export_texts_with_bookmarks_toggle',
        sentenceCountToGenerate: 'sle_sentence_count_to_generate',
        loop: 'sle_loop',
        theme: 'sle_theme',
        marqueeThemeToggle: 'sle_marquee_theme_toggle',
        appSizeToggle: 'sle_app_size_toggle',
        activeTab: 'sle_active_tab',
        lastPosition: 'sle_last_position',

        // text-to-speech
        voiceButton: 'sle_voice_button',
        voice: 'sle_voice',
        voiceSpeechRate: 'sle_voice_speech_rate',

        // search
        searchButton: 'sle_search_button',

        // bookmarks
        bookmarksButton: 'sle_bookmarks_button',
      },

      getDefaultSettingsProfile() {
        const settings = {};
        settings[this.settingsNames.colorTaskToggle] = false;
        settings[this.settingsNames.colorTaskLetters] = '1';
        settings[this.settingsNames.colorTaskColors] = '';
        settings[this.settingsNames.speed] = '90';
        settings[this.settingsNames.shufflingLetters] = 'no';
        settings[this.settingsNames.skippingLetters] = 'no';
        settings[this.settingsNames.shufflingWords] = 'no';
        settings[this.settingsNames.skippingWords] = 'no';
        settings[this.settingsNames.eliminatingLetters] = 'no';
        settings[this.settingsNames.textSize] = '42';
        return settings;
      },

      getCurrentSettingsProfile() {
        const settings = {};
        settings[this.settingsNames.colorTaskToggle] = this.elements.colorEncoderToggle.checked;
        settings[this.settingsNames.colorTaskLetters] = this.elements.colorLetterCount.value;
        settings[this.settingsNames.colorTaskColors] = this.elements.colorInput.value;
        settings[this.settingsNames.speed] = this.elements.speedDisplay.value;
        settings[this.settingsNames.shufflingLetters] = this.elements.letterShuffleSelect.value;
        settings[this.settingsNames.skippingLetters] = this.elements.letterSkipSelect.value;
        settings[this.settingsNames.shufflingWords] = this.elements.wordShuffleSelect.value;
        settings[this.settingsNames.skippingWords] = this.elements.wordSkipSelect.value;
        settings[this.settingsNames.eliminatingLetters] = this.elements.letterEliminationSelect.value;
        settings[this.settingsNames.textSize] = this.elements.fontSizeDisplay.value;
        return settings;
      },

      setSettingsProfile(settingsProfileData) {
        const defaultSettings = this.getDefaultSettingsProfile();
        const keys = Object.keys(settingsProfileData);

        let currentKey = this.settingsNames.colorTaskToggle;
        this.elements.colorEncoderToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.colorTaskLetters;
        this.elements.colorLetterCount.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.colorTaskColors;
        this.elements.colorInput.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.speed;
        this.elements.speedDisplay.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.shufflingLetters;
        this.elements.letterShuffleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skippingLetters;
        this.elements.letterSkipSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.shufflingWords;
        this.elements.wordShuffleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skippingWords;
        this.elements.wordSkipSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.eliminatingLetters;
        this.elements.letterEliminationSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.textSize;
        this.elements.fontSizeDisplay.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        this.adjustSpeed(this.elements.speedDisplay.value);
        this.adjustFontSize(this.elements.fontSizeDisplay.value);
        this.toggleColorEncoder();
      },

      initialize() {
        const currentReader = this;
        console.info(currentReader);
        currentReader.loadBackground();
        currentReader.cacheElements();
        try {
          currentReader.speechSynthesis = window.speechSynthesis;
          currentReader.loadVoices();
          currentReader.loadDb(function () {
            try {
              currentReader.setupPatterns();
              currentReader.bindEvents();
              currentReader.loadPreferences();
            }
            catch (err) {
              console.error(err);
              currentReader.elements.mainContainer.innerHTML = `Not supported:<br>${err}`;
            }
          });
        }
        catch (err) {
          console.error(err);
          currentReader.elements.mainContainer.innerHTML = `Not supported:<br>${err}`;
        }
      },

      loadBackground() {
        this.elements.body = document.body;
        this.elements.body.classList.remove('light');
        this.elements.body.classList.remove('dark');
        this.elements.body.classList.add(localStorage.getItem(this.settingsNames.theme) || this.themes[0]);
      },

      cacheElements() {
        this.elements.mainContainer = document.getElementById('main-container');
        this.elements.textInput = document.getElementById('text-input');
        this.elements.speedSlider = document.getElementById('speed-slider');
        this.elements.speedDisplay = document.getElementById('speed-display');
        this.elements.progressDisplay = document.getElementById('progress-display');
        this.elements.colorDetails = document.getElementById('color-details');
        this.elements.appendTextToggle = document.getElementById('append-text-toggle');
        this.elements.letterShuffleSelect = document.getElementById('letter-shuffle-select');
        this.elements.letterEliminationSelect = document.getElementById('letter-elimination-select');
        this.elements.letterSkipSelect = document.getElementById('letter-skip-select');
        this.elements.wordShuffleSelect = document.getElementById('word-shuffle-select');
        this.elements.wordSkipSelect = document.getElementById('word-skip-select');
        this.elements.marqueeDisplay = document.getElementById('marquee-display');
        this.elements.marqueeControlsContainer = document.getElementById('marquee-controls-container');
        this.elements.marqueeContainer = document.getElementById('marquee-container');
        this.elements.playPauseButton = document.getElementById('play-pause-button');
        this.elements.stopButton = document.getElementById('stop-button');
        this.elements.themeToggle = document.getElementById('theme-toggle');
        this.elements.fullSizeToggle = document.getElementById('full-size-toggle');
        this.elements.deleteAllSettingsProfiles = document.getElementById('delete-all-settings-profiles');
        this.elements.deleteAllTexts = document.getElementById('delete-all-texts');
        this.elements.deleteDatabase = document.getElementById('delete-database');
        this.elements.clearText = document.getElementById('clear-text');
        this.elements.sentenceCountInput = document.getElementById('sentence-count-input');
        this.elements.loadSentenceWordsmythBeginner = document.getElementById('load-sentence-wordsmyth-beginner');
        this.elements.loadSentenceWordsmythIntermediate = document.getElementById('load-sentence-wordsmyth-intermediate');
        this.elements.loadSentenceWordsmythAdvanced = document.getElementById('load-sentence-wordsmyth-advanced');
        this.elements.loadSentenceMerriamWebster = document.getElementById('load-sentence-merriam-webster');
        this.elements.loadWiki = document.getElementById('load-wiki');
        this.elements.loadUnderthekey = document.getElementById('load-underthekey');
        this.elements.loadMetaphorpsum = document.getElementById('load-metaphorpsum');
        this.elements.loadFile = document.getElementById('load-file');
        this.elements.randomizeParagraphs = document.getElementById('randomize-paragraphs');
        this.elements.randomizeSentences = document.getElementById('randomize-sentences');
        this.elements.colorEncoderToggle = document.getElementById('color-encoder-toggle');
        this.elements.colorEncoderOptions = document.getElementById('color-encoder-options');
        this.elements.colorLetterCount = document.getElementById('color-letter-count');
        this.elements.rewindButton = document.getElementById('rewind-button');
        this.elements.fastForwardButton = document.getElementById('fast-forward-button');
        this.elements.colorInput = document.getElementById('color-input');
        this.elements.dumpColors = document.getElementById('dump-colors');
        this.elements.showColorInfoElement = document.getElementById('show-color-info-element');
        this.elements.showColorInfoToggle = document.getElementById('show-color-info-toggle');
        this.elements.refreshText = document.getElementById('refresh-text');
        this.elements.refreshColors = document.getElementById('refresh-colors');
        this.elements.copyMarqueeText = document.getElementById('copy-marquee-text');
        this.elements.copyCurrentText = document.getElementById('copy-current-text');
        this.elements.textHelper = document.getElementById('text-helper');
        this.elements.marqueeThemeToggle = document.getElementById('marquee-theme-toggle');
        this.elements.loopToggle = document.getElementById('loop-toggle');
        this.elements.fontSizeSlider = document.getElementById('font-size-slider');
        this.elements.fontSizeDisplay = document.getElementById('font-size-display');
        this.elements.tabButtons = document.querySelectorAll('.tab-button');
        this.elements.tabNavigation = document.getElementById('tab-navigation');
        this.elements.tabContent = document.getElementById('tab-content');
        this.elements.tabContents = document.querySelectorAll('.tab-content');
        this.elements.progressBarContainer = document.getElementById('progress-bar-container');
        this.elements.progressBar = document.getElementById('progress-bar');
        this.elements.textSelect = document.getElementById('text-select');
        this.elements.newTextButton = document.getElementById('new-text-button');
        this.elements.duplicateTextButton = document.getElementById('duplicate-text-button');
        this.elements.deleteTextButton = document.getElementById('delete-text-button');
        this.elements.saveTextButton = document.getElementById('save-text-button');
        this.elements.colorEncoderDiv = document.getElementById('color-encoder-div');
        this.elements.settingsProfileSelect = document.getElementById('settings-profile-select');
        this.elements.newSettingsProfileButton = document.getElementById('new-settings-profile-button');
        this.elements.duplicateSettingsProfileButton = document.getElementById('duplicate-settings-profile-button');
        this.elements.deleteSettingsProfileButton = document.getElementById('delete-settings-profile-button');
        this.elements.saveSettingsProfileButton = document.getElementById('save-settings-profile-button');
        this.elements.textToSpeechContainer = document.getElementById('text-to-speech-container');
        this.elements.showSpeakButtonToggle = document.getElementById('show-speak-button-toggle');
        this.elements.showBookmarksButtonToggle = document.getElementById('show-bookmarks-button-toggle');
        this.elements.showSearchButtonToggle = document.getElementById('show-search-button-toggle');
        this.elements.speakButton = document.getElementById('speak-button');
        this.elements.voiceSelect = document.getElementById('voice-select');
        this.elements.speechRateSlider = document.getElementById('speech-rate-slider');
        this.elements.speechRateDisplay = document.getElementById('speech-rate-display');
        this.elements.importAllSettingsProfiles = document.getElementById('import-all-settings-profiles');
        this.elements.importAllTexts = document.getElementById('import-all-texts');
        this.elements.importAllSettingsProfilesAndTexts = document.getElementById('import-all-settings-profiles-and-texts');
        this.elements.importAll = document.getElementById('import-all');
        this.elements.exportAllSettingsProfiles = document.getElementById('export-all-settings-profiles');
        this.elements.exportAllTexts = document.getElementById('export-all-texts');
        this.elements.exportAllTextsWithBookmarksToggle = document.getElementById('export-all-texts-with-bookmarks-toggle');
        this.elements.exportAllSettingsProfilesAndTexts = document.getElementById('export-all-settings-profiles-and-texts');
        this.elements.exportAll = document.getElementById('export-all');
        this.elements.searchContainer = document.getElementById('search-container');
        this.elements.searchButton = document.getElementById('search-button');
        this.elements.searchControls = document.getElementById('search-controls');
        this.elements.searchInput = document.getElementById('search-input');
        this.elements.searchNextButton = document.getElementById('search-next-button');
        this.elements.searchPrevButton = document.getElementById('search-prev-button');
        this.elements.underControlsContainer = document.getElementById('under-controls-container');
        this.elements.bookmarksButton = document.getElementById("bookmarks-button");
        this.elements.bookmarksContainer = document.getElementById("bookmarks-container");
        this.elements.bookmarksControls = document.getElementById("bookmarks-controls");
        this.elements.bookmarkNameInput = document.getElementById("bookmark-name-input");
        this.elements.addBookmarkButton = document.getElementById("add-bookmark-button");
        this.elements.bookmarksList = document.getElementById("bookmarks-list");
        this.elements.saveBookmarksButton = document.getElementById("save-bookmarks-button");
        this.elements.cancelBookmarksButton = document.getElementById("cancel-bookmarks-button");
        this.elements.importReplaceToggle = document.getElementById("import-replace-toggle");
        this.elements.fasterTransitionsToggle = document.getElementById("faster-transitions-toggle");

        this.cachedContainerWidth = null;
        this.cachedTextWidth = null;
        this.elements.deleteDatabase.style.display = 'none';
      },

      loadDb(callback) {
        const currentReader = this;
        const hideTextSelectElements = function () {
          currentReader.elements.textSelect.style.display = 'none';
          currentReader.elements.newTextButton.style.display = 'none';
          currentReader.elements.duplicateTextButton.style.display = 'none';
          currentReader.elements.deleteTextButton.style.display = 'none';
          currentReader.elements.settingsProfileSelect.style.display = 'none';
          currentReader.elements.newSettingsProfileButton.style.display = 'none';
          currentReader.elements.duplicateSettingsProfileButton.style.display = 'none';
          currentReader.elements.deleteSettingsProfileButton.style.display = 'none';
        }
        currentReader.database = null;
        try {
          const request = indexedDB.open(currentReader.databaseName, currentReader.databaseVersion);
          request.onupgradeneeded = function (event) {
            currentReader.database = event.target.result;
            currentReader.database.createObjectStore(currentReader.settingsNames.texts, { keyPath: "title" });
            currentReader.database.createObjectStore(currentReader.settingsNames.settingsProfiles, { keyPath: "name" });
          };
          request.onsuccess = function (event) {
            currentReader.database = event.target.result;
            return callback();
          };
          request.onerror = function (event) {
            currentReader.database = null;
            const message = `IndexedDB error: ${event.target.error}`;
            console.error(event.target.error);
            hideTextSelectElements();
            alert(message);
            return callback();
          };
          request.onblocked = function (event) {
            currentReader.database = null;
            const message = `IndexedDB blocked`;
            console.error(message);
            hideTextSelectElements();
            alert(message);
            return callback();
          };
        } catch (err) {
          currentReader.database = null;
          console.error(err);
          hideTextSelectElements();
          alert(message);
          return callback();
        }
      },

      updateCachedSizes() {
        this.cachedContainerWidth = Math.ceil(this.elements.marqueeContainer.getBoundingClientRect().width);
        this.cachedTextWidth = Math.ceil(this.elements.marqueeDisplay.getBoundingClientRect().width);
      },

      setupPatterns() {
        this.vowelPattern = new RegExp('[\u0041\u0045\u0049\u004f\u0055\u0410\u0415\u0401\u0418\u041e\u0423\u042b\u042d\u042e\u042f\u0391\u0395\u0397\u0399\u039f\u03a5\u03a9\u0101\u012b\u016b\u0113\u014d]', 'ui');
        this.letterPattern = new RegExp(/\p{L}/, 'ui');
        this.wordPattern = new RegExp(/\p{L}+/, 'ui');
        this.punctuationPattern = new RegExp(/\p{S}|\p{Ps}|\p{Pe}|\p{Pi}|\p{Pf}|[!"#%&*,./:;?@^]|^-$/, 'ui');
        this.vowelPatternG = new RegExp(this.vowelPattern, 'uig');
        this.letterPatternG = new RegExp(this.letterPattern, 'uig');
        this.wordPatternG = new RegExp(this.wordPattern, 'uig');
      },

      bindEvents() {
        const currentReader = this;
        this.elements.playPauseButton.addEventListener('click', () => this.togglePlayback());
        this.elements.stopButton.addEventListener('click', () => this.stopPlayback());
        this.elements.themeToggle.addEventListener('click', () => this.switchTheme());
        this.elements.marqueeThemeToggle.addEventListener('click', () => this.switchMarqueeTheme());
        this.elements.fullSizeToggle.addEventListener('click', () => this.toggleFullSize());
        this.elements.deleteAllSettingsProfiles.addEventListener('click', () => this.deleteAllSettingsProfiles());
        this.elements.deleteAllTexts.addEventListener('click', () => this.deleteAllTexts());
        this.elements.deleteDatabase.addEventListener('click', () => this.deleteDatabase());
        this.elements.clearText.addEventListener('click', () => this.clearInput());
        this.elements.loadSentenceWordsmythBeginner.addEventListener('click', () => this.fetchSentenceWordsmythBeginner());
        this.elements.loadSentenceWordsmythIntermediate.addEventListener('click', () => this.fetchSentenceWordsmythIntermediate());
        this.elements.loadSentenceWordsmythAdvanced.addEventListener('click', () => this.fetchSentenceWordsmythAdvanced());
        this.elements.loadSentenceMerriamWebster.addEventListener('click', () => this.fetchSentenceMerriamWebster());
        this.elements.loadWiki.addEventListener('click', () => this.fetchWikipedia());
        this.elements.loadUnderthekey.addEventListener('click', () => this.fetchUnderthekey());
        this.elements.loadMetaphorpsum.addEventListener('click', () => this.fetchMetaphorpsum());
        this.elements.loadFile.addEventListener('click', () => this.loadFromFile());
        this.elements.randomizeParagraphs.addEventListener('click', () => this.randomizeParagraphs());
        this.elements.randomizeSentences.addEventListener('click', () => this.randomizeSentences());
        this.elements.colorEncoderToggle.addEventListener('click', () => this.toggleColorEncoder());
        this.elements.dumpColors.addEventListener('click', () => this.dumpColorMap());
        this.elements.showColorInfoToggle.addEventListener('click', () => this.toggleColorDetails());
        this.elements.appendTextToggle.addEventListener('click', () => this.toggleAppendText());
        this.elements.refreshText.addEventListener('click', () => this.refreshMarqueeText());
        this.elements.refreshColors.addEventListener('click', () => this.refreshMarqueeColors());
        this.elements.copyMarqueeText.addEventListener('click', () => this.copyMarqueeText());
        this.elements.copyCurrentText.addEventListener('click', () => this.copyCurrentText());
        this.elements.loopToggle.addEventListener('click', () => this.toggleLoop());
        this.elements.rewindButton.addEventListener('click', () => this.rewind());
        this.elements.fastForwardButton.addEventListener('click', () => this.fastForward());
        this.elements.fontSizeSlider.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeSlider.value));
        this.elements.fontSizeDisplay.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeDisplay.value));
        this.elements.speedSlider.addEventListener('input', () => this.adjustSpeed(this.elements.speedSlider.value));
        this.elements.speedDisplay.addEventListener('input', () => this.adjustSpeed(this.elements.speedDisplay.value));
        this.elements.tabButtons.forEach(button => button.addEventListener('click', () => this.switchTab(button)));
        this.elements.progressBarContainer.addEventListener('click', (e) => this.handleProgressBarClick(e));
        this.elements.textSelect.addEventListener('change', () => this.switchText());
        this.elements.newTextButton.addEventListener('click', () => this.createNewText());
        this.elements.duplicateTextButton.addEventListener('click', () => this.duplicateText());
        this.elements.deleteTextButton.addEventListener('click', () => this.deleteCurrentText());
        this.elements.saveTextButton.addEventListener('click', () => this.saveCurrentText());
        this.elements.settingsProfileSelect.addEventListener('change', () => this.switchSettingsProfile());
        this.elements.newSettingsProfileButton.addEventListener('click', () => this.createNewSettingsProfile());
        this.elements.duplicateSettingsProfileButton.addEventListener('click', () => this.duplicateSettingsProfile());
        this.elements.deleteSettingsProfileButton.addEventListener('click', () => this.deleteCurrentSettingsProfile());
        this.elements.saveSettingsProfileButton.addEventListener('click', () => this.saveCurrentSettingsProfile());
        this.elements.showSpeakButtonToggle.addEventListener('click', () => this.toggleSpeechButton());
        this.elements.showBookmarksButtonToggle.addEventListener('click', () => this.toggleBookmarksButton());
        this.elements.showSearchButtonToggle.addEventListener('click', () => this.toggleSearchButton());
        this.elements.speakButton.addEventListener('click', () => this.toggleSpeech());
        this.elements.voiceSelect.addEventListener('change', () => this.updateVoice());
        this.elements.speechRateSlider.addEventListener('input', () => this.adjustSpeechRate(this.elements.speechRateSlider.value));
        this.elements.speechRateDisplay.addEventListener('input', () => this.adjustSpeechRate(this.elements.speechRateDisplay.value));
        this.elements.importAllSettingsProfiles.addEventListener('click', () => this.importAllSettingsProfiles());
        this.elements.importAllTexts.addEventListener('click', () => this.importAllTexts());
        this.elements.importAllSettingsProfilesAndTexts.addEventListener('click', () => this.importAllSettingsProfilesAndTexts());
        this.elements.importAll.addEventListener('click', () => this.importAll());
        this.elements.exportAllSettingsProfiles.addEventListener('click', () => this.exportAllSettingsProfiles());
        this.elements.exportAllTexts.addEventListener('click', () => this.exportAllTexts());
        this.elements.exportAllSettingsProfilesAndTexts.addEventListener('click', () => this.exportAllSettingsProfilesAndTexts());
        this.elements.exportAll.addEventListener('click', () => this.exportAll());
        this.elements.searchButton.addEventListener('click', () => this.toggleSearch());
        this.elements.searchInput.addEventListener('input', (e) => this.handleSearchInput(e.target.value));
        this.elements.searchNextButton.addEventListener('click', () => this.goToNextMatch());
        this.elements.searchPrevButton.addEventListener('click', () => this.goToPreviousMatch());
        this.elements.bookmarksButton.addEventListener("click", () => this.toggleBookmarks());
        this.elements.addBookmarkButton.addEventListener("click", () => this.addBookmark());
        this.elements.saveBookmarksButton.addEventListener("click", () => this.saveBookmarksToDB());
        this.elements.cancelBookmarksButton.addEventListener("click", () => {
          if (JSON.stringify(currentReader.currentTextBookmarks) !== JSON.stringify(currentReader.tmpBookmarks) &&
              !confirm('Are you sure you want to close bookmarks block without saving changes?')) {
            return;
          }
          currentReader.toggleBookmarks();
        });
        this.elements.importReplaceToggle.addEventListener('click', () => this.toggleImportReplace());
        this.elements.sentenceCountInput.addEventListener('input', () => this.saveSentenceCountToGenerate());
        this.elements.fasterTransitionsToggle.addEventListener('click', () => this.toggleFasterTransitions());
        this.elements.exportAllTextsWithBookmarksToggle.addEventListener('click', () => this.toggleExportTextsWithBookmarks());

        const textModified = () => { currentReader.textIsModified = true; };
        this.elements.textInput.addEventListener('input', textModified);

        const settingsProfileModified = () => { currentReader.settingsProfileIsModified = true; };
        this.elements.fontSizeSlider.addEventListener('change', settingsProfileModified);
        this.elements.fontSizeDisplay.addEventListener('change', settingsProfileModified);
        this.elements.speedSlider.addEventListener('change', settingsProfileModified);
        this.elements.speedDisplay.addEventListener('change', settingsProfileModified);
        this.elements.letterShuffleSelect.addEventListener('change', settingsProfileModified);
        this.elements.letterSkipSelect.addEventListener('change', settingsProfileModified);
        this.elements.letterEliminationSelect.addEventListener('change', settingsProfileModified);
        this.elements.wordShuffleSelect.addEventListener('change', settingsProfileModified);
        this.elements.wordSkipSelect.addEventListener('change', settingsProfileModified);
        this.elements.colorEncoderToggle.addEventListener('click', settingsProfileModified);
        this.elements.colorLetterCount.addEventListener('change', settingsProfileModified);
        this.elements.dumpColors.addEventListener('click', settingsProfileModified);
        this.elements.colorInput.addEventListener('change', settingsProfileModified);

        document.addEventListener('keydown', e => this.handleKeyPress(e));
        window.addEventListener('resize', () => {
          if (currentReader.currentPosition !== null) {
            currentReader.updateCachedSizes();
            currentReader.updateProgressBar();
          }
        });
        currentReader.restoreActiveTab();

        // sentences generators
        currentReader.sentenceWordsmyth1Generator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesWordsmyth1();
          } catch (e) {
            alert('[wordsmyth1.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();

        currentReader.sentenceWordsmyth2Generator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesWordsmyth2();
          } catch (e) {
            alert('[wordsmyth2.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();

        currentReader.sentenceWordsmyth3Generator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesWordsmyth3();
          } catch (e) {
            alert('[wordsmyth3.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();

        currentReader.sentenceMerriamWebsterGenerator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesMerriamWebster();
          } catch (e) {
            alert('[merriam_webster.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();
      },

      loadPreferences() {
        this.elements.rewindButton.disabled = true;
        this.elements.fastForwardButton.disabled = true;
        this.elements.refreshText.disabled = true;
        this.elements.refreshColors.disabled = true;
        this.elements.copyMarqueeText.disabled = true;
        const marqueeThemeToggle = localStorage.getItem(this.settingsNames.marqueeThemeToggle) || this.marqueeThemes[0];
        this.elements.body.classList.add(marqueeThemeToggle);
        this.elements.marqueeThemeToggle.innerHTML += ` [${marqueeThemeToggle.slice(-1)}]`;
        this.elements.appendTextToggle.checked = localStorage.getItem(this.settingsNames.appendTextToggle) !== 'false';
        this.elements.showColorInfoToggle.checked = localStorage.getItem(this.settingsNames.showColorInfoToggle) !== 'false';
        this.isLoopEnabled = localStorage.getItem(this.settingsNames.loop) === 'true';
        if (this.isLoopEnabled) this.elements.loopToggle.classList.add('active');
        this.elements.mainContainer.classList.add(localStorage.getItem(this.settingsNames.appSizeToggle) || 'normal-size');
        this.elements.showSpeakButtonToggle.checked = localStorage.getItem(this.settingsNames.voiceButton) === 'true';
        this.toggleSpeechButton();
        this.elements.showBookmarksButtonToggle.checked = localStorage.getItem(this.settingsNames.bookmarksButton) === 'true';
        this.toggleBookmarksButton();
        this.elements.showSearchButtonToggle.checked = localStorage.getItem(this.settingsNames.searchButton) === 'true';
        this.toggleSearchButton();
        this.elements.importReplaceToggle.checked = localStorage.getItem(this.settingsNames.importReplaceToggle) !== 'false';
        this.toggleImportReplace();
        this.elements.sentenceCountInput.value = localStorage.getItem(this.settingsNames.sentenceCountToGenerate) || '1';
        this.saveSentenceCountToGenerate();
        this.elements.fasterTransitionsToggle.checked = localStorage.getItem(this.settingsNames.fasterTransitionsToggle) === 'true';
        this.toggleFasterTransitions();
        this.elements.exportAllTextsWithBookmarksToggle.checked = localStorage.getItem(this.settingsNames.exportTextsWithBookmarksToggle) !== 'false';
        this.toggleExportTextsWithBookmarks();

        const voiceIndex = localStorage.getItem(this.settingsNames.voice) || null;
        if (voiceIndex != null) {
          this.elements.voiceSelect.value = voiceIndex;
        }
        const voiceSpeechRate = localStorage.getItem(this.settingsNames.voiceSpeechRate) || null;
        if (voiceSpeechRate != null) {
          this.adjustSpeechRate(voiceSpeechRate);
        }

        const currentTextName = localStorage.getItem(this.settingsNames.currentTextName) || this.defaultTextName;
        const texts = JSON.parse(localStorage.getItem(this.settingsNames.texts) || '[]');
        this.elements.textSelect.innerHTML = `<option value="${this.defaultTextName}">${this.defaultTextName}</option>` + texts.map(text => `<option value="${text}">${text}</option>`).join('');
        this.currentTextName = this.defaultTextName;
        if (texts.includes(currentTextName)) {
          this.currentTextName = currentTextName;
        }
        this.elements.textSelect.value = this.currentTextName;
        this.textIsModified = false;

        const currentSettingsProfileName = localStorage.getItem(this.settingsNames.currentSettingsProfile) || this.defaultSettingsProfileName;
        const settingsProfiles = JSON.parse(localStorage.getItem(this.settingsNames.settingsProfiles) || '[]');
        this.elements.settingsProfileSelect.innerHTML = `<option value="${this.defaultSettingsProfileName}">${this.defaultSettingsProfileName}</option>` + settingsProfiles.map(settingsProfile => `<option value="${settingsProfile}">${settingsProfile}</option>`).join('');
        this.currentSettingsProfileName = this.defaultSettingsProfileName;
        if (settingsProfiles.includes(currentSettingsProfileName)) {
          this.currentSettingsProfileName = currentSettingsProfileName;
        }
        this.elements.settingsProfileSelect.value = this.currentSettingsProfileName;
        this.settingsProfileIsModified = false;

        const currentReader = this;
        currentReader.switchSettingsProfile(function () {
          currentReader.switchText(function () {
            currentReader.toggleAppendText();
            currentReader.toggleColorEncoder(false);
            currentReader.toggleColorDetails();
            currentReader.lastSavedPosition = localStorage.getItem(currentReader.settingsNames.lastPosition);
            if (currentReader.lastSavedPosition && currentReader.elements.textInput.value) {
              currentReader.currentPosition = parseInt(currentReader.lastSavedPosition);
              setTimeout(() => {
                currentReader.startAnimation(false, false);
                currentReader.elements.progressDisplay.style.display = 'none';
              }, 1);
            } else {
              currentReader.lastSavedPosition = null;
            }
            setInterval(() => currentReader.savePosition(), currentReader.lastSavedPositionUpdateDelay);
          });
        });
      },

      togglePlayback() {
        this.animationTimer ? this.pauseAnimation() : this.startAnimation();
      },

      stopPlayback(fully = false) {
        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
          this.animationTimer = null;
        }
        this.elements.playPauseButton.textContent = 'Start';
        this.elements.playPauseButton.classList.remove('pause');
        this.currentPosition = this.cachedContainerWidth;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.elements.speakButton.style.display = '';
        this.elements.searchButton.style.display = '';
        this.elements.bookmarksButton.style.display = '';
        this.elements.underControlsContainer.style.display = '';
        this.elements.loopToggle.style.display = '';
        this.elements.progressDisplay.style.display = 'none';
        this.elements.tabNavigation.style.display = '';
        this.elements.tabContent.style.display = '';
        this.lastSavedPosition = null;
        this.updateProgressBar();
        if (fully && this.previousText !== null) {
          this.animationStartTime = null;
          this.currentPosition = null;
          this.previousText = '';
          this.wordCount = 0;
          this.elements.rewindButton.disabled = true;
          this.elements.fastForwardButton.disabled = true;
          this.elements.refreshText.disabled = true;
          this.elements.refreshColors.disabled = true;
          this.elements.copyMarqueeText.disabled = true;
        }
      },

      startAnimation(resume = false, movement = true) {
        let htmlValue = this.elements.textInput.value.replace(/\s+/g, ' ').trim();
        htmlValue = htmlValue.replace(/\p{Z}+/ug, ' ');
        htmlValue = htmlValue.replace(/\p{C}+/ug, '');
        if (!htmlValue) {
          alert(`The text "${this.currentTextName}" is empty`);
          return false;
        }

        this.elements.textHelper.innerHTML = htmlValue;
        const cleanedText = this.elements.textHelper.textContent || this.elements.textHelper.innerText || "";
        this.elements.textHelper.innerHTML = '';

        if (this.previousText !== cleanedText) {
          this.wordCount = cleanedText.split(/\s+/).filter(word => word.length > 0).length;
        }

        let palleteChanged = false;

        if (!resume && this.elements.colorEncoderToggle.checked) {
          palleteChanged = true;
          const targetSize = parseInt(this.elements.colorLetterCount.value);
          const preservedColors = new Map();
          const preservedLetters = [];
          this.elements.colorInput.value.split('\n').forEach(line => {
            const [letter, ...colorParts] = line.split(/\s+/);
            if (letter && colorParts.length) {
              const color = colorParts.join(' ');
              Array.from(letter.toLowerCase()).forEach(char => {
                preservedLetters.push(char);
                preservedColors.set(char, color);
              });
            }
          });

          if (this.colorMap.size < targetSize || this.previousColorInput !== this.elements.colorInput.value) {
            const newColors = this.generateColors(targetSize);
            const letters = Array.from(this.colorList);
            preservedLetters.forEach(char => {
              if (letters.length < targetSize && cleanedText.includes(char) && !letters.includes(char)) {
                letters.push(char);
              }
            });
            let index = 0;
            for (let i = 0; i < cleanedText.length && letters.length < targetSize; i++) {
              const char = cleanedText[i].toLowerCase();
              if (this.isLetter(char) && !letters.includes(char)) {
                letters.push(char);
                index++;
              }
            }
            letters.sort();
            index = 0;
            letters.forEach(char => {
              if (!this.colorMap.has(char)) {
                this.colorMap.set(char, preservedColors.get(char) || newColors[index++]);
                this.colorList.push(char);
              }
            });
          }
          this.colorList.reverse();
          for (const x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              if (preservedColors.get(x) == null) {
                this.colorMap.delete(x);
                this.colorList.splice(this.colorList.indexOf(x), 1);
              }
            }
            else {
              break;
            }
          }
          this.colorList.sort((a, b) => (preservedLetters.indexOf(a) - preservedLetters.indexOf(b)));
          this.colorList.reverse();
          for (const x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              this.colorMap.delete(x);
              this.colorList.splice(this.colorList.indexOf(x), 1);
            }
            else {
              break;
            }
          }
          this.colorList.sort();
        }

        if (!resume) {
          this.elements.colorDetails.innerHTML = this.colorList
            .map((char, index) => {
              let postElem = '';
              if (index !== 0 && index % 5 === 0) {
                postElem = '<br><br>'
              }
              const color = this.colorMap.get(char);
              return `${postElem}${char.toUpperCase()}<span style="background-color:${color};color:${color};" class="marquee-letter-span clickable" onclick="MarqueeReader.updateColor(this)">${char.toUpperCase()}</span>`;
            })
            .join('  ');
        }

        const textNeedsUpdate = this.currentPosition == null || this.previousText !== cleanedText ||
          this.previousLetterShuffle !== this.elements.letterShuffleSelect.value ||
          this.previousLetterSkip !== this.elements.letterSkipSelect.value ||
          this.previousLetterElimination !== this.elements.letterEliminationSelect.value ||
          this.previousWordShuffle !== this.elements.wordShuffleSelect.value ||
          this.previousWordSkip !== this.elements.wordSkipSelect.value
        ;

        const colorsNeedsUpdate = !this.wasColorTaskChecked || palleteChanged ||
          this.wasColorTaskEnabled !== this.elements.colorEncoderToggle.checked ||
          (this.elements.colorEncoderToggle.checked && this.previousColorInput !== this.elements.colorInput.value);

        if (textNeedsUpdate || colorsNeedsUpdate) {
          const colorize = this.elements.colorEncoderToggle.checked
            ? char => this.colorMap.has(char.toLowerCase())
              ? `<span style="background-color:${this.colorMap.get(char.toLowerCase())};color:${this.colorMap.get(char.toLowerCase())};" class="marquee-letter-span">${char}</span>`
              : char
            : char => char;
          this.elements.marqueeDisplay.innerHTML = this.processText(
            textNeedsUpdate ? cleanedText : this.elements.marqueeDisplay.textContent,
            cleanedText,
            textNeedsUpdate,
            colorize
          );
        }

        if (!resume) {
          this.updateCachedSizes();
        }

        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = containerWidth;
        const endPos = -textWidth;
        const speed = parseInt(this.elements.speedDisplay.value);

        const stepSize = speed > 80 ? (1 + (speed - 80) / 15) : 1;
        const stepDelay = speed > 20 ? Math.max(10, 110 - speed) : (Math.max(10, 110 - speed) + 10 * (20 - speed));

        this.animationStartTime = Date.now();
        this.lastUpdateTime = this.animationStartTime;
        if (this.currentPosition == null || this.currentPosition <= endPos) this.currentPosition = startPos;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.lastSavedPosition = this.currentPosition;

        this.previousText = cleanedText;
        this.previousLetterShuffle = this.elements.letterShuffleSelect.value;
        this.previousLetterSkip = this.elements.letterSkipSelect.value;
        this.previousWordShuffle = this.elements.wordShuffleSelect.value;
        this.previousWordSkip = this.elements.wordSkipSelect.value;
        this.previousLetterElimination = this.elements.letterEliminationSelect.value;
        this.previousColorInput = this.elements.colorInput.value;
        this.previousPosition = this.currentPosition;
        this.wasColorTaskEnabled = this.elements.colorEncoderToggle.checked;
        this.wasColorTaskChecked = true;

        const animate = () => {
          const newLastUpdateTime = Date.now();
          const step = Math.max(stepSize, (newLastUpdateTime - this.lastUpdateTime) / (stepDelay / stepSize));
          const newPosition = this.currentPosition - step;
          this.lastSavedPosition = newPosition;
          const actualStepDelay = Math.floor((this.lastUpdateTime - this.animationStartTime) / Math.max(1e-9, this.previousPosition - newPosition) * 10) / 10;
          const secondsRemaining = Math.floor(actualStepDelay * (newPosition - endPos) / 1000);
          this.elements.progressDisplay.innerHTML = this.formatTime(secondsRemaining);
          const totalSeconds = actualStepDelay * (startPos - endPos) / 1000;
          const wpm = totalSeconds ? Math.max(1, Math.floor(this.wordCount / (totalSeconds / 60))) : this.wordCount;
          this.elements.progressDisplay.innerHTML += `<br>WPM: ${wpm}`;
          const progress = Math.max(0, Math.min(100, Math.floor((newPosition - startPos) * 100 / (endPos - startPos))));
          this.elements.progressDisplay.innerHTML += `<br>Progress: ${progress}%`;
          this.lastUpdateTime = newLastUpdateTime;

          if (newPosition <= endPos) {
            if (this.isLoopEnabled) {
              this.animationStartTime = Date.now();
              this.currentPosition = startPos;
              this.previousPosition = this.currentPosition;
              this.updateProgressBar();
              this.elements.marqueeDisplay.style.left = `${startPos}px`;
              this.lastSavedPosition = null;
              if (this.animationTimer) this.animationTimer = setTimeout(animate, stepDelay);
            } else {
              this.currentPosition = endPos;
              this.previousPosition = this.currentPosition;
              this.updateProgressBar();
              this.elements.marqueeDisplay.style.left = `${endPos}px`;
              clearTimeout(this.animationTimer);
              this.animationTimer = null;
              this.lastSavedPosition = null;
              this.elements.playPauseButton.textContent = 'Start';
              this.elements.playPauseButton.classList.remove('pause');
              this.elements.speakButton.style.display = '';
              this.elements.searchButton.style.display = '';
              this.elements.bookmarksButton.style.display = '';
              this.elements.underControlsContainer.style.display = '';
              this.elements.loopToggle.style.display = '';
              this.elements.progressDisplay.style.display = '';
              this.elements.tabNavigation.style.display = '';
              this.elements.tabContent.style.display = '';
            }
          } else {
            this.elements.marqueeDisplay.style.left = `${newPosition}px`;
            this.currentPosition = newPosition;
            this.updateProgressBar();
            if (this.animationTimer) this.animationTimer = setTimeout(animate, stepDelay);
          }
        };

        this.updateProgressBar();
        this.elements.rewindButton.disabled = false;
        this.elements.fastForwardButton.disabled = false;
        this.elements.refreshText.disabled = false;
        this.elements.refreshColors.disabled = false;
        this.elements.copyMarqueeText.disabled = false;
        if (movement) {
          this.elements.playPauseButton.textContent = 'Pause';
          this.elements.playPauseButton.classList.add('pause');
          this.elements.speakButton.style.display = 'none';
          this.elements.searchButton.style.display = 'none';
          this.elements.bookmarksButton.style.display = 'none';
          this.elements.underControlsContainer.style.display = '';
          this.elements.loopToggle.style.display = 'none';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = 'none';
          this.elements.tabContent.style.display = 'none';
          this.animationTimer = setTimeout(animate, stepDelay);
        }
        return true;
      },

      pauseAnimation() {
        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
          this.animationTimer = null;
          this.elements.playPauseButton.textContent = 'Start';
          this.elements.playPauseButton.classList.remove('pause');
          this.elements.speakButton.style.display = '';
          this.elements.searchButton.style.display = '';
          this.elements.bookmarksButton.style.display = '';
          this.elements.underControlsContainer.style.display = '';
          this.elements.loopToggle.style.display = '';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = '';
          this.elements.tabContent.style.display = '';
          this.updateProgressBar();
        }
      },

      processText(text, referenceText, shouldModify, colorize) {
        const escapeString = str => str.replace(/\\/g, '').replace(/"/g, '').replace(/'/g, "\\'");
        const textLines = text.split('\n');
        const refLines = referenceText.split('\n');
        return textLines.map((line, index) => {
          const words = line.split(/\s+/).filter(word => word);
          const refWords = refLines[index] ? refLines[index].split(/\s+/) : words;
          let processedWords = words;
          let processedRefWords = refWords;

          if (shouldModify && this.elements.wordSkipSelect.value !== 'no') {
            const match = /(\d+)%_words/.exec(this.elements.wordSkipSelect.value);
            if (match) {
              processedWords = this.skipWords(processedWords, parseInt(match[1]) / 100);
            }
          }

          if (shouldModify && this.elements.wordShuffleSelect.value !== 'no') {
            const match = /(\d+)_words?/.exec(this.elements.wordShuffleSelect.value);
            if (match) {
              const groupSize = parseInt(match[1]);
              const shuffledIndices = this.shuffleWordGroups(processedWords, groupSize);
              processedWords = shuffledIndices.map(i => processedWords[i]);
              processedRefWords = shuffledIndices.map(i => processedRefWords[i]);
            }
          }

          return processedWords.map((word, i) => {
            let modifiedWord = word;
            const skipShuffle = /^[A-Z\d']/.test(word) || /[\u2032\u2033\u2034\u2057\u2019\u0060\u00B4\uFF40\u02F4]/.test(word);

            if (shouldModify && this.elements.letterEliminationSelect.value !== 'no' && word.length > 1) {
              const vowelMatch = /(\d+)%_vowels/.exec(this.elements.letterEliminationSelect.value);
              const randomMatch = /(\d+)%_random/.exec(this.elements.letterEliminationSelect.value);
              if (vowelMatch) {
                modifiedWord = this.eliminateLetters(this.vowelPatternG, modifiedWord, parseInt(vowelMatch[1]) / 100);
              } else if (randomMatch) {
                modifiedWord = this.eliminateLetters(this.letterPatternG, modifiedWord, parseInt(randomMatch[1]) / 100);
              }
            }

            if (shouldModify && this.elements.letterSkipSelect.value !== 'no' && word.length > 1) {
              const skipMatch = /(\d+)%_letters/.exec(this.elements.letterSkipSelect.value);
              if (skipMatch) {
                modifiedWord = this.skipLetters(modifiedWord, parseInt(skipMatch[1]) / 100);
              }
            }

            if (shouldModify && this.elements.letterShuffleSelect.value !== 'no' && (!skipShuffle || this.elements.letterShuffleSelect.value === 'very-hard')) {
              const parts = modifiedWord.split('-');
              modifiedWord = parts.map(part => {
                const threshold = this.elements.letterShuffleSelect.value === 'hard' || this.elements.letterShuffleSelect.value === 'very-hard' ? 0 :
                  this.elements.letterShuffleSelect.value === 'medium' || this.elements.letterShuffleSelect.value === 'medium_plus' ? 1 : Math.floor(part.length / 3);
                const suffixLength = this.elements.letterShuffleSelect.value === 'medium_plus' ? 0 : threshold;
                const letters = [];
                for (const x of part) {
                  if (this.isLetter(x)) {
                    letters.push(x);
                  }
                }
                const firstLetters = letters.slice(0, threshold);
                const midLetters = letters.slice(threshold, letters.length - suffixLength);
                const lastLetters = letters.slice(letters.length - suffixLength);
                const originalMiddle = Array.from(midLetters);
                const originalMiddleSize = new Set(originalMiddle).size;
                if (originalMiddleSize > 1) {
                  while (midLetters.join('') === originalMiddle.join('')) {
                    this.shuffleArray(midLetters);
                  }
                }
                const reordered = [...firstLetters, ...midLetters, ...lastLetters];
                let result = '';
                let j = 0;
                for (const char of part) {
                  result += this.isLetter(char) ? reordered[j++] : char;
                }
                return result;
              }).join('-');
            }

            const coloredWord = Array.from(modifiedWord).map(colorize).join('');
            return this.elements.letterShuffleSelect.value !== 'no' ||
              this.elements.letterEliminationSelect.value !== 'no' ||
              this.elements.letterSkipSelect.value !== 'no' ||
              this.elements.wordSkipSelect.value !== 'no'
              ? `<span class="marquee-word-span clickable" onclick="MarqueeReader.showWordHint('${escapeString(modifiedWord)}', '${escapeString(processedRefWords[i] || word)}')">${coloredWord}</span>`
              : (
                this.elements.colorEncoderToggle.checked
                ? `<span class="marquee-word-span clickable" onclick="MarqueeReader.showWordHint('${escapeString(modifiedWord)}')">${coloredWord}</span>`
                : `<span class="marquee-word-span">${coloredWord}</span>`);
          }).join(' ');
        }).join('\n');
      },

      eliminateLetters(regex, word, percentOfLetters, onlyReturnIndices = false) {
        const lettersOnly = word.replace(/[^\p{L}]/ug, '');
        const matchIndices = [];
        let isFirstMatch = true;
        regex.lastIndex = 0;
        while (true) {
          const match = regex.exec(word);
          if (match === null) break;
          if (isFirstMatch) {
            isFirstMatch = false;
            if (lettersOnly[0] === word[match.index]) continue;
          }
          matchIndices.push(match.index);
        }
        regex.lastIndex = 0;
        if (matchIndices.length > 0 && word.length >= 2 && regex === this.letterPatternG) {
          const lastIndex = matchIndices[matchIndices.length - 1];
          if (!this.vowelPattern.test(word[lastIndex]) || (lastIndex > 0 && this.vowelPattern.test(word[lastIndex - 1]))) {
            matchIndices.pop();
          }
        }
        let effectiveLength = lettersOnly.length;
        if (regex === this.vowelPatternG) {
          let vowelCount = 0;
          for (const char of word) {
            this.vowelPattern.lastIndex = 0;
            if (this.vowelPattern.test(char)) {
              vowelCount++;
            }
          }
          effectiveLength = vowelCount;
        }
        const numToRemove = Math.min(Math.floor(effectiveLength * percentOfLetters), matchIndices.length);
        const shuffledIndices = Array.from(matchIndices);
        this.shuffleArray(shuffledIndices);
        const duplicateIndices = [];
        const vowelIndices = [];
        const otherIndices = [];
        for (const index of shuffledIndices) {
          if (index > 0 && word[index - 1] === word[index]) {
            duplicateIndices.push(index);
          } else if (this.vowelPattern.test(word[index])) {
            vowelIndices.push(index);
          } else {
            otherIndices.push(index);
          }
        }
        const cmp = (a, b) => b - a;
        duplicateIndices.sort(cmp);
        vowelIndices.sort(cmp);
        otherIndices.sort(cmp);
        const indicesToRemove = [...duplicateIndices, ...vowelIndices, ...otherIndices].slice(0, numToRemove).sort((a, b) => a - b);
        if (onlyReturnIndices) {
          return indicesToRemove;
        }
        const wordParts = [];
        let start = 0;
        for (const removeIndex of indicesToRemove) {
          if (start < removeIndex) {
            wordParts.push(word.slice(start, removeIndex));
          }
          start = removeIndex + 1;
        }
        if (start < word.length) {
          wordParts.push(word.slice(start));
        }
        return wordParts.join('');
      },

      shuffleWordGroups(words, groupSize) {
        const shuffledIndices = [];
        for (let start = 0; start < words.length;) {
          let groupWords = words.slice(start, start + groupSize);
          const subGroupWords = [groupWords[0]];
          const hasPunctuation = this.punctuationPattern.test(groupWords[0]);
          for (let j = 1; j < groupWords.length; j++) {
            if (hasPunctuation || this.punctuationPattern.test(groupWords[j])) {
              break;
            }
            subGroupWords.push(groupWords[j]);
          }
          groupWords = subGroupWords;
          const groupLength = groupWords.length;
          const shuffleableIndices = [];
          const fixedIndices = new Set();
          for (let j = 0; j < groupLength; j++) {
            if (!this.punctuationPattern.test(groupWords[j]) && this.wordPattern.test(groupWords[j])) {
              shuffleableIndices.push(j);
            }
            else {
              fixedIndices.add(j);
            }
          }
          this.shuffleArray(shuffleableIndices);
          let shufflePosition = 0;
          for (let j = 0; j < groupLength; j++) {
            if (fixedIndices.has(j)) {
              shuffledIndices.push(start + j);
            } else {
              shuffledIndices.push(start + shuffleableIndices[shufflePosition]);
              shufflePosition++;
            }
          }
          start += groupLength;
        }
        return shuffledIndices;
      },

      maxDistanceIndexes(length) {
        if (length <= 0) return [];
        const result = [0];
        const remaining = new Set();
        for (let i = 1; i < length; i++) remaining.add(i);
        while (remaining.size > 0) {
          let maxDist = -1;
          let bestIdx = -1;
          for (const current of remaining) {
            let currentDist = Infinity;
            for (const prev of result) {
              currentDist = Math.min(currentDist, Math.abs(current - prev));
            }
            if (currentDist > maxDist) {
              maxDist = currentDist;
              bestIdx = current;
            }
          }
          result.push(bestIdx);
          remaining.delete(bestIdx);
        }
        return result;
      },

      skipWords(words, percent) {
        const wordsToSkip = Math.floor(words.filter((v, i) => this.wordPattern.test(v)).length * percent);
        let indices1 = [], indices2 = [];
        for (let i = 0; i < words.length; ++i) {
          (i % 2 ? indices1 : indices2).push(i)
        }
        if (Math.random() < 0.5) {
          [indices1, indices2] = [indices2, indices1];
        }
        const newIndices1 = this.maxDistanceIndexes(indices1.length);
        const newIndices2 = this.maxDistanceIndexes(indices2.length);
        const indices = [...newIndices1.map(i => indices1[i]), ...newIndices2.map(i => indices2[i])];
        const newWords = words.slice();
        for (let i = 0, k = 0; i < indices.length && k < wordsToSkip; ++i) {
          const currentIndex = indices[i];
          const word = words[currentIndex];
          const newWord = word.replaceAll(this.wordPatternG, '_');
          if (word !== newWord) {
            newWords[currentIndex] = newWord;
            ++k;
          }
        }
        return newWords;
      },

      skipLetters(word, percent) {
        const lettersIndices = this.eliminateLetters(this.letterPatternG, word, percent, true);
        return [...word].map((v, i) => lettersIndices.includes(i) ? '_' : v).join('');
      },

      isLetter(char) {
        return /^[a-zA-Z]$/.test(char) || char.toLowerCase() !== char.toUpperCase() || (this.letterPattern && this.letterPattern.test(char));
      },

      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      },

      generateColors(count) {
        const colors = [];
        const isTooDarkOrLight = (r, g, b) => {
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance < 0.2 || luminance > 0.8;
        };
        for (let i = 0; i < count; i++) {
          let r, g, b;
          do {
            r = Math.floor(Math.random() * 256);
            g = Math.floor(Math.random() * 256);
            b = Math.floor(Math.random() * 256);
          } while (isTooDarkOrLight(r, g, b));
          colors.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
        }
        return colors;
      },

      formatTime(seconds) {
        if (seconds < 0) return '00:00:00';
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      },

      switchTheme() {
        const current = this.themes.find(theme => this.elements.body.classList.contains(theme));
        const next = this.themes[(this.themes.indexOf(current) + 1) % this.themes.length] || this.themes[0];
        this.themes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(next);
        localStorage.setItem(this.settingsNames.theme, next);
      },

      switchMarqueeTheme() {
        const current = this.marqueeThemes.find(theme => this.elements.body.classList.contains(theme));
        const next = this.marqueeThemes[(this.marqueeThemes.indexOf(current) + 1) % this.marqueeThemes.length] || this.marqueeThemes[0];
        this.marqueeThemes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(next);
        localStorage.setItem(this.settingsNames.marqueeThemeToggle, next);
        this.elements.marqueeThemeToggle.innerHTML = [...this.elements.marqueeThemeToggle.innerHTML.split(' ').slice(0, -1), `[${next.slice(-1)}]`].join(' ');
      },

      toggleFullSize() {
        const sizes = ['max-size', 'normal-size'];
        const container = document.querySelector('.container');
        const current = sizes.find(size => container.classList.contains(size));
        const next = sizes[(sizes.indexOf(current) + 1) % sizes.length] || sizes[0];
        sizes.forEach(size => container.classList.remove(size));
        container.classList.add(next);
        localStorage.setItem(this.settingsNames.appSizeToggle, next);
        if (this.currentPosition !== null) {
          this.updateCachedSizes();
          this.updateProgressBar();
        }
      },

      toggleLoop() {
        this.isLoopEnabled = !this.isLoopEnabled;
        this.elements.loopToggle.classList.toggle('active');
        localStorage.setItem(this.settingsNames.loop, this.isLoopEnabled);
      },

      toggleImportReplace() {
        localStorage.setItem(this.settingsNames.importReplaceToggle, this.elements.importReplaceToggle.checked);
      },

      toggleFasterTransitions() {
        localStorage.setItem(this.settingsNames.fasterTransitionsToggle, this.elements.fasterTransitionsToggle.checked);
      },

      toggleExportTextsWithBookmarks() {
        localStorage.setItem(this.settingsNames.exportTextsWithBookmarksToggle, this.elements.exportAllTextsWithBookmarksToggle.checked);
      },

      saveSentenceCountToGenerate() {
        localStorage.setItem(this.settingsNames.sentenceCountToGenerate, this.elements.sentenceCountInput.value);
      },

      switchTab(button) {
        this.elements.tabButtons.forEach(btn => {
          btn.classList.remove('active');
          btn.setAttribute('aria-selected', 'false');
        });
        button.classList.add('active');
        button.setAttribute('aria-selected', 'true');
        const tabId = button.getAttribute('data-tab');
        this.elements.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === tabId);
        });
        localStorage.setItem(this.settingsNames.activeTab, button.getAttribute('data-tab'))
      },

      restoreActiveTab() {
        const activeTab = localStorage.getItem(this.settingsNames.activeTab) || 'info-tab';
        if (activeTab) {
          var activeTabButton = document.querySelector(`.tab-button[data-tab="${activeTab}"]`);
          if (activeTabButton) {
            this.switchTab(activeTabButton);
          }
        }
      },

      adjustFontSize(value) {
        this.elements.fontSizeSlider.value = value;
        this.elements.fontSizeDisplay.value = value;
        this.elements.marqueeDisplay.style.fontSize = `${value}px`;
      },

      adjustSpeed(value) {
        this.elements.speedSlider.value = value;
        this.elements.speedDisplay.value = value;
      },

      rewind() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left) + Math.floor(containerWidth / 4)));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      fastForward() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left) - Math.floor(containerWidth / 4)));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      goToStartPosition() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = containerWidth;
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      goToEndPosition() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = -textWidth;
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeText() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          this.previousLetterShuffle = '';
          this.startAnimation(false, false);
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeColors() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          if (this.elements.colorEncoderToggle.checked) {
            this.colorMap.clear();
            this.colorList = [];
          }
          this.startAnimation(false, false);
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      copyMarqueeText() {
        if (this.currentPosition !== null) {
          navigator.clipboard.writeText(this.elements.marqueeDisplay.textContent);
        }
      },

      copyCurrentText() {
        navigator.clipboard.writeText(this.elements.textInput.value);
      },

      toggleColorEncoder(updateMarqueeTextBlock = true) {
        const isVisible = this.elements.colorEncoderToggle.checked;
        this.elements.colorInput.style.display = isVisible ? '' : 'none';
        this.elements.dumpColors.style.display = isVisible ? '' : 'none';
        this.elements.colorEncoderOptions.style.display = isVisible ? '' : 'none';
        this.elements.colorDetails.style.display = this.elements.showColorInfoToggle.checked && isVisible ? '' : 'none';
        this.elements.colorEncoderDiv.classList.remove('items-border');
        if (isVisible) {
          this.elements.colorEncoderDiv.classList.add('items-border');
        }
        if (updateMarqueeTextBlock) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          this.wasColorTaskChecked = false;
          if (this.elements.textInput.value) {
            this.startAnimation(false, false);
          }
          if (wasPlaying) this.startAnimation(true);
        }
      },

      toggleColorDetails() {
        const isVisible = this.elements.showColorInfoToggle.checked && this.elements.colorEncoderToggle.checked;
        this.elements.colorDetails.style.display = isVisible ? '' : 'none';
        localStorage.setItem(this.settingsNames.showColorInfoToggle, isVisible);
      },

      toggleAppendText() {
        localStorage.setItem(this.settingsNames.appendTextToggle, this.elements.appendTextToggle.checked);
      },

      dumpColorMap() {
        const currentReader = this;
        currentReader.colorList.forEach(char => {
          const color = currentReader.hexToRgb(currentReader.colorMap.get(char));
          const entry = `${char.toUpperCase()} ${color}`;
          if (!currentReader.elements.colorInput.value.includes(entry)) {
            currentReader.elements.colorInput.value += (currentReader.elements.colorInput.value && !currentReader.elements.colorInput.value.endsWith('\n') ? '\n' : '') + entry + '\n';
          }
        });
      },

      clearInput() {
        this.elements.textInput.value = '';
        this.textIsModified = true;
      },

      fetchSentenceWordsmythBeginner() {
        if (this.animationTimer) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceWordsmyth1Generator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = /[.!?]$/.test(sentence) ? sentence : `${sentence}.`;
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchSentenceWordsmythIntermediate() {
        if (this.animationTimer) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceWordsmyth2Generator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = /[.!?]$/.test(sentence) ? sentence : `${sentence}.`;
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchSentenceWordsmythAdvanced() {
        if (this.animationTimer) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceWordsmyth3Generator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = /[.!?]$/.test(sentence) ? sentence : `${sentence}.`;
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchSentenceMerriamWebster() {
        if (this.animationTimer) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceMerriamWebsterGenerator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = /[.!?]$/.test(sentence) ? sentence : `${sentence}.`;
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchWikipedia() {
        if (this.animationTimer) {
          return;
        }
        const currentReader = this;
        fetch('https://en.wikipedia.org/api/rest_v1/page/random/summary')
          .then(response => response.json())
          .then(data => {
            const text = data.extract.trim();
            currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
            currentReader.textIsModified = true;
          })
          .catch(() => alert('[Wiki] Data fetching error'));
      },

      fetchUnderthekey() {
        if (this.animationTimer) {
          return;
        }
        const currentReader = this;
        fetch('https://sentence.underthekey.com/language?language=eng')
          .then(response => response.json())
          .then(data => {
            for (const sentence of data) {
              const text = sentence['content'].trim();
              currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              currentReader.textIsModified = true;
            }
          })
          .catch(() => alert('[Underthekey] Data fetching error'));
      },

      fetchMetaphorpsum() {
        if (this.animationTimer) {
          return;
        }
        const currentReader = this;
        fetch('http://metaphorpsum.com/sentences/1')
          .then(response => response.text())
          .then(text => {
            currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text.trim()}` : text.trim();
            currentReader.textIsModified = true;
          })
          .catch(() => alert('[Metaphorpsum] Data fetching error'));
      },

      loadFromFile() {
        if (this.animationTimer) {
          return;
        }
        const currentReader = this;
        const input = document.createElement('input');
        input.type = 'file';
        input.onchange = e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = event => {
              const text = event.target.result.trim();
              currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              currentReader.textIsModified = true;
            };
            reader.readAsText(file);
          }
        };
        this.elements.body.appendChild(input);
        input.click();
        this.elements.body.removeChild(input);
      },

      randomizeParagraphs() {
        const currentReader = this;
        const text = this.elements.textInput.value;
        const paragraphs = text.split('\n').filter(p => p.trim());
        currentReader.shuffleArray(paragraphs);
        this.elements.textInput.value = paragraphs.join('\n\n');
      },

      randomizeSentences() {
        const currentReader = this;
        const text = this.elements.textInput.value;
        const paragraphs = text.split('\n').filter(p => p.trim());
        const splitIntoSentences = (paragraph) => {
          const sentences = [];
          let currentSentence = '';
          for (let i = 0; i < paragraph.length; i++) {
            const char = paragraph[i];
            currentSentence += char;
            if (char === '.' || char === '!' || char === '?') {
              if (i === paragraph.length - 1 || paragraph[i + 1] === ' ') {
                sentences.push(currentSentence.trim());
                currentSentence = '';
                i++;
              }
            }
          }
          currentSentence = currentSentence.trim();
          if (currentSentence) {
            const lastChar = currentSentence[currentSentence.length - 1];
            if (!(lastChar === '.' || lastChar === '!' || lastChar === '?')) {
              currentSentence = currentSentence.concat('.');
            }
            sentences.push(currentSentence);
          }
          return sentences;
        };
        const processedParagraphs = paragraphs.map(paragraph => {
          const sentences = splitIntoSentences(paragraph);
          currentReader.shuffleArray(sentences);
          return sentences.join(' ');
        });
        this.elements.textInput.value = processedParagraphs.join('\n\n');
      },

      savePosition() {
        if (this.lastSavedPosition !== null && (this.cachedContainerWidth == null || this.lastSavedPosition < this.cachedContainerWidth)) {
          localStorage.setItem(this.settingsNames.lastPosition, this.lastSavedPosition);
        } else {
          localStorage.removeItem(this.settingsNames.lastPosition);
        }
      },

      updateColor(element) {
        const newColor = prompt('Enter color:', element.style.color);
        if (newColor) {
          this.colorMap.set(element.textContent.toLowerCase(), newColor);
          element.style.color = newColor;
          element.style.backgroundColor = newColor;
        }
      },

      showWordHint(shuffled, original = null) {
        if (original) {
          alert(`${shuffled} -> ${original}`);
        }
        else {
          alert(`${shuffled}`);
        }
      },

      hexToRgb(hex) {
        if (!/^#[a-f0-9]{3,6}$/i.test(hex)) return hex;
        hex = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (_, r, g, b) => r + r + g + g + b + b);
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : hex;
      },

      handleKeyPress(event) {
        if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) return;
        event.preventDefault();
        switch (event.key) {
          case ' ': this.togglePlayback(); break;
          case 'ArrowUp': this.goToEndPosition(); break;
          case 'ArrowDown': this.goToStartPosition(); break;
          case 'ArrowLeft': this.rewind(); break;
          case 'ArrowRight': this.fastForward(); break;
          case 'l':
          case 'L': this.toggleLoop(); break;
          case 'e':
          case 'E': this.elements.colorEncoderToggle.click(); break;
          case 's':
          case 'S': this.stopPlayback(); break;
          case '+': if (!this.animationTimer) this.elements.speedDisplay.value = parseInt(this.elements.speedDisplay.value) + 1; this.adjustSpeed(this.elements.speedDisplay.value); break;
          case '-': if (!this.animationTimer) this.elements.speedDisplay.value = parseInt(this.elements.speedDisplay.value) - 1; this.adjustSpeed(this.elements.speedDisplay.value); break;
          case 't':
          case 'T': this.refreshMarqueeText(); break;
          case 'c':
          case 'C': this.refreshMarqueeColors(); break;
          case 'Escape': this.elements.showColorInfoToggle.click(); break;
        }
      },

      updateProgressBar() {
        const currentReader = this;
        if (this.currentPosition !== null) {
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;
          const progress = Math.max(0, Math.min(100, (this.currentPosition - startPos) * 100 / (endPos - startPos)));
          this.elements.progressBar.style.width = `${progress}%`;
          
          const searchMarks = this.elements.progressBarContainer.querySelectorAll('.search-mark');
          searchMarks.forEach(mark => mark.remove());

          if (this.searchMatches.length > 0) {
            this.searchMatches.forEach((match, index) => {
              const matchProgress = Math.max(0, Math.min(100, (match.position - startPos) * 100 / (endPos - startPos)));
              const mark = document.createElement('div');
              mark.className = `search-mark ${index === currentReader.currentMatchIndex ? 'active' : ''}`;
              mark.style.left = `${matchProgress}%`;
              mark.addEventListener('click', (event) => {
                event.stopPropagation();
                currentReader.goToMatch(index);
              });
              currentReader.elements.progressBarContainer.appendChild(mark);
            });
          }
        } else {
          this.elements.progressBar.style.width = '0%';
        }
      },

      handleProgressBarClick(event) {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();

          const rect = this.elements.progressBarContainer.getBoundingClientRect();
          const scrollbarWidth = wasPlaying ? window.innerWidth - document.documentElement.clientWidth : 0;
          const clickX = event.clientX - rect.left - Math.min(20, Math.max(0, scrollbarWidth));

          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;

          const progress = clickX / rect.width;
          this.currentPosition = startPos - (startPos - endPos) * progress;
          this.currentPosition = Math.max(endPos, Math.min(startPos, this.currentPosition));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();

          if (wasPlaying) this.startAnimation(true);
        }
      },

      switchSettingsProfile(callback = null) {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentSettingsProfileName;
        if (!currentReader.database) {
          currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
          return;
        }
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and switch settings profile?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        currentReader.pauseAnimation();
        const selectedSettingsProfileName = currentReader.elements.settingsProfileSelect.value;
        if (selectedSettingsProfileName === currentReader.defaultSettingsProfileName) {
          currentReader.setSettingsProfile(JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfile) || '{}'));
          currentReader.currentSettingsProfileName = selectedSettingsProfileName;
          localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
          currentReader.settingsProfileIsModified = false;
          if (callback) {
            return callback();
          }
        } else {
          const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readonly');
          const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
          const request = objectStore.get(selectedSettingsProfileName);
          request.onsuccess = () => {
            const data = request.result;
            currentReader.setSettingsProfile(JSON.parse(data && data.settings ? data.settings : '{}'));
            currentReader.currentSettingsProfileName = selectedSettingsProfileName;
            localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
            currentReader.settingsProfileIsModified = false;
            if (callback) {
              return callback();
            }
          };
          request.onerror = () => {
            currentReader.currentSettingsProfileName = currentReader.defaultSettingsProfileName;
            localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
            currentReader.locationReload();
          };
        }
      },

      switchText(callback = null) {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (!currentReader.database) {
          currentReader.elements.textSelect.value = currentTextName;
          return;
        }
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and switch text?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        currentReader.stopPlayback(true);
        const selectedTextName = currentReader.elements.textSelect.value;
        if (selectedTextName === currentReader.defaultTextName) {
          currentReader.currentTextBookmarks = JSON.parse(localStorage.getItem(currentReader.settingsNames.textBookmarks) || '[]');
          currentReader.elements.textInput.value = localStorage.getItem(currentReader.settingsNames.text) || '';
          currentReader.currentTextName = selectedTextName;
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
          currentReader.textIsModified = false;
          if (callback) {
            return callback();
          }
        } else {
          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readonly');
          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
          const request = objectStore.get(selectedTextName);
          request.onsuccess = () => {
            const data = request.result;
            currentReader.currentTextBookmarks = data && data.bookmarks ? JSON.parse(data.bookmarks) : [];
            currentReader.elements.textInput.value = data && data.content ? data.content : '';
            currentReader.currentTextName = selectedTextName;
            localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
            currentReader.textIsModified = false;
            if (callback) {
              return callback();
            }
          };
          request.onerror = () => {
            currentReader.currentTextName = currentReader.defaultTextName;
            localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
            currentReader.locationReload();
          };
        }
      },

      createNewSettingsProfile(settingsProfile = null) {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentSettingsProfileName;
        if (!settingsProfile) {
          settingsProfile = currentReader.getDefaultSettingsProfile();
        }
        const newSettingsProfile = JSON.stringify(settingsProfile);
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and create a new settings profile?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        let name;
        do {
          name = prompt('Enter a unique name for the new settings profile:');
          if (!name) return;
          const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
          if (settingsProfiles.includes(name) || name === currentReader.defaultSettingsProfileName) {
            alert('This settings profile name already exists. Choose another one.');
            name = null;
          }
        } while (!name);
        currentReader.pauseAnimation();
        const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
        settingsProfiles.push(name);
        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
        objectStore.add({ name: name, settings: newSettingsProfile });
        transaction.oncomplete = () => {
          localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          currentReader.elements.settingsProfileSelect.appendChild(option);
          currentReader.elements.settingsProfileSelect.value = name;
          currentReader.settingsProfileIsModified = false;
          currentReader.switchSettingsProfile();
        };
        transaction.onabort = () => {
          console.error(transaction.error);
          alert(transaction.error);
        };
      },

      duplicateSettingsProfile() {
        this.createNewSettingsProfile(this.getCurrentSettingsProfile());
      },

      createNewText(defaultContent = '', defaultBookmarks = []) {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and create a new text?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        let name;
        do {
          name = prompt('Enter a unique name for the new text:');
          if (!name) return;
          const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          if (texts.includes(name) || name === this.defaultTextName) {
            alert('This text name already exists. Choose another one.');
            name = null;
          }
        } while (!name);
        currentReader.stopPlayback(true);
        const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
        texts.push(name);
        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
        const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
        objectStore.add({ title: name, content: defaultContent, bookmarks: JSON.stringify(defaultBookmarks) });
        transaction.oncomplete = () => {
          localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          currentReader.elements.textSelect.appendChild(option);
          currentReader.elements.textSelect.value = name;
          currentReader.textIsModified = false;
          currentReader.switchText();
        };
        transaction.onabort = () => {
          console.error(transaction.error);
          alert(transaction.error);
        };
      },

      duplicateText() {
        this.createNewText(this.elements.textInput.value, this.currentTextBookmarks);
      },

      saveCurrentSettingsProfile() {
        const currentReader = this;
        try {
          const currentSettings = JSON.stringify(currentReader.getCurrentSettingsProfile());
          if (currentReader.currentSettingsProfileName === currentReader.defaultSettingsProfileName) {
            localStorage.setItem(currentReader.settingsNames.settingsProfile, currentSettings);
            currentReader.settingsProfileIsModified = false;
          } else if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
            const request = objectStore.put({ name: currentReader.currentSettingsProfileName, settings: currentSettings });
            request.onsuccess = () => {
              currentReader.settingsProfileIsModified = false;
            };
          }
          localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
        }
        catch (err) {
          console.error(err);
          alert(err);
        }
      },

      saveCurrentText() {
        const currentReader = this;
        try {
          if (currentReader.currentTextName === currentReader.defaultTextName) {
            localStorage.setItem(currentReader.settingsNames.text, currentReader.elements.textInput.value);
            localStorage.setItem(currentReader.settingsNames.textBookmarks, JSON.stringify(currentReader.currentTextBookmarks));
            currentReader.textIsModified = false;
          } else if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
            const request = objectStore.put({
              title: currentReader.currentTextName,
              content: currentReader.elements.textInput.value,
              bookmarks: JSON.stringify(currentReader.currentTextBookmarks),
            });
            request.onsuccess = () => {
              currentReader.textIsModified = false;
            };
          }
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
        }
        catch (err) {
          console.error(err);
          alert(err);
        }
      },

      deleteCurrentSettingsProfile() {
        const currentReader = this;
        if (currentReader.currentSettingsProfileName === currentReader.defaultSettingsProfileName) {
          alert(`Cannot delete the "${currentReader.defaultSettingsProfileName}" settings profile`);
          return;
        }
        if (confirm(`Are you sure you want to delete the settings profile "${currentReader.currentSettingsProfileName}"?`)) {
          currentReader.pauseAnimation();
          const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
          const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
          objectStore.delete(currentReader.currentSettingsProfileName);
          transaction.oncomplete = () => {
            let settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
            settingsProfiles = settingsProfiles.filter(profileName => profileName !== currentReader.currentSettingsProfileName);
            localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
            const option = currentReader.elements.settingsProfileSelect.querySelector(`option[value="${currentReader.currentSettingsProfileName}"]`);
            if (option) option.remove();
            currentReader.elements.settingsProfileSelect.value = currentReader.defaultSettingsProfileName;
            currentReader.settingsProfileIsModified = false;
            currentReader.switchSettingsProfile();
          };
          transaction.onabort = () => {
            console.error(transaction.error);
            alert(transaction.error);
          };
        }
      },

      deleteCurrentText() {
        const currentReader = this;
        if (currentReader.currentTextName === currentReader.defaultTextName) {
          alert(`Cannot delete the "${currentReader.defaultTextName}" text`);
          return;
        }
        if (confirm(`Are you sure you want to delete the text "${currentReader.currentTextName}"? This action will also remove all associated bookmarks.`)) {
          currentReader.stopPlayback(true);
          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
          objectStore.delete(currentReader.currentTextName);
          transaction.oncomplete = () => {
            let texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
            texts = texts.filter(text => text !== currentReader.currentTextName);
            localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
            const option = currentReader.elements.textSelect.querySelector(`option[value="${currentReader.currentTextName}"]`);
            if (option) option.remove();
            currentReader.elements.textSelect.value = currentReader.defaultTextName;
            currentReader.textIsModified = false;
            currentReader.switchText();
          };
          transaction.onabort = () => {
            console.error(transaction.error);
            alert(transaction.error);
          };
        }
      },

      deleteAllSettingsProfiles(callback = null) {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all settings profiles?')) {
          if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
            const request = objectStore.clear();
            transaction.oncomplete = () => {
              localStorage.removeItem(currentReader.settingsNames.settingsProfile);
              localStorage.removeItem(currentReader.settingsNames.settingsProfiles);
              if (callback) {
                return callback();
              }
              currentReader.locationReload();
            };
            transaction.onabort = () => {
              console.error(transaction.error);
              alert(transaction.error);
            };
          }
          else {
            localStorage.removeItem(currentReader.settingsNames.settingsProfile);
          }
        }
        else {
          currentReader.deleteDatabaseViewCounter += 1;
          if (currentReader.deleteDatabaseViewCounter >= currentReader.deleteDatabaseViewMax) {
            currentReader.elements.deleteDatabase.style.display = '';
          }
        }
      },

      deleteAllTexts(callback = null) {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all texts? This action will also remove all bookmarks.')) {
          if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
            const request = objectStore.clear();
            transaction.oncomplete = () => {
              currentReader.lastSavedPosition = null;
              localStorage.removeItem(currentReader.settingsNames.lastPosition);
              localStorage.removeItem(currentReader.settingsNames.text);
              localStorage.removeItem(currentReader.settingsNames.texts);
              localStorage.removeItem(currentReader.settingsNames.textBookmarks);
              if (callback) {
                return callback();
              }
              currentReader.locationReload();
            };
            transaction.onabort = () => {
              console.error(transaction.error);
              alert(transaction.error);
            };
          }
          else {
            currentReader.lastSavedPosition = null;
            localStorage.removeItem(currentReader.settingsNames.lastPosition);
            localStorage.removeItem(currentReader.settingsNames.text);
            localStorage.removeItem(currentReader.settingsNames.textBookmarks);
          }
        }
        else {
          currentReader.deleteDatabaseViewCounter += 1;
          if (currentReader.deleteDatabaseViewCounter >= currentReader.deleteDatabaseViewMax) {
            currentReader.elements.deleteDatabase.style.display = '';
          }
        }
      },

      deleteDatabase(callback = null) {
        const currentReader = this;
        if (confirm('Are you sure you want to delete the database? This action will also remove all bookmarks.')) {
          if (currentReader.database) {
            currentReader.database.close();
            const request = indexedDB.deleteDatabase(currentReader.databaseName);
            request.onsuccess = () => {
              currentReader.lastSavedPosition = null;
              localStorage.removeItem(currentReader.settingsNames.lastPosition);
              localStorage.removeItem(currentReader.settingsNames.settingsProfile);
              localStorage.removeItem(currentReader.settingsNames.settingsProfiles);
              localStorage.removeItem(currentReader.settingsNames.text);
              localStorage.removeItem(currentReader.settingsNames.texts);
              localStorage.removeItem(currentReader.settingsNames.textBookmarks);
              if (callback) {
                return callback();
              }
              currentReader.locationReload();
            };
            request.onerror = (event) => {
              console.error(event.target.error);
              alert(event.target.error);
            };
            request.onblocked = (event) => {
              console.error(event.type);
              alert(event.type);
            };
          }
          else {
            currentReader.lastSavedPosition = null;
            localStorage.removeItem(currentReader.settingsNames.lastPosition);
            localStorage.removeItem(currentReader.settingsNames.settingsProfile);
            localStorage.removeItem(currentReader.settingsNames.settingsProfiles);
            localStorage.removeItem(currentReader.settingsNames.text);
            localStorage.removeItem(currentReader.settingsNames.texts);
            localStorage.removeItem(currentReader.settingsNames.textBookmarks);
          }
        }
      },

      importAllSettingsProfilesAux(data, callback = null) {
        const currentReader = this;
        try {
          const jsonParsed = JSON.parse(data), newSettingsProfiles = [];
          for (const jsonObject of (jsonParsed[currentReader.settingsNames.settingsProfiles] || [])) {
            const name = jsonObject['name'], settings = JSON.stringify(jsonObject['settings']);
            if (name && settings) {
              newSettingsProfiles.push({
                'name': name,
                'settings': settings
              });
            }
          }
          const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
          if (newSettingsProfiles.length > 0) {
            currentReader.pauseAnimation();
            const transaction = currentReader.database ? currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite') : null;
            const objectStore = currentReader.database ? transaction.objectStore(currentReader.settingsNames.settingsProfiles) : null;
            for (const newSettingsProfile of newSettingsProfiles) {
              const name = newSettingsProfile['name'];
              const settings = newSettingsProfile['settings'];
              if (name === currentReader.defaultSettingsProfileName) {
                if (currentReader.elements.importReplaceToggle.checked) {
                  localStorage.setItem(currentReader.settingsNames.settingsProfile, settings);
                }
              }
              else if (currentReader.database) {
                const included = settingsProfiles.includes(name);
                if (!included) {
                  settingsProfiles.push(name);
                }
                const data = { name: name, settings: settings };
                if (currentReader.elements.importReplaceToggle.checked) {
                  objectStore.put(data);
                }
                else if (!included) {
                  objectStore.add(data);
                }
              }
            }
            if (currentReader.database) {
              transaction.oncomplete = () => {
                localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
                if (callback) {
                  return callback(jsonParsed);
                }
                currentReader.locationReload();
              };
              transaction.onabort = () => {
                console.error(transaction.error);
                alert(transaction.error);
              };
            }
            else {
              if (callback) {
                return callback(jsonParsed);
              }
              currentReader.locationReload();
            }
          }
          else {
            if (callback) {
              return callback(jsonParsed);
            }
            alert('No settings profiles found in the file');
          }
        }
        catch (err) {
          console.error(err);
          alert(`Error importing settings profiles: ${err}`);
        }
      },

      importAllSettingsProfiles(callback = null) {
        const currentReader = this;
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new settings profiles?')) {
            return;
          }
        }
        const element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            const f = event.target.files[0];
            if (f) {
              const r = new FileReader;
              r.addEventListener("load", (function (event) {
                return currentReader.importAllSettingsProfilesAux(event.target.result, callback);
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality is not supported by your browser")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAllTextsAux(data, callback = null) {
        const currentReader = this;
        try {
          const jsonParsed = JSON.parse(data), newTexts = [];
          for (const jsonObject of (jsonParsed[currentReader.settingsNames.texts] || [])) {
            const title = jsonObject['title'], content = jsonObject['content'], bookmarks = jsonObject['bookmarks'];
            if (title && content) {
              newTexts.push({
                'title': title,
                'content': content,
                'bookmarks': JSON.stringify(bookmarks || [])
              });
            }
          }
          const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          if (newTexts.length > 0) {
            currentReader.stopPlayback(true);
            const transaction = currentReader.database ? currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite') : null;
            const objectStore = currentReader.database ? transaction.objectStore(currentReader.settingsNames.texts) : null;
            for (const newText of newTexts) {
              const title = newText['title'];
              const content = newText['content'];
              const bookmarks = newText['bookmarks'];
              if (title === currentReader.defaultTextName) {
                if (currentReader.elements.importReplaceToggle.checked) {
                  localStorage.setItem(currentReader.settingsNames.text, content);
                  localStorage.setItem(currentReader.settingsNames.textBookmarks, bookmarks);
                  if (currentReader.currentTextName === currentReader.defaultTextName) {
                    currentReader.lastSavedPosition = null;
                    localStorage.removeItem(currentReader.settingsNames.lastPosition);
                  }
                }
              }
              else if (currentReader.database) {
                const included = texts.includes(title);
                if (!included) {
                  texts.push(title);
                }
                const data = {
                  title: title,
                  content: content,
                  bookmarks: bookmarks,
                };
                let changed = false;
                if (currentReader.elements.importReplaceToggle.checked) {
                  objectStore.put(data);
                  changed = true;
                }
                else if (!included) {
                  objectStore.add(data);
                  changed = true;
                }
                if (changed && currentReader.currentTextName === title) {
                  currentReader.lastSavedPosition = null;
                  localStorage.removeItem(currentReader.settingsNames.lastPosition);
                }
              }
            }
            if (currentReader.database) {
              transaction.oncomplete = () => {
                localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
                if (callback) {
                  return callback(jsonParsed);
                }
                currentReader.locationReload();
              };
              transaction.onabort = () => {
                console.error(transaction.error);
                alert(transaction.error);
              };
            }
            else {
              if (callback) {
                return callback(jsonParsed);
              }
              currentReader.locationReload();
            }
          }
          else {
            if (callback) {
              return callback(jsonParsed);
            }
            alert('No texts found in the file');
          }
        }
        catch (err) {
          console.error(err);
          alert(`Error importing texts: ${err}`);
        }
      },

      importAllTexts(callback = null) {
        const currentReader = this;
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new texts?')) {
            return;
          }
        }
        const element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            const f = event.target.files[0];
            if (f) {
              const r = new FileReader;
              r.addEventListener("load", (function (event) {
                return currentReader.importAllTextsAux(event.target.result, callback);
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality is not supported by your browser")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAllSettingsProfilesAndTexts(afterSuccessCallback = null) {
        const currentReader = this;
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new settings profiles?')) {
            return;
          }
        }
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new texts?')) {
            return;
          }
        }
        const element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            const f = event.target.files[0];
            if (f) {
              const r = new FileReader;
              r.addEventListener("load", (function (event) {
                currentReader.importAllSettingsProfilesAux(event.target.result, (jsonParsed1) => {
                  currentReader.importAllTextsAux(event.target.result, (jsonParsed2) => {
                    if (afterSuccessCallback) {
                      return afterSuccessCallback(jsonParsed2);
                    }
                    currentReader.locationReload();
                  });
                });
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality is not supported by your browser")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAll() {
        const currentReader = this;
        currentReader.importAllSettingsProfilesAndTexts((jsonParsed) => {
          if (!currentReader.elements.importReplaceToggle.checked) {
            return;
          }
          for (const [k, v] of Object.entries(jsonParsed)) {
            if (k == null || v == null) {
              continue;
            }
            if (
              k !== currentReader.settingsNames.textBookmarks &&
              k !== currentReader.settingsNames.texts &&
              k !== currentReader.settingsNames.text &&
              k !== currentReader.settingsNames.settingsProfiles &&
              k !== currentReader.settingsNames.settingsProfile
            ) {
              localStorage.setItem(k, v);
            }
          }
          currentReader.locationReload();
        });
      },

      exportAllSettingsProfiles(callback = null) {
        const currentReader = this;
        const defaultSettingsProfile = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfile) || '{}');
        const settingsProfilesKey = currentReader.settingsNames.settingsProfiles;
        const exportData = {};
        exportData[settingsProfilesKey] = [];
        exportData[settingsProfilesKey].push({
          name: currentReader.defaultSettingsProfileName,
          settings: defaultSettingsProfile
        });
        if (!currentReader.database) {
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData);
          return;
        }
        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const profiles = request.result;
          profiles.forEach(profile => {
            exportData[settingsProfilesKey].push({
              name: profile.name,
              settings: JSON.parse(profile.settings)
            });
          });
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData, 'settings_profiles');
        };
        request.onerror = (event) => {
          const message = `Error exporting settings profiles: ${event.target.error}`;
          console.error(event.target.error);
          alert(message);
        };
      },

      exportAllTexts(callback = null) {
        const currentReader = this;
        const defaultText = localStorage.getItem(currentReader.settingsNames.text) || '';
        const defaultTextBookmarks = JSON.parse(localStorage.getItem(currentReader.settingsNames.textBookmarks) || '[]');
        const textsKey = currentReader.settingsNames.texts;
        const exportData = {};
        exportData[textsKey] = [];
        exportData[textsKey].push({
          title: currentReader.defaultTextName,
          content: defaultText,
          bookmarks: currentReader.elements.exportAllTextsWithBookmarksToggle.checked ? defaultTextBookmarks : []
        });
        if (!currentReader.database) {
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData);
          return;
        }
        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const texts = request.result;
          texts.forEach(text => {
            exportData[textsKey].push({
              title: text.title,
              content: text.content,
              bookmarks: currentReader.elements.exportAllTextsWithBookmarksToggle.checked ? JSON.parse(text.bookmarks || '[]') : [],
            });
          });
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData, 'texts');
        };
        request.onerror = () => {
          const message = `Error exporting texts: ${event.target.error}`;
          console.error(event.target.error);
          alert(message);
        };
      },

      exportAllSettingsProfilesAndTexts(afterSuccessCallback = null) {
        const currentReader = this;
        currentReader.exportAllSettingsProfiles((exportData1) => {
          return currentReader.exportAllTexts((exportData2) => {
            const name = 'settings_profiles_and_texts';
            const exportData = {
              ...exportData1,
              ...exportData2,
            };
            const newName = afterSuccessCallback ? afterSuccessCallback(exportData) : '';
            currentReader.downloadExportFile(exportData, newName ? newName : name);
          });
        });
      },

      exportAll() {
        const currentReader = this;
        currentReader.exportAllSettingsProfilesAndTexts((exportData) => {
          for (const localStorageSettingName of Object.values(currentReader.settingsNames)) {
            const localStorageSettingValue = localStorage.getItem(localStorageSettingName);
            if (localStorageSettingValue == null) {
              continue;
            }
            if (
              localStorageSettingName !== currentReader.settingsNames.textBookmarks &&
              localStorageSettingName !== currentReader.settingsNames.texts &&
              localStorageSettingName !== currentReader.settingsNames.text &&
              localStorageSettingName !== currentReader.settingsNames.settingsProfiles &&
              localStorageSettingName !== currentReader.settingsNames.settingsProfile
            ) {
              exportData[localStorageSettingName] = localStorageSettingValue;
            }
          }
          return 'all';
        });
      },

      getStrDateTime() {
        let dts = new Date((new Date().setHours(new Date().getHours() - (new Date().getTimezoneOffset() / 60)))).toISOString();
        dts = dts.replace('T', ' ').replaceAll('-', '.').slice(0, 19);
        return dts;
      },

      downloadExportFile(data, dataInfoTag) {
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        const datetimeString = this.getStrDateTime().replaceAll(':', '.').replaceAll(' ', '_');
        link.download = `reading_${dataInfoTag}_${datetimeString}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
      },

      locationReload() {
        setTimeout(function () {
          location.reload();
        }, 1);
      },

      adjustSpeechRate(value) {
        this.speechRate = parseFloat(value);
        this.elements.speechRateSlider.value = value;
        this.elements.speechRateDisplay.value = value;
        localStorage.setItem(this.settingsNames.voiceSpeechRate, this.speechRate);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      loadVoices() {
        const updateVoices = () => {
          this.voices = this.speechSynthesis.getVoices();
          this.elements.voiceSelect.innerHTML = this.voices.map((voice, index) =>
            `<option value="${index}">[${voice.lang}] ${voice.name}</option>`
          ).join('');
        };
        this.speechSynthesis.onvoiceschanged = updateVoices;
        updateVoices();
      },

      updateVoice() {
        localStorage.setItem(this.settingsNames.voice, this.elements.voiceSelect.value);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      toggleSpeechButton() {
        this.elements.textToSpeechContainer.style.display = this.elements.showSpeakButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.voiceButton, this.elements.showSpeakButtonToggle.checked);
      },

      toggleSearchButton() {
        this.elements.searchContainer.style.display = this.elements.showSearchButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.searchButton, this.elements.showSearchButtonToggle.checked);
      },

      toggleBookmarksButton() {
        this.elements.bookmarksContainer.style.display = this.elements.showBookmarksButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.bookmarksButton, this.elements.showBookmarksButtonToggle.checked);
      },

      toggleSpeech() {
        if (!this.speechSynthesis) return;

        const currentReader = this;

        const startUpdate = function () {
          currentReader.isSpeaking = true;
          currentReader.elements.speakButton.textContent = 'Stop';
          currentReader.elements.playPauseButton.disabled = true;
          currentReader.elements.stopButton.disabled = true;
          currentReader.elements.rewindButton.disabled = true;
          currentReader.elements.fastForwardButton.disabled = true;
          currentReader.elements.refreshText.disabled = true;
          currentReader.elements.refreshColors.disabled = true;
          currentReader.elements.copyMarqueeText.disabled = true;
          currentReader.elements.searchButton.style.display = 'none';
          currentReader.elements.bookmarksButton.style.display = 'none';
          currentReader.elements.underControlsContainer.style.display = '';
          currentReader.elements.loopToggle.style.display = 'none';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = 'none';
          currentReader.elements.tabContent.style.display = 'none';
          currentReader.animationStartTime = Date.now();
          currentReader.isSpeaking = true;
        };

        const stopUpdate = function () {
          currentReader.speechSynthesis.cancel();
          currentReader.isSpeaking = false;
          currentReader.elements.speakButton.textContent = 'Speak';
          currentReader.elements.playPauseButton.disabled = false;
          currentReader.elements.stopButton.disabled = false;
          currentReader.elements.rewindButton.disabled = false;
          currentReader.elements.fastForwardButton.disabled = false;
          currentReader.elements.refreshText.disabled = false;
          currentReader.elements.refreshColors.disabled = false;
          currentReader.elements.copyMarqueeText.disabled = false;
          currentReader.elements.searchButton.style.display = '';
          currentReader.elements.bookmarksButton.style.display = '';
          currentReader.elements.underControlsContainer.style.display = '';
          currentReader.elements.loopToggle.style.display = '';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = '';
          currentReader.elements.tabContent.style.display = '';
          const speakMarks = currentReader.elements.progressBarContainer.querySelectorAll('.speak-mark');
          speakMarks.forEach(mark => mark.remove());
          currentReader.isSpeaking = false;
        };

        if (this.isSpeaking) {
          stopUpdate();
          return;
        }

        this.startAnimation(false, false);
        const processedText = this.elements.marqueeDisplay.textContent;
        const realText = this.elements.fasterTransitionsToggle.checked ? this.previousText.replaceAll('.', ';') : this.previousText;
        if (!processedText || !realText) {
          return;
        }

        let startSpanIndex = 0;
        const spans = Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span'));
        const words = realText.split(/\s+/).filter(w => w);
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const shift = containerWidth * Math.max(0, Math.min(0.5, containerWidth / 100 - 5));
        if (this.currentPosition !== null) {
          const startPos = shift;
          const endPos = shift - textWidth;
          const progress = (this.currentPosition - startPos) / (endPos - startPos);
          const charIndex = Math.floor(progress * processedText.length);
          let currentCharCount = 0;
          for (let i = 0; i < spans.length; i++) {
            currentCharCount += spans[i].textContent.length + 1;
            if (currentCharCount > charIndex) {
              startSpanIndex = i;
              break;
            }
          }
        }

        if (spans.length <= startSpanIndex || words.length <= startSpanIndex || spans.length !== words.length) {
          return;
        }
        const realTextFromIndex = words.slice(startSpanIndex).join(' ');

        const wordCount = words.length;
        const utterance = new SpeechSynthesisUtterance(realTextFromIndex);
        const selectedVoiceIndex = parseInt(this.elements.voiceSelect.value);
        if (this.voices[selectedVoiceIndex]) {
          utterance.voice = this.voices[selectedVoiceIndex];
        }
        utterance.rate = this.speechRate / 100;

        const spanPositions = spans.slice(startSpanIndex).map(span => {
          const spanRect = span.getBoundingClientRect();
          const marqueeRect = this.elements.marqueeDisplay.getBoundingClientRect();
          return -(spanRect.left - marqueeRect.left);
        });

        const mark = document.createElement('div');
        mark.className = `speak-mark`;
        mark.style.left = Math.max(0, Math.min(100, (shift * 100 / containerWidth))) + '%';
        mark.addEventListener('click', (event) => {
          event.stopPropagation();
        });
        let markAdded = false;

        utterance.onboundary = (event) => {
          if (event.name === 'word') {
            const wordIndex = realTextFromIndex.substring(0, event.charIndex).split(/\s+/).filter(w => w).length;
            const spanIndex = Math.min(wordIndex, spanPositions.length - 1);

            const startPos = containerWidth;
            const endPos = -textWidth;

            currentReader.currentPosition = spanPositions[spanIndex];
            currentReader.currentPosition = Math.max(endPos, Math.min(startPos, currentReader.currentPosition + shift));
            currentReader.elements.marqueeDisplay.style.left = `${currentReader.currentPosition}px`;

            const newLastUpdateTime = Date.now();
            const elapsedTime = (newLastUpdateTime - currentReader.animationStartTime) / 1000;
            const wordsPerSecond = wordIndex / elapsedTime;
            const remainingWords = wordCount - wordIndex;
            const secondsRemaining = wordsPerSecond ? (remainingWords / wordsPerSecond) : 0;

            currentReader.elements.progressDisplay.innerHTML = currentReader.formatTime(secondsRemaining);
            const wpm = elapsedTime > 0 ? Math.floor(wordIndex / (elapsedTime / 60)) : wordCount;
            currentReader.elements.progressDisplay.innerHTML += `<br>WPM: ${wpm}`;
            const progress = Math.max(0, Math.min(100, Math.floor((currentReader.currentPosition - startPos) * 100 / (endPos - startPos))));
            currentReader.elements.progressDisplay.innerHTML += `<br>Progress: ${progress}%`;

            if (!markAdded) {
              currentReader.elements.progressBarContainer.appendChild(mark);
              markAdded = true;
            }
            currentReader.updateProgressBar();
          }
        };

        utterance.onend = () => {
          const startPos = containerWidth;
          const endPos = -textWidth;

          currentReader.currentPosition = endPos;
          currentReader.elements.marqueeDisplay.style.left = `${currentReader.currentPosition}px`;

          const newLastUpdateTime = Date.now();
          const elapsedTime = (newLastUpdateTime - currentReader.animationStartTime) / 1000;
          const wordsPerSecond = (wordCount - 1) / elapsedTime;
          const remainingWords = wordCount - (wordCount - 1);
          const secondsRemaining = wordsPerSecond ? (remainingWords / wordsPerSecond) : 0;

          currentReader.elements.progressDisplay.innerHTML = currentReader.formatTime(secondsRemaining);
          const wpm = elapsedTime > 0 ? Math.floor((wordCount - 1) / (elapsedTime / 60)) : wordCount;
          currentReader.elements.progressDisplay.innerHTML += `<br>WPM: ${wpm}`;
          const progress = Math.max(0, Math.min(100, Math.floor((currentReader.currentPosition - startPos) * 100 / (endPos - startPos))));
          currentReader.elements.progressDisplay.innerHTML += `<br>Progress: ${progress}%`;

          if (markAdded) {
            mark.remove();
          }

          currentReader.lastSavedPosition = currentReader.currentPosition;
          currentReader.updateProgressBar();
          stopUpdate();

          if (currentReader.elements.loopToggle.classList.contains('active')) {
            currentReader.currentPosition = null;
            setTimeout(() => currentReader.toggleSpeech(), 50);
          }
        };

        startUpdate();
        this.speechSynthesis.speak(utterance);
      },

      toggleSearch() {
        const currentReader = this;

        if (this.animationTimer || this.isSpeaking) {
          alert('Stop animation or speech first');
          return;
        }

        this.startAnimation(false, false);
        this.textToSearch = this.elements.marqueeDisplay.textContent;
        if (!this.textToSearch) {
          return;
        }

        this.isSearchActive = !this.isSearchActive;
        this.elements.searchButton.textContent = this.isSearchActive ? 'Close' : 'Search';
        this.elements.searchControls.style.display = this.isSearchActive ? 'block' : 'none';

        if (this.isSearchActive) {
          currentReader.elements.playPauseButton.disabled = true;
          currentReader.elements.stopButton.disabled = true;
          currentReader.elements.rewindButton.disabled = false;
          currentReader.elements.fastForwardButton.disabled = false;
          currentReader.elements.refreshText.disabled = true;
          currentReader.elements.refreshColors.disabled = true;
          currentReader.elements.copyMarqueeText.disabled = true;
          currentReader.elements.speakButton.style.display = 'none';
          currentReader.elements.bookmarksButton.style.display = 'none';
          currentReader.elements.underControlsContainer.style.display = '';
          currentReader.elements.loopToggle.style.display = 'none';
          currentReader.elements.progressDisplay.style.display = 'none';
          currentReader.elements.tabNavigation.style.display = 'none';
          currentReader.elements.tabContent.style.display = 'none';
          currentReader.elements.searchInput.focus();
          currentReader.handleSearchInput(currentReader.elements.searchInput.value);
        } else {
          currentReader.elements.playPauseButton.disabled = false;
          currentReader.elements.stopButton.disabled = false;
          currentReader.elements.rewindButton.disabled = false;
          currentReader.elements.fastForwardButton.disabled = false;
          currentReader.elements.refreshText.disabled = false;
          currentReader.elements.refreshColors.disabled = false;
          currentReader.elements.copyMarqueeText.disabled = false;
          currentReader.elements.speakButton.style.display = '';
          currentReader.elements.bookmarksButton.style.display = '';
          currentReader.elements.underControlsContainer.style.display = '';
          currentReader.elements.loopToggle.style.display = '';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = '';
          currentReader.elements.tabContent.style.display = '';
          currentReader.clearSearch();
        }
      },

      handleSearchInput(query) {
        this.searchQuery = query.trim();
        this.searchMatches = [];
        this.currentMatchIndex = -1;
        const text = this.textToSearch;

        if (!this.searchQuery || !text) {
          this.updateProgressBar();
          return;
        }

        this.updateCachedSizes();
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = 0;
        const endPos = containerWidth - textWidth;
        const caseInsensitive = this.searchQuery === this.searchQuery.toLowerCase();

        const spans = Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span'));
        const queryWords = this.searchQuery.split(/\s+/).filter(word => word);
        for (let i = 0; i <= spans.length - queryWords.length; i++) {
          const matchSpans = [];
          let isMatch = true;
          let matchText = '';
          for (let j = 0; j < queryWords.length; j++) {
            const span = spans[i + j];
            const spanText = caseInsensitive ? span.textContent.toLowerCase() : span.textContent;
            matchText += (j > 0 ? ' ' : '') + spanText;
            if (!spanText.includes(queryWords[j])) {
              isMatch = false;
              break;
            }
            matchSpans.push(span);
          }
          if (isMatch && matchText.includes(this.searchQuery)) {
            const firstSpanRect = matchSpans[0].getBoundingClientRect();
            const marqueeRect = this.elements.marqueeDisplay.getBoundingClientRect();
            const position = -(firstSpanRect.left - marqueeRect.left);
            const matchLength = matchSpans.reduce((sum, span) => sum + span.getBoundingClientRect().width, 0) +
              (matchSpans.length - 1) * parseFloat(getComputedStyle(matchSpans[0]).marginRight || 0);
            this.searchMatches.push({ spanElements: matchSpans, position, matchLength });
          }
        }

        this.updateProgressBar();
        if (this.searchMatches.length > 0) {
            this.currentMatchIndex = 0;
            this.goToMatch(this.currentMatchIndex);
        }
      },

      goToMatch(index) {
        if (index < 0 || index >= this.searchMatches.length) return;

        this.currentMatchIndex = index;
        const match = this.searchMatches[this.currentMatchIndex];

        this.currentPosition = match.position;
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const endPos = containerWidth - textWidth;

        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.updateProgressBar();
      },

      goToNextMatch() {
        if (this.searchMatches.length === 0) return;
        const nextIndex = (this.currentMatchIndex + 1) % this.searchMatches.length;
        this.goToMatch(nextIndex);
      },

      goToPreviousMatch() {
        if (this.searchMatches.length === 0) return;
        const prevIndex = this.currentMatchIndex - 1 < 0 ? this.searchMatches.length - 1 : this.currentMatchIndex - 1;
        this.goToMatch(prevIndex);
      },

      clearSearch() {
        this.searchQuery = '';
        this.searchMatches = [];
        this.currentMatchIndex = -1;
        this.textToSearch = '';
        this.elements.searchInput.value = '';
        this.updateProgressBar();
      },

      toggleBookmarks() {
        if (this.animationTimer || this.isSpeaking) {
          alert("Stop animation or speech first");
          return;
        }

        if (!this.previousText) {
          this.startAnimation(false, false);
        }
        if (!this.previousText) {
          return;
        }

        this.isBookmarksActive = !this.isBookmarksActive;

        if (this.isBookmarksActive) {
          this.tmpBookmarks = JSON.parse(JSON.stringify(this.currentTextBookmarks));
          this.elements.bookmarksButton.style.display = "none";
          this.elements.bookmarksControls.style.display = "";
          this.elements.playPauseButton.disabled = true;
          this.elements.stopButton.disabled = true;
          this.elements.rewindButton.disabled = false;
          this.elements.fastForwardButton.disabled = false;
          this.elements.refreshText.disabled = true;
          this.elements.refreshColors.disabled = true;
          this.elements.copyMarqueeText.disabled = true;
          this.elements.speakButton.style.display = 'none';
          this.elements.searchButton.style.display = 'none';
          this.elements.underControlsContainer.style.display = '';
          this.elements.loopToggle.style.display = 'none';
          this.elements.progressDisplay.style.display = 'none';
          this.elements.tabNavigation.style.display = 'none';
          this.elements.tabContent.style.display = 'none';
          this.loadBookmarks();
        } else {
          this.tmpBookmarks = [];
          this.elements.bookmarksButton.style.display = "";
          this.elements.bookmarksControls.style.display = "none";
          this.elements.playPauseButton.disabled = false;
          this.elements.stopButton.disabled = false;
          this.elements.rewindButton.disabled = false;
          this.elements.fastForwardButton.disabled = false;
          this.elements.refreshText.disabled = false;
          this.elements.refreshColors.disabled = false;
          this.elements.copyMarqueeText.disabled = false;
          this.elements.speakButton.style.display = '';
          this.elements.searchButton.style.display = '';
          this.elements.underControlsContainer.style.display = '';
          this.elements.loopToggle.style.display = '';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = '';
          this.elements.tabContent.style.display = '';
          const bookmarkMarks = this.elements.progressBarContainer.querySelectorAll(".bookmark-mark");
          bookmarkMarks.forEach(mark => mark.remove());
          this.updateProgressBar();
        }
      },

      loadBookmarks() {
        const currentReader = this;
        currentReader.elements.bookmarksList.innerHTML = "";
        const bookmarks = currentReader.tmpBookmarks.sort((a, b) => a.progress - b.progress);
        bookmarks.forEach((bookmark, index) => {
          const bookmarkDiv = document.createElement("div");
          bookmarkDiv.className = "bookmark-item items-border";

          const nameElem = document.createElement("div");
          nameElem.textContent = bookmark.name;
          nameElem.innerHTML += '<br>' + bookmark.progress.toFixed(2) + '%';
          nameElem.className = "bookmark-name clickable";
          nameElem.onclick = () => currentReader.goToBookmark(bookmark.progress);

          const removeButton = document.createElement("button");
          removeButton.textContent = "Remove";
          removeButton.className = "bookmark-remove-button dark-button";
          removeButton.onclick = () => currentReader.removeBookmark(index);

          bookmarkDiv.appendChild(nameElem);
          bookmarkDiv.appendChild(removeButton);
          currentReader.elements.bookmarksList.appendChild(bookmarkDiv);
        });
        currentReader.updateBookmarkMarks();
      },

      addBookmark() {
        const name = this.elements.bookmarkNameInput.value.trim();
        if (!name) {
          alert("The bookmark name is empty");
          return;
        }
        if (this.currentPosition === null) return;

        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = containerWidth;
        const endPos = -textWidth;
        const progress = Math.max(0, Math.min(100, (this.currentPosition - startPos) * 100 / (endPos - startPos)));
        this.tmpBookmarks.push({ name, progress });
        this.elements.bookmarkNameInput.value = "";
        this.loadBookmarks();
      },

      removeBookmark(index) {
        this.tmpBookmarks.splice(index, 1);
        this.loadBookmarks();
      },

      goToBookmark(progress) {
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = containerWidth;
        const endPos = -textWidth;
        const position = progress * (endPos - startPos) / 100 + startPos;
        this.currentPosition = position;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.lastSavedPosition = this.currentPosition;
        this.updateProgressBar();
      },

      saveBookmarksToDB() {
        const currentReader = this;

        if (!currentReader.database) return;

        const bookmarks = (this.isBookmarksActive ? this.tmpBookmarks : this.currentTextBookmarks).sort((a, b) => a.progress - b.progress);

        if (currentReader.currentTextName === currentReader.defaultTextName) {
          localStorage.setItem(currentReader.settingsNames.textBookmarks, JSON.stringify(bookmarks));
          currentReader.currentTextBookmarks = bookmarks;
          currentReader.toggleBookmarks();
          return;
        }

        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], "readwrite");
        const store = transaction.objectStore(currentReader.settingsNames.texts);
        const request = store.get(currentReader.currentTextName);
        request.onsuccess = () => {
          const data = request.result;
          const updatedData = {
            ...data,
            bookmarks: JSON.stringify(bookmarks)
          };
          const nextRequest = store.put(updatedData);
          nextRequest.onsuccess = () => {
            currentReader.currentTextBookmarks = bookmarks;
            currentReader.toggleBookmarks();
          };
          nextRequest.onerror = (event) => {
            const message = `Failed to save bookmarks to database: ${event.target.error}`;
            console.error(event.target.error);
            alert(message);
          };
        };
        request.onerror = () => {
          const message = `Failed to save bookmarks to database: ${event.target.error}`;
          console.error(event.target.error);
          alert(message);
        };
      },

      updateBookmarkMarks() {
        const currentReader = this;
        const bookmarks = (currentReader.isBookmarksActive ? currentReader.tmpBookmarks : currentReader.currentTextBookmarks).sort((a, b) => a.progress - b.progress);
        const bookmarkMarks = currentReader.elements.progressBarContainer.querySelectorAll(".bookmark-mark");
        bookmarkMarks.forEach(mark => mark.remove());
        bookmarks.forEach(bookmark => {
          const containerWidth = currentReader.cachedContainerWidth;
          const textWidth = currentReader.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;
          const mark = document.createElement("div");
          mark.className = "bookmark-mark";
          mark.style.left = `${bookmark.progress}%`;
          mark.title = bookmark.name;
          mark.addEventListener("click", (event) => {
            event.stopPropagation();
            currentReader.goToBookmark(bookmark.progress);
          });
          currentReader.elements.progressBarContainer.appendChild(mark);
        });
      },

    };

    document.addEventListener('DOMContentLoaded', () => {
      MarqueeReader.initialize();
    });
  </script>
</body>
</html>