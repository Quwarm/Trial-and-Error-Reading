<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trial and Error Reading</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <style>
    :root {
      --background-color: #eeeeee;
      --text-color: #333;
      --container-background: #efefef;
      --border-color: rgb(90, 90, 90);
      --border-color-inv: #e0e0e0;
      --green-button-background: rgb(25, 135, 84);
      --green-button-hover: rgb(21, 115, 71);
      --purple-button-background: rgb(84, 25, 135);
      --purple-button-hover: rgb(71, 21, 115);
      --orange-button-background: rgb(218, 104, 11);
      --orange-button-hover: rgb(194, 93, 10);
      --red-button-background: rgb(187, 45, 59);
      --red-button-hover: rgb(180, 25, 46);
      --cyan-button-background: rgb(11, 166, 197);
      --cyan-button-hover: rgb(9, 130, 153);
      --gray-button-background: rgb(200, 200, 200);
      --gray-button-text: rgb(0, 0, 0);
      --gray-button-hover: rgb(210, 210, 210);
      --gray-button-disabled-background: rgb(230, 230, 230);
      --gray-button-disabled-text: rgb(173, 173, 173);
      --blue-button-background: rgb(13, 110, 253);
      --blue-button-hover: rgb(11, 94, 215);
      --dark-button-background: rgb(55, 55, 55);
      --dark-button-hover: rgb(66, 70, 73);
    }

    body.dark {
      --background-color: #1a1a1a;
      --text-color: #e0e0e0;
      --container-background: #2a2a2a;
      --border-color: #e0e0e0;
      --border-color-inv: rgb(90, 90, 90);
      --gray-button-background: rgb(90, 90, 90);
      --gray-button-text: rgb(255, 255, 255);
      --gray-button-hover: rgb(80, 80, 80);
      --gray-button-disabled-background: rgb(90, 90, 90);
      --gray-button-disabled-text: rgb(70, 70, 70);
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    span {
      unicode-bidi: embed;
    }

    .container.normal-size {
      max-width: 1000px;
      margin: 0 auto;
    }

    .container.max-size {
      max-width: 100%;
      margin: 0 auto;
    }

    #marquee-controls-container,
    #marquee-container,
    #controls-container,
    #text-to-speech-container,
    #additional-settings-container {
      text-align: center;
    }

    label {
      display: block;
      padding-top: 5px;
      padding-bottom: 5px;
    }

    #text-input {
      width: 100%;
      min-height: 300px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: var(--container-background);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    #color-input {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: var(--container-background);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    #marquee-container {
      width: 100%;
      height: 60px;
      overflow: hidden;
      position: relative;
      border: 2px solid var(--border-color);
      padding-left: 2px;
      padding-right: 2px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      direction: ltr;
      background-color: var(--container-background);
    }

    #marquee-display {
      position: absolute;
      white-space: nowrap;
      line-height: 60px;
      text-align: right;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin: 2px;
      background-color: var(--gray-button-background);
      color: white;
    }

    .blue-button {
      background-color: var(--blue-button-background);
    }

    .blue-button:hover {
      background-color: var(--blue-button-hover);
    }

    .green-button {
      background-color: var(--green-button-background);
    }

    .green-button:hover {
      background-color: var(--green-button-hover);
    }

    .cyan-button {
      background-color: var(--cyan-button-background);
    }

    .cyan-button:hover {
      background-color: var(--cyan-button-hover);
    }

    .dark-button {
      background-color: var(--dark-button-background);
    }

    .dark-button:hover {
      background-color: var(--dark-button-hover);
    }

    .action-button {
      background-color: var(--gray-button-background);
      color: var(--gray-button-text);
    }

    .action-button:hover {
      background-color: var(--gray-button-hover);
    }

    .action-button:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    #color-details {
      font-size: 22px;
    }

    #play-pause-button, #stop-button, #speak-button {
      min-width: 100px;
    }

    #play-pause-button {
      background-color: var(--green-button-background);
    }
    
    #play-pause-button:hover {
      background-color: var(--green-button-hover);
    }

    #play-pause-button.pause {
      background-color: var(--orange-button-background);
    }

    #play-pause-button.pause:hover {
      background-color: var(--orange-button-hover);
    }

    #speak-button {
      background-color: var(--purple-button-background);
    }

    #speak-button:hover {
      background-color: var(--purple-button-hover);
    }

    #stop-button {
      background-color: var(--red-button-background);
    }

    #stop-button:hover {
      background-color: var(--red-button-hover);
    }

    #play-pause-button:disabled, #stop-button:disabled, #speak-button:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    .marquee-letter-span {
      box-sizing: border-box;
      display: inline-block;
    }

    .marquee-word-span {
      display: inline-block;
    }

    body.marquee-theme-1 .marquee-letter-span {
      border-left: 1px dashed var(--border-color-inv);
      border-right: 1px dashed var(--border-color-inv);
    }

    body.marquee-theme-2 .marquee-letter-span,
    body.marquee-theme-3 .marquee-letter-span,
    body.marquee-theme-4 .marquee-letter-span {
      border-left: 1px solid var(--border-color-inv);
      border-right: 1px solid var(--border-color-inv);
    }

    body.marquee-theme-3 .marquee-word-span {
      border-left: 1px solid var(--border-color);
      border-right: 1px solid var(--border-color);
    }

    body.marquee-theme-4 .marquee-word-span {
      border-left: 2px solid var(--border-color);
      border-right: 2px solid var(--border-color);
    }

    body.marquee-theme-1 #marquee-display {
      letter-spacing: 1px;
      word-spacing: 1px;
    }

    body.marquee-theme-2 #marquee-display {
      letter-spacing: 3px;
      word-spacing: 20px;
    }

    body.marquee-theme-3 #marquee-display {
      letter-spacing: 5px;
      word-spacing: 25px;
    }

    body.marquee-theme-4 #marquee-display {
      letter-spacing: 5px;
      word-spacing: 30px;
    }

    #speed-display,
    #font-size-display {
      text-align: center;
    }

    input[type="text"],
    input[type="number"],
    select {
      padding: 8px 4px;
      text-align: center;
    }

    .clickable {
      cursor: pointer;
    }

    #letter-shuffle-select,
    #letter-elimination-select,
    #word-shuffle-select {
      min-width: 150px;
    }

    .select-label {
      min-width: 150px;
      display: inline-block;
    }

    input[type="range"] {
      width: 225px;
      padding: 0 4px;
    }

    input[type="number"] {
      width: 70px;
    }

    input[type="checkbox"] {
      transform: scale(1.4);
      margin: 7px 4px;
    }

    kbd {
      border: 1px solid;
      border-radius: 3px;
      padding: 1px 4px;
      font-size: 12px;
      font-family: monospace;
    }

    body.light kbd {
      background-color: rgb(200, 200, 200);
      border-color: rgb(90, 90, 90);
      color: #333;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    body.dark kbd {
      background-color: rgb(60, 60, 60);
      border-color: rgb(200, 200, 200);
      color: #e0e0e0;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    a {
      text-decoration: none;
      font-weight: bold;
    }

    body.light a {
      color: #aaa;
    }

    body.light a:hover {
      color: #555;
    }

    body.dark a {
      color: #555;
    }

    body.dark a:hover {
      color: #aaa;
    }

    .mt-10 {
      margin-top: 10px;
    }

    .mt-20 {
      margin-top: 20px;
    }

    .mb-10 {
      margin-bottom: 10px;
    }

    .mb-20 {
      margin-bottom: 20px;
    }

    #tab-navigation {
      display: flex;
      justify-content: space-around;
    }

    .tab-button {
      flex: 1;
      padding: 10px;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    body.light .tab-button {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
    }

    body.light .tab-button.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark .tab-button {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
    }

    body.dark .tab-button.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    .tab-content {
      display: none;
      text-align: center;
    }

    .tab-content.active {
      display: block;
    }

    .items-border {
      border-radius: 10px;
      padding: 2px;
    }

    body.light .items-border {
      border: 2px solid rgb(230, 230, 230);
    }

    body.light .items-border.active {
      border: 2px solid rgb(200, 200, 200);
    }

    body.dark .items-border {
      border: 2px solid rgb(90, 90, 90);
    }

    body.dark .items-border.active {
      border: 2px solid rgb(90, 90, 90);
    }

    body.light #loop-toggle {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
      min-width: 70px;
    }

    body.light #loop-toggle.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark #loop-toggle {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
      min-width: 70px;
    }

    body.dark #loop-toggle.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    #progress-bar-container {
      width: 100%;
      height: 20px;
      background-color: var(--container-background);
      border: 1px solid var(--border-color);
      position: relative;
      cursor: pointer;
      margin-bottom: 5px;
    }

    #progress-bar {
      height: 100%;
      background-color: var(--green-button-background);
      width: 0%;
      transition: width 0.1s linear;
    }

    body.dark #progress-bar {
      background-color: var(--green-button-hover);
    }

    #info-tab ul {
      list-style-type: disc;
      padding-left: 20px;
      text-align: left;
      max-width: 600px;
      margin: 0 auto;
    }
    #info-tab li {
      margin-bottom: 10px;
    }

    #settings-profile-select, #text-select {
      min-width: 20%;
      max-width: 50%;
      padding: 8px;
      text-align: center;
    }

    @media (max-width: 600px) {
      button {
        width: 100%;
        margin: 10px 0;
      }
      kbd {
        display: none;
      }
      #settings-profile-select, #text-select {
        min-width: 100%;
        max-width: 100%;
      }
      input[type="range"] {
        width: 30%;
        margin-right: 25%;
      }
      input[type="number"] {
        width: 30%;
      }
      select {
        width: 100%;
      }
      #tab-navigation {
        flex-direction: column;
        border: 5px solid var(--border-color-inv);
        border-radius: 10px;
        padding: 2px;
        margin-bottom: 10px;
      }
      .tab-button {
        margin-bottom: 5px;
      }
    }
  </style>
</head>
<body class="">
  <div id="main-container" class="container normal-size">
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>

    <div id="marquee-container" class="mt-20">
      <span id="marquee-display"></span>
    </div>

    <div id="controls-container" class="mt-10">
      <div>
        <button id="rewind-button" class="action-button" disabled>&lt;&lt; <kbd>←</kbd></button>
        <button id="play-pause-button">Start <kbd>Space</kbd></button>
        <button id="stop-button">Stop <kbd>S</kbd></button>
        <button id="fast-forward-button" class="action-button" disabled>&gt;&gt; <kbd>→</kbd></button>
      </div>
      <div id="text-to-speech-container" class="mt-10">
        <button id="speak-button">Speak</button>
      </div>
      <div>
        <button id="loop-toggle">Loop <kbd>L</kbd></button>
        <div id="progress-display" class="mt-10" style="display: none;"></div>
        <div id="color-details" class="mt-10" style="display: none;"></div>
      </div>
    </div>

    <div id="tab-navigation" class="mt-10" role="tablist">
      <button class="tab-button active" data-tab="manipulations-tab" role="tab" aria-selected="true">Manipulations</button>
      <button class="tab-button" data-tab="texts-tab" role="tab" aria-selected="false">Texts</button>
      <button class="tab-button" data-tab="settings-tab" role="tab" aria-selected="false">Settings</button>
      <button class="tab-button" data-tab="info-tab" role="tab" aria-selected="false">Information</button>
    </div>

    <div id="tab-content">
      <div id="manipulations-tab" class="tab-content active items-border">
        <div class="mt-10">
          <select id="settings-profile-select"></select>
          <button id="new-settings-profile-button" class="green-button">New Settings</button>
          <button id="save-settings-profile-button" class="blue-button">Save Settings</button>
          <button id="delete-settings-profile-button" class="dark-button">Delete Settings</button>
        </div>
        <div id="marquee-controls-container" class="mt-10">
          <button id="refresh-text" class="action-button" disabled>↻ Text ↻ <kbd>T</kbd></button>
          <button id="refresh-colors" class="action-button" disabled>↻ Colors ↻ <kbd>C</kbd></button>
          <button id="copy-text" class="action-button" disabled>⏏ Copy text ⏏</button>
        </div>
        <div class="mt-10">
          <label>Text size</label>
          <input type="range" id="font-size-slider" min="8" max="50" value="50">
          <input type="number" id="font-size-display" min="8" max="50" value="50">
        </div>
        <div class="mt-10">
          <label>Speed <kbd>+</kbd><kbd>-</kbd></label>
          <input type="range" id="speed-slider" min="1" max="200" value="100">
          <input type="number" id="speed-display" min="1" max="200" value="100">
        </div>
        <div class="mt-10">
          <span class="select-label">Shuffling letters:</span>
          <select id="letter-shuffle-select">
            <option value="no">-</option>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="medium_plus">Medium+</option>
            <option value="hard">Hard</option>
            <option value="very-hard">Very Hard</option>
          </select>
        </div>
        <div class="mt-10">
          <span class="select-label">Eliminating letters:</span>
          <select id="letter-elimination-select">
            <option value="no">-</option>
            <option value="20%_vowels">20% vowels</option>
            <option value="40%_vowels">40% vowels</option>
            <option value="60%_vowels">60% vowels</option>
            <option value="80%_vowels">80% vowels</option>
            <option value="100%_vowels">Almost all vowels</option>
            <option value="10%_random">10% smart-random</option>
            <option value="20%_random">20% smart-random</option>
            <option value="30%_random">30% smart-random</option>
            <option value="40%_random">40% smart-random</option>
          </select>
        </div>
        <div class="mt-10">
          <span class="select-label">Shuffling words:</span>
          <select id="word-shuffle-select">
            <option value="no">-</option>
            <option value="2_words">Two words</option>
            <option value="3_words">Three words</option>
            <option value="4_words">Four words</option>
            <option value="5_words">Five words</option>
          </select>
        </div>
        <div id="color-encoder-div" class="mt-10">
          <label><input type="checkbox" id="color-encoder-toggle" checked> Color encoder task <kbd>E</kbd></label>
          <div id="color-encoder-options" class="mt-10">
            <span>Number of letters:</span>
            <input type="number" id="color-letter-count" min="0" max="32" value="1">
          </div>
          <button id="dump-colors" class="mt-10">Dump colors</button>
          <textarea id="color-input" placeholder="&lt;letter&gt; &lt;color&gt;&#13;&#10;a rgb(0, 0, 0)&#13;&#10;b red&#13;&#10;..."></textarea>
        </div>
        <div class="mt-10">
        </div>
      </div>
      <div id="texts-tab" class="tab-content items-border">
        <div class="mt-10">
          <select id="text-select">
          </select>
          <button id="new-text-button" class="green-button">New Text</button>
          <button id="save-text-button" class="blue-button">Save Text</button>
          <button id="delete-text-button" class="dark-button">Delete Text</button>
        </div>
        <div class="mt-10">
          <label>Text</label>
          <textarea id="text-input" placeholder="Enter text here"></textarea>
        </div>
        <div class="mt-10">
          <button id="load-sentence">Load [one of the 22831 sentences] <kbd>N</kbd></button>
          <button id="load-wiki">Load [random wiki summary]</button>
          <button id="load-file">Load [from file]</button>
          <button id="load-metaphorpsum" style="display: none;">Load [random sentence from metaphorpsum]</button>
          <label><input type="checkbox" id="append-text-toggle" checked> Append text after loading/fetching</label>
        </div>
        <div class="mt-10">
          <button id="clear-text" class="dark-button">Clear</button>
        </div>
      </div>
      <div id="settings-tab" class="tab-content items-border">
        <div class="mt-10">
          <label id="show-color-info-element"><input type="checkbox" id="show-color-info-toggle" checked> Show letters-colors info <kbd>ESC</kbd></label>
        </div>
        <div class="mt-10 items-border">
          <label>Appearance</label>
          <button id="marquee-theme-toggle" class="cyan-button">Toggle Marquee Text Block Theme</button>
          <button id="theme-toggle" class="cyan-button">Toggle Theme</button>
          <button id="full-size-toggle" class="cyan-button">Toggle Full Size</button>
        </div>
        <div class="mt-10 items-border">
          <label>Text-to-Speech</label>
          <label id="show-button-element"><input type="checkbox" id="show-button-toggle" checked> Show Speak button</label>
          <div>
            <select id="voice-select"></select>
          </div>
          <label>Speed</label>
          <input type="range" id="speech-rate-slider" min="1" max="300" step="1" value="100">
          <input type="number" id="speech-rate-display" min="1" max="300" step="1" value="100">
        </div>
        <div class="mt-10 items-border">
          <label>Import</label>
          <div>
            <button id="import-all-settings-profiles" class="dark-button">Import all settings profiles</button>
            <button id="import-all-texts" class="dark-button">Import all texts</button>
          </div>
          <div>
            <button id="import-all-settings-profiles-and-texts" class="dark-button">Import all settings profiles and texts</button>
            <button id="import-all" class="dark-button">Import all</button>
          </div>
        </div>
        <div class="mt-10 items-border">
          <label>Export</label>
          <div>
            <button id="export-all-settings-profiles" class="dark-button">Export all settings profiles</button>
            <button id="export-all-texts" class="dark-button">Export all texts</button>
          </div>
          <div>
            <button id="export-all-settings-profiles-and-texts" class="dark-button">Export all settings profiles and texts</button>
            <button id="export-all" class="dark-button">Export all</button>
          </div>
        </div>
        <div class="mt-10 items-border">
          <label>Delete</label>
          <div>
            <button id="delete-all-settings-profiles" class="dark-button">Delete all settings profiles</button>
            <button id="delete-all-texts" class="dark-button">Delete all texts</button>
          </div>
          <div>
            <button id="delete-database" class="dark-button">Delete the entire database</button>
          </div>
        </div>
      </div>
      <div id="info-tab" class="tab-content items-border">
        <div class="mt-20">
            <p>Here are some tips and recommendations to help you effectively use this website:</p>
            <ul>
                <li><strong>Resist checking answers too soon:</strong> Avoid looking up the solution until you're certain you don't know a word or have spent enough time trying to figure it out.</li>
                <li><strong>Take breaks:</strong> Regular breaks can improve your problem-solving efficiency and keep your mind fresh.</li>
                <li><strong>Be patient with progress:</strong> Improvements may take months and depends on how often you train, as well as your diet and sleep quality.</li>
                <li><strong>Short sessions are key:</strong> Training twice a day in short bursts is more effective than one long session daily.</li>
                <li><strong>Quality over quantity:</strong> Fully solving a few sentences per day is better than partially solving many.</li>
                <li><strong>Challenge yourself:</strong> Solving without changing the text combination on the go (via "↻ Text ↻" button) is harder and more beneficial than adjusting it mid-session.</li>
                <li><strong>Increase difficulty:</strong> Continuously ramp up the exercise difficulty to maintain progress, rather than staying at an easy level for too long.</li>
            </ul>
        </div>
        <div class="mb-20"></div>
        <a href="https://github.com/Quwarm/Trial-and-Error-Reading" target="_blank">GitHub</a>
      </div>
    </div>
  </div>

  <div id="text-helper" style="display: none;"></div>

  <script>
    const MarqueeReader = {
      animationTimer: null,
      currentPosition: null,
      animationStartTime: null,
      lastUpdateTime: null,
      colorMap: new Map(),
      colorList: [],
      previousText: null,
      previousLetterShuffle: '',
      previousWordShuffle: '',
      previousLetterElimination: '',
      previousColorInput: '',
      previousPosition: null,
      wasColorTaskEnabled: null,
      wasColorTaskChecked: true,
      isLoopEnabled: false,
      wordCount: 0,
      lastSavedPosition: null,
      lastSavedPositionUpdateDelay: 500,

      elements: {},

      databaseName: 'TrialAndErrorReadingDB',
      databaseVersion: 2,
      database: null,
      defaultTextName: 'Default',
      currentTextName: 'Default',
      textIsModified: false,
      defaultSettingsProfileName: 'Default',
      currentSettingsProfileName: 'Default',
      settingsProfileIsModified: false,
      deleteDatabaseViewCounter: 0,
      deleteDatabaseViewMax: 3,

      vowelPattern: null,
      letterPattern: null,
      punctuationPattern: null,

      cachedContainerWidth: null,
      cachedTextWidth: null,

      speechSynthesis: null,
      isSpeaking: false,
      currentVoice: null,
      voices: [],
      speechRate: 100,

      themes: [
        'dark',
        'light'
      ],

      marqueeThemes: [
        'marquee-theme-1',
        'marquee-theme-2',
        'marquee-theme-3',
        'marquee-theme-4'
      ],

      sentenceGenerator: null,

      settingsNames: {
        // texts
        currentTextName: 'sle_current_text_name',
        text: 'sle_text',
        texts: 'sle_texts',

        // settings profiles
        currentSettingsProfile: 'sle_current_settings_profile',
        settingsProfile: 'sle_settings_profile',
        settingsProfiles: 'sle_settings_profiles',

        // profile settings
        colorTaskToggle: 'sle_color_task_toggle',
        colorTaskLetters: 'sle_color_task_letters',
        colorTaskColors: 'sle_color_task_colors',
        speed: 'sle_speed',
        shufflingLetters: 'sle_shuffling_letters',
        shufflingWords: 'sle_shuffling_words',
        eliminatingLetters: 'sle_eliminating_letters',
        textSize: 'sle_text_size',

        // non-profile settings
        showColorInfoToggle: 'sle_show_color_info_toggle',
        appendTextToggle: 'sle_append_text_toggle',
        loop: 'sle_loop',
        theme: 'sle_theme',
        marqueeThemeToggle: 'sle_marquee_theme_toggle',
        appSizeToggle: 'sle_app_size_toggle',
        activeTab: 'sle_active_tab',
        lastPosition: 'sle_last_position',

        // text-to-speech
        voiceButton: 'sle_voice_button',
        voice: 'sle_voice',
        voiceSpeechRate: 'sle_voice_speech_rate'
      },

      getDefaultSettingsProfile() {
        let settings = {};
        settings[this.settingsNames.colorTaskToggle] = false;
        settings[this.settingsNames.colorTaskLetters] = '1';
        settings[this.settingsNames.colorTaskColors] = '';
        settings[this.settingsNames.speed] = '90';
        settings[this.settingsNames.shufflingLetters] = 'no';
        settings[this.settingsNames.shufflingWords] = 'no';
        settings[this.settingsNames.eliminatingLetters] = 'no';
        settings[this.settingsNames.textSize] = '42';
        return settings;
      },

      getCurrentSettingsProfile() {
        let settings = {};
        settings[this.settingsNames.colorTaskToggle] = this.elements.colorEncoderToggle.checked;
        settings[this.settingsNames.colorTaskLetters] = this.elements.colorLetterCount.value;
        settings[this.settingsNames.colorTaskColors] = this.elements.colorInput.value;
        settings[this.settingsNames.speed] = this.elements.speedDisplay.value;
        settings[this.settingsNames.shufflingLetters] = this.elements.letterShuffleSelect.value;
        settings[this.settingsNames.shufflingWords] = this.elements.wordShuffleSelect.value;
        settings[this.settingsNames.eliminatingLetters] = this.elements.letterEliminationSelect.value;
        settings[this.settingsNames.textSize] = this.elements.fontSizeDisplay.value;
        return settings;
      },

      setSettingsProfile(settingsProfileData) {
        const defaultSettings = this.getDefaultSettingsProfile();
        const keys = Object.keys(settingsProfileData);

        let currentKey = this.settingsNames.colorTaskToggle;
        this.elements.colorEncoderToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.colorTaskLetters;
        this.elements.colorLetterCount.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.colorTaskColors;
        this.elements.colorInput.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.speed;
        this.elements.speedDisplay.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.shufflingLetters;
        this.elements.letterShuffleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.shufflingWords;
        this.elements.wordShuffleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.eliminatingLetters;
        this.elements.letterEliminationSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.textSize;
        this.elements.fontSizeDisplay.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        this.adjustSpeed(this.elements.speedDisplay.value);
        this.adjustFontSize(this.elements.fontSizeDisplay.value);
        this.toggleColorEncoder();
      },

      initialize() {
        const currentReader = this;
        console.info(currentReader);
        currentReader.loadBackground();
        currentReader.cacheElements();
        try {
          currentReader.speechSynthesis = window.speechSynthesis;
          currentReader.loadVoices();
          currentReader.loadDb(function () {
            try {
              currentReader.setupPatterns();
              currentReader.bindEvents();
              currentReader.loadPreferences();
            }
            catch (err) {
              console.error(err);
              currentReader.elements.mainContainer.innerHTML = `Not supported:<br>${err}`;
            }
          });
        }
        catch (err) {
          console.error(err);
          currentReader.elements.mainContainer.innerHTML = `Not supported:<br>${err}`;
        }
      },

      loadBackground() {
        this.elements.body = document.body;
        this.elements.body.classList.add(localStorage.getItem(this.settingsNames.theme) || this.themes[0]);
      },

      cacheElements() {
        this.elements.mainContainer = document.getElementById('main-container');
        this.elements.textInput = document.getElementById('text-input');
        this.elements.speedSlider = document.getElementById('speed-slider');
        this.elements.speedDisplay = document.getElementById('speed-display');
        this.elements.progressDisplay = document.getElementById('progress-display');
        this.elements.colorDetails = document.getElementById('color-details');
        this.elements.appendTextToggle = document.getElementById('append-text-toggle');
        this.elements.letterShuffleSelect = document.getElementById('letter-shuffle-select');
        this.elements.wordShuffleSelect = document.getElementById('word-shuffle-select');
        this.elements.letterEliminationSelect = document.getElementById('letter-elimination-select');
        this.elements.marqueeDisplay = document.getElementById('marquee-display');
        this.elements.marqueeControlsContainer = document.getElementById('marquee-controls-container');
        this.elements.marqueeContainer = document.getElementById('marquee-container');
        this.elements.playPauseButton = document.getElementById('play-pause-button');
        this.elements.stopButton = document.getElementById('stop-button');
        this.elements.themeToggle = document.getElementById('theme-toggle');
        this.elements.fullSizeToggle = document.getElementById('full-size-toggle');
        this.elements.deleteAllSettingsProfiles = document.getElementById('delete-all-settings-profiles');
        this.elements.deleteAllTexts = document.getElementById('delete-all-texts');
        this.elements.deleteDatabase = document.getElementById('delete-database');
        this.elements.clearText = document.getElementById('clear-text');
        this.elements.loadSentence = document.getElementById('load-sentence');
        this.elements.loadWiki = document.getElementById('load-wiki');
        this.elements.loadMetaphorpsum = document.getElementById('load-metaphorpsum');
        this.elements.loadFile = document.getElementById('load-file');
        this.elements.colorEncoderToggle = document.getElementById('color-encoder-toggle');
        this.elements.colorEncoderOptions = document.getElementById('color-encoder-options');
        this.elements.colorLetterCount = document.getElementById('color-letter-count');
        this.elements.rewindButton = document.getElementById('rewind-button');
        this.elements.fastForwardButton = document.getElementById('fast-forward-button');
        this.elements.colorInput = document.getElementById('color-input');
        this.elements.dumpColors = document.getElementById('dump-colors');
        this.elements.showColorInfoElement = document.getElementById('show-color-info-element');
        this.elements.showColorInfoToggle = document.getElementById('show-color-info-toggle');
        this.elements.refreshText = document.getElementById('refresh-text');
        this.elements.refreshColors = document.getElementById('refresh-colors');
        this.elements.copyText = document.getElementById('copy-text');
        this.elements.textHelper = document.getElementById('text-helper');
        this.elements.marqueeThemeToggle = document.getElementById('marquee-theme-toggle');
        this.elements.loopToggle = document.getElementById('loop-toggle');
        this.elements.fontSizeSlider = document.getElementById('font-size-slider');
        this.elements.fontSizeDisplay = document.getElementById('font-size-display');
        this.elements.tabButtons = document.querySelectorAll('.tab-button');
        this.elements.tabNavigation = document.getElementById('tab-navigation');
        this.elements.tabContent = document.getElementById('tab-content');
        this.elements.tabContents = document.querySelectorAll('.tab-content');
        this.elements.progressBarContainer = document.getElementById('progress-bar-container');
        this.elements.progressBar = document.getElementById('progress-bar');
        this.elements.textSelect = document.getElementById('text-select');
        this.elements.newTextButton = document.getElementById('new-text-button');
        this.elements.deleteTextButton = document.getElementById('delete-text-button');
        this.elements.saveTextButton = document.getElementById('save-text-button');
        this.elements.colorEncoderDiv = document.getElementById('color-encoder-div');
        this.elements.settingsProfileSelect = document.getElementById('settings-profile-select');
        this.elements.newSettingsProfileButton = document.getElementById('new-settings-profile-button');
        this.elements.deleteSettingsProfileButton = document.getElementById('delete-settings-profile-button');
        this.elements.saveSettingsProfileButton = document.getElementById('save-settings-profile-button');
        this.elements.textToSpeechContainer = document.getElementById('text-to-speech-container');
        this.elements.showButtonToggle = document.getElementById('show-button-toggle');
        this.elements.speakButton = document.getElementById('speak-button');
        this.elements.voiceSelect = document.getElementById('voice-select');
        this.elements.speechRateSlider = document.getElementById('speech-rate-slider');
        this.elements.speechRateDisplay = document.getElementById('speech-rate-display');
        this.elements.importAllSettingsProfiles = document.getElementById('import-all-settings-profiles');
        this.elements.importAllTexts = document.getElementById('import-all-texts');
        this.elements.importAllSettingsProfilesAndTexts = document.getElementById('import-all-settings-profiles-and-texts');
        this.elements.importAll = document.getElementById('import-all');
        this.elements.exportAllSettingsProfiles = document.getElementById('export-all-settings-profiles');
        this.elements.exportAllTexts = document.getElementById('export-all-texts');
        this.elements.exportAllSettingsProfilesAndTexts = document.getElementById('export-all-settings-profiles-and-texts');
        this.elements.exportAll = document.getElementById('export-all');

        this.cachedContainerWidth = null;
        this.cachedTextWidth = null;
        this.elements.deleteDatabase.style.display = 'none';
      },

      loadDb(callback) {
        const currentReader = this;
        const hideTextSelectElements = function () {
          currentReader.elements.textSelect.style.display = 'none';
          currentReader.elements.newTextButton.style.display = 'none';
          currentReader.elements.deleteTextButton.style.display = 'none';
          currentReader.elements.settingsProfileSelect.style.display = 'none';
          currentReader.elements.newSettingsProfileButton.style.display = 'none';
          currentReader.elements.deleteSettingsProfileButton.style.display = 'none';
        }
        currentReader.database = null;
        try {
          const request = indexedDB.open(currentReader.databaseName, currentReader.databaseVersion);
          request.onupgradeneeded = function (event) {
            currentReader.database = event.target.result;
            currentReader.database.createObjectStore(currentReader.settingsNames.texts, { keyPath: "title" });
            currentReader.database.createObjectStore(currentReader.settingsNames.settingsProfiles, { keyPath: "name" });
          };
          request.onsuccess = function (event) {
            currentReader.database = event.target.result;
            callback();
          };
          request.onerror = function (event) {
            currentReader.database = null;
            const message = `IndexedDB error: ${event.target.errorCode}`;
            console.error(message);
            hideTextSelectElements();
            alert(message);
            callback();
          };
          request.onblocked = function (event) {
            currentReader.database = null;
            const message = `IndexedDB blocked: ${event.target.errorCode}`;
            console.error(message);
            hideTextSelectElements();
            alert(message);
            callback();
          };
        } catch (err) {
          currentReader.database = null;
          console.error(err);
          hideTextSelectElements();
          callback();
        }
      },

      updateCachedSizes() {
        this.cachedContainerWidth = Math.ceil(this.elements.marqueeContainer.getBoundingClientRect().width);
        this.cachedTextWidth = Math.ceil(this.elements.marqueeDisplay.getBoundingClientRect().width);
      },

      setupPatterns() {
        this.vowelPattern = new RegExp('[\u0041\u0045\u0049\u004f\u0055\u0410\u0415\u0401\u0418\u041e\u0423\u042b\u042d\u042e\u042f\u0391\u0395\u0397\u0399\u039f\u03a5\u03a9\u0101\u012b\u016b\u0113\u014d]', 'ui');
        this.letterPattern = new RegExp(/\p{L}/, 'ui');
        this.punctuationPattern = new RegExp(/\p{S}|\p{Ps}|\p{Pe}|\p{Pi}|\p{Pf}|[!"#%&*,./:;?@^]|^-$/, 'ui');
        this.vowelPatternG = new RegExp(this.vowelPattern, 'uig');
        this.letterPatternG = new RegExp(this.letterPattern, 'uig');
      },

      bindEvents() {
        this.elements.playPauseButton.addEventListener('click', () => this.togglePlayback());
        this.elements.stopButton.addEventListener('click', () => this.stopPlayback());
        this.elements.themeToggle.addEventListener('click', () => this.switchTheme());
        this.elements.marqueeThemeToggle.addEventListener('click', () => this.switchMarqueeTheme());
        this.elements.fullSizeToggle.addEventListener('click', () => this.toggleFullSize());
        this.elements.deleteAllSettingsProfiles.addEventListener('click', () => this.deleteAllSettingsProfiles());
        this.elements.deleteAllTexts.addEventListener('click', () => this.deleteAllTexts());
        this.elements.deleteDatabase.addEventListener('click', () => this.deleteDatabase());
        this.elements.clearText.addEventListener('click', () => this.clearInput());
        this.elements.loadSentence.addEventListener('click', () => this.fetchSentence());
        this.elements.loadWiki.addEventListener('click', () => this.fetchWikipedia());
        this.elements.loadMetaphorpsum.addEventListener('click', () => this.fetchMetaphorpsum());
        this.elements.loadFile.addEventListener('click', () => this.loadFromFile());
        this.elements.colorEncoderToggle.addEventListener('click', () => this.toggleColorEncoder());
        this.elements.dumpColors.addEventListener('click', () => this.dumpColorMap());
        this.elements.showColorInfoToggle.addEventListener('click', () => this.toggleColorDetails());
        this.elements.appendTextToggle.addEventListener('click', () => this.toggleAppendText());
        this.elements.refreshText.addEventListener('click', () => this.refreshMarqueeText());
        this.elements.refreshColors.addEventListener('click', () => this.refreshMarqueeColors());
        this.elements.copyText.addEventListener('click', () => this.copyMarqueeText());
        this.elements.loopToggle.addEventListener('click', () => this.toggleLoop());
        this.elements.rewindButton.addEventListener('click', () => this.rewind());
        this.elements.fastForwardButton.addEventListener('click', () => this.fastForward());
        this.elements.fontSizeSlider.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeSlider.value));
        this.elements.fontSizeDisplay.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeDisplay.value));
        this.elements.speedSlider.addEventListener('input', () => this.adjustSpeed(this.elements.speedSlider.value));
        this.elements.speedDisplay.addEventListener('input', () => this.adjustSpeed(this.elements.speedDisplay.value));
        this.elements.tabButtons.forEach(button => button.addEventListener('click', () => this.switchTab(button)));
        this.elements.progressBarContainer.addEventListener('click', (e) => this.handleProgressBarClick(e));
        this.elements.textSelect.addEventListener('change', () => this.switchText());
        this.elements.newTextButton.addEventListener('click', () => this.createNewText());
        this.elements.deleteTextButton.addEventListener('click', () => this.deleteCurrentText());
        this.elements.saveTextButton.addEventListener('click', () => this.saveCurrentText());
        this.elements.settingsProfileSelect.addEventListener('change', () => this.switchSettingsProfile());
        this.elements.newSettingsProfileButton.addEventListener('click', () => this.createNewSettingsProfile());
        this.elements.deleteSettingsProfileButton.addEventListener('click', () => this.deleteCurrentSettingsProfile());
        this.elements.saveSettingsProfileButton.addEventListener('click', () => this.saveCurrentSettingsProfile());
        this.elements.showButtonToggle.addEventListener('click', () => this.toggleSpeechButton());
        this.elements.speakButton.addEventListener('click', () => this.toggleSpeech());
        this.elements.voiceSelect.addEventListener('change', () => this.updateVoice());
        this.elements.speechRateSlider.addEventListener('input', () => this.adjustSpeechRate(this.elements.speechRateSlider.value));
        this.elements.speechRateDisplay.addEventListener('input', () => this.adjustSpeechRate(this.elements.speechRateDisplay.value));
        this.elements.importAllSettingsProfiles.addEventListener('click', () => this.importAllSettingsProfiles());
        this.elements.importAllTexts.addEventListener('click', () => this.importAllTexts());
        this.elements.importAllSettingsProfilesAndTexts.addEventListener('click', () => this.importAllSettingsProfilesAndTexts());
        this.elements.importAll.addEventListener('click', () => this.importAll());
        this.elements.exportAllSettingsProfiles.addEventListener('click', () => this.exportAllSettingsProfiles());
        this.elements.exportAllTexts.addEventListener('click', () => this.exportAllTexts());
        this.elements.exportAllSettingsProfilesAndTexts.addEventListener('click', () => this.exportAllSettingsProfilesAndTexts());
        this.elements.exportAll.addEventListener('click', () => this.exportAll());

        this.elements.textInput.addEventListener('input', () => { this.textIsModified = true; });

        this.elements.fontSizeSlider.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.fontSizeDisplay.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.speedSlider.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.speedDisplay.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.letterShuffleSelect.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.letterEliminationSelect.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.wordShuffleSelect.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.colorEncoderToggle.addEventListener('click', () => { this.settingsProfileIsModified = true; });
        this.elements.colorLetterCount.addEventListener('change', () => { this.settingsProfileIsModified = true; });
        this.elements.dumpColors.addEventListener('click', () => { this.settingsProfileIsModified = true; });
        this.elements.colorInput.addEventListener('change', () => { this.settingsProfileIsModified = true; });

        document.addEventListener('keydown', e => this.handleKeyPress(e));
        const currentReader = this;
        window.addEventListener('resize', () => {
          if (currentReader.currentPosition !== null) {
            currentReader.updateCachedSizes();
            currentReader.updateProgressBar();
          }
        });
        currentReader.restoreActiveTab();
        currentReader.sentenceGenerator = function* () {
          let sentences = [];
          try {
            sentences = getSentences();
          } catch (e) {
            alert('[Sentences.js] Sentences not found!');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();
      },

      loadPreferences() {
        this.elements.rewindButton.disabled = true;
        this.elements.fastForwardButton.disabled = true;
        this.elements.refreshText.disabled = true;
        this.elements.refreshColors.disabled = true;
        this.elements.copyText.disabled = true;
        const marqueeThemeToggle = localStorage.getItem(this.settingsNames.marqueeThemeToggle) || this.marqueeThemes[0];
        this.elements.body.classList.add(marqueeThemeToggle);
        this.elements.marqueeThemeToggle.innerHTML += ` [${marqueeThemeToggle.slice(-1)}]`;
        this.elements.appendTextToggle.checked = localStorage.getItem(this.settingsNames.appendTextToggle) !== 'false';
        this.elements.showColorInfoToggle.checked = localStorage.getItem(this.settingsNames.showColorInfoToggle) !== 'false';
        this.isLoopEnabled = localStorage.getItem(this.settingsNames.loop) === 'true';
        if (this.isLoopEnabled) this.elements.loopToggle.classList.add('active');
        this.elements.mainContainer.classList.add(localStorage.getItem(this.settingsNames.appSize) || 'normal-size');
        this.elements.showButtonToggle.checked = localStorage.getItem(this.settingsNames.voiceButton) === 'true';
        this.toggleSpeechButton();

        const voiceIndex = localStorage.getItem(this.settingsNames.voice) || null;
        if (voiceIndex != null) {
          this.elements.voiceSelect.value = voiceIndex;
        }
        const voiceSpeechRate = localStorage.getItem(this.settingsNames.voiceSpeechRate) || null;
        if (voiceSpeechRate != null) {
          this.adjustSpeechRate(voiceSpeechRate);
        }

        const currentTextName = localStorage.getItem(this.settingsNames.currentTextName) || this.defaultTextName;
        const texts = JSON.parse(localStorage.getItem(this.settingsNames.texts) || '[]');
        this.elements.textSelect.innerHTML = `<option value="${this.defaultTextName}">${this.defaultTextName}</option>` + texts.map(text => `<option value="${text}">${text}</option>`).join('');
        this.currentTextName = this.defaultTextName;
        if (texts.includes(currentTextName)) {
          this.currentTextName = currentTextName;
        }
        this.elements.textSelect.value = this.currentTextName;
        this.textIsModified = false;

        const currentSettingsProfileName = localStorage.getItem(this.settingsNames.currentSettingsProfile) || this.defaultSettingsProfileName;
        const settingsProfiles = JSON.parse(localStorage.getItem(this.settingsNames.settingsProfiles) || '[]');
        this.elements.settingsProfileSelect.innerHTML = `<option value="${this.defaultSettingsProfileName}">${this.defaultSettingsProfileName}</option>` + settingsProfiles.map(settingsProfile => `<option value="${settingsProfile}">${settingsProfile}</option>`).join('');
        this.currentSettingsProfileName = this.defaultSettingsProfileName;
        if (settingsProfiles.includes(currentSettingsProfileName)) {
          this.currentSettingsProfileName = currentSettingsProfileName;
        }
        this.elements.settingsProfileSelect.value = this.currentSettingsProfileName;
        this.settingsProfileIsModified = false;

        const currentReader = this;
        currentReader.switchSettingsProfile(function () {
          currentReader.switchText(function () {
            currentReader.toggleAppendText();
            currentReader.toggleColorEncoder(false);
            currentReader.toggleColorDetails();
            currentReader.lastSavedPosition = localStorage.getItem(currentReader.settingsNames.lastPosition);
            if (currentReader.lastSavedPosition && currentReader.elements.textInput.value && confirm('Resume from last position?')) {
              currentReader.currentPosition = parseInt(currentReader.lastSavedPosition);
              setTimeout(() => {
                currentReader.startAnimation(false, false);
                currentReader.elements.progressDisplay.style.display = 'none';
              }, 1);
            } else {
              currentReader.lastSavedPosition = null;
            }
            setInterval(() => currentReader.savePosition(), currentReader.lastSavedPositionUpdateDelay);
          });
        });
      },

      togglePlayback() {
        this.animationTimer ? this.pauseAnimation() : this.startAnimation();
      },

      stopPlayback(fully = false) {
        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
          this.animationTimer = null;
        }
        this.elements.playPauseButton.textContent = 'Start';
        this.elements.playPauseButton.classList.remove('pause');
        this.currentPosition = this.cachedContainerWidth;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.elements.marqueeControlsContainer.style.display = '';
        this.elements.progressDisplay.style.display = 'none';
        this.elements.loopToggle.style.display = '';
        this.lastSavedPosition = null;
        this.elements.tabNavigation.style.display = '';
        this.elements.tabContent.style.display = '';
        this.elements.speakButton.style.display = '';
        this.updateProgressBar();
        if (fully && this.previousText !== null) {
          this.animationStartTime = null;
          this.currentPosition = null;
          this.previousText = '';
          this.wordCount = 0;
          this.elements.rewindButton.disabled = true;
          this.elements.fastForwardButton.disabled = true;
          this.elements.refreshText.disabled = true;
          this.elements.refreshColors.disabled = true;
          this.elements.copyText.disabled = true;
        }
      },

      startAnimation(resume = false, movement = true) {
        let htmlValue = this.elements.textInput.value.replace(/\s+/g, ' ').trim();
        htmlValue = htmlValue.replace(/\p{Z}+/ug, ' ');
        htmlValue = htmlValue.replace(/\p{C}+/ug, '');
        if (!htmlValue) {
          alert('Please add text');
          return false;
        }

        this.elements.textHelper.innerHTML = htmlValue;
        const cleanedText = this.elements.textHelper.textContent || this.elements.textHelper.innerText || "";
        this.elements.textHelper.innerHTML = '';

        if (this.previousText !== cleanedText) {
          this.wordCount = cleanedText.split(/\s+/).filter(word => word.length > 0).length;
        }

        let palleteChanged = false;

        if (!resume && this.elements.colorEncoderToggle.checked) {
          palleteChanged = true;
          const targetSize = parseInt(this.elements.colorLetterCount.value);
          const preservedColors = new Map();
          const preservedLetters = [];
          this.elements.colorInput.value.split('\n').forEach(line => {
            const [letter, ...colorParts] = line.split(/\s+/);
            if (letter && colorParts.length) {
              const color = colorParts.join(' ');
              Array.from(letter.toLowerCase()).forEach(char => {
                preservedLetters.push(char);
                preservedColors.set(char, color);
              });
            }
          });

          if (this.colorMap.size < targetSize || this.previousColorInput !== this.elements.colorInput.value) {
            const newColors = this.generateColors(targetSize);
            const letters = Array.from(this.colorList);
            preservedLetters.forEach(char => {
              if (letters.length < targetSize && cleanedText.includes(char) && !letters.includes(char)) {
                letters.push(char);
              }
            });
            let index = 0;
            for (let i = 0; i < cleanedText.length && letters.length < targetSize; i++) {
              const char = cleanedText[i].toLowerCase();
              if (this.isLetter(char) && !letters.includes(char)) {
                letters.push(char);
                index++;
              }
            }
            letters.sort();
            index = 0;
            letters.forEach(char => {
              if (!this.colorMap.has(char)) {
                this.colorMap.set(char, preservedColors.get(char) || newColors[index++]);
                this.colorList.push(char);
              }
            });
          }
          this.colorList.reverse();
          for (let x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              if (preservedColors.get(x) == null) {
                this.colorMap.delete(x);
                this.colorList.splice(this.colorList.indexOf(x), 1);
              }
            }
            else {
              break;
            }
          }
          this.colorList.sort((a, b) => (preservedLetters.indexOf(a) - preservedLetters.indexOf(b)));
          this.colorList.reverse();
          for (let x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              this.colorMap.delete(x);
              this.colorList.splice(this.colorList.indexOf(x), 1);
            }
            else {
              break;
            }
          }
          this.colorList.sort();
          this.elements.colorDetails.style.display = this.elements.showColorInfoToggle.checked ? '' : 'none';
        } else if (!resume && movement) {
          this.elements.colorDetails.style.display = 'none';
        }

        if (!resume) {
          this.elements.colorDetails.innerHTML = this.colorList
            .map((char, index) => {
              let postElem = '';
              if (index !== 0 && index % 5 === 0) {
                postElem = '<br><br>'
              }
              const color = this.colorMap.get(char);
              return `${postElem}${char.toUpperCase()}<span style="background-color:${color};color:${color};" class="marquee-letter-span clickable" onclick="MarqueeReader.updateColor(this)">${char.toUpperCase()}</span>`;
            })
            .join('  ');
        }

        const textNeedsUpdate = this.currentPosition == null || this.previousText !== cleanedText ||
          this.previousLetterShuffle !== this.elements.letterShuffleSelect.value ||
          this.previousLetterElimination !== this.elements.letterEliminationSelect.value ||
          this.previousWordShuffle !== this.elements.wordShuffleSelect.value;

        const colorsNeedsUpdate = !this.wasColorTaskChecked || palleteChanged ||
          this.wasColorTaskEnabled !== this.elements.colorEncoderToggle.checked ||
          (this.elements.colorEncoderToggle.checked && this.previousColorInput !== this.elements.colorInput.value);

        if (textNeedsUpdate || colorsNeedsUpdate) {
          const colorize = this.elements.colorEncoderToggle.checked
            ? char => this.colorMap.has(char.toLowerCase())
              ? `<span style="background-color:${this.colorMap.get(char.toLowerCase())};color:${this.colorMap.get(char.toLowerCase())};" class="marquee-letter-span">${char}</span>`
              : char
            : char => char;
          this.elements.marqueeDisplay.innerHTML = this.processText(
            textNeedsUpdate ? cleanedText : this.elements.marqueeDisplay.textContent,
            cleanedText,
            textNeedsUpdate,
            colorize
          );
        }

        if (!resume) {
          this.updateCachedSizes();
        }

        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = containerWidth;
        const endPos = -textWidth;
        const speed = parseInt(this.elements.speedDisplay.value);

        const stepSize = speed > 80 ? (1 + (speed - 80) / 15) : 1;
        const stepDelay = speed > 20 ? Math.max(10, 110 - speed) : (Math.max(10, 110 - speed) + 10 * (20 - speed));

        this.animationStartTime = Date.now();
        this.lastUpdateTime = this.animationStartTime;
        if (this.currentPosition == null || this.currentPosition <= endPos) this.currentPosition = startPos;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.lastSavedPosition = this.currentPosition;

        this.previousText = cleanedText;
        this.previousLetterShuffle = this.elements.letterShuffleSelect.value;
        this.previousWordShuffle = this.elements.wordShuffleSelect.value;
        this.previousLetterElimination = this.elements.letterEliminationSelect.value;
        this.previousColorInput = this.elements.colorInput.value;
        this.previousPosition = this.currentPosition;
        this.wasColorTaskEnabled = this.elements.colorEncoderToggle.checked;
        this.wasColorTaskChecked = true;

        const animate = () => {
          const newLastUpdateTime = Date.now();
          const step = Math.max(stepSize, (newLastUpdateTime - this.lastUpdateTime) / (stepDelay / stepSize));
          const newPosition = this.currentPosition - step;
          this.lastSavedPosition = newPosition;
          const actualStepDelay = Math.floor((this.lastUpdateTime - this.animationStartTime) / Math.max(1e-9, this.previousPosition - newPosition) * 10) / 10;
          const secondsRemaining = Math.floor(actualStepDelay * (newPosition - endPos) / 1000);
          this.elements.progressDisplay.innerHTML = this.formatTime(secondsRemaining);
          const totalSeconds = actualStepDelay * (startPos - endPos) / 1000;
          const wpm = totalSeconds ? Math.max(1, Math.floor(this.wordCount / (totalSeconds / 60))) : this.wordCount;
          this.elements.progressDisplay.innerHTML += `<br>WPM: ${wpm}`;
          const progress = Math.floor(100 * (1 - (newPosition - endPos) / (startPos - endPos)));
          this.elements.progressDisplay.innerHTML += `<br>Progress: ${progress}%`;
          this.lastUpdateTime = newLastUpdateTime;

          if (newPosition <= endPos) {
            if (this.isLoopEnabled) {
              this.animationStartTime = Date.now();
              this.currentPosition = startPos;
              this.previousPosition = this.currentPosition;
              this.updateProgressBar();
              this.elements.marqueeDisplay.style.left = `${startPos}px`;
              this.lastSavedPosition = null;
              if (this.animationTimer) this.animationTimer = setTimeout(animate, stepDelay);
            } else {
              this.currentPosition = endPos;
              this.previousPosition = this.currentPosition;
              this.updateProgressBar();
              this.elements.marqueeDisplay.style.left = `${endPos}px`;
              clearTimeout(this.animationTimer);
              this.animationTimer = null;
              this.elements.playPauseButton.textContent = 'Start';
              this.elements.playPauseButton.classList.remove('pause');
              this.elements.marqueeControlsContainer.style.display = '';
              this.elements.colorDetails.style.display = this.elements.colorEncoderToggle.checked && this.elements.showColorInfoToggle.checked ? '' : 'none';
              this.elements.loopToggle.style.display = '';
              this.lastSavedPosition = null;
              this.elements.tabNavigation.style.display = '';
              this.elements.tabContent.style.display = '';
              this.elements.speakButton.style.display = '';
            }
          } else {
            this.elements.marqueeDisplay.style.left = `${newPosition}px`;
            this.currentPosition = newPosition;
            this.updateProgressBar();
            if (this.animationTimer) this.animationTimer = setTimeout(animate, stepDelay);
          }
        };

        this.updateProgressBar();
        this.elements.rewindButton.disabled = false;
        this.elements.fastForwardButton.disabled = false;
        this.elements.refreshText.disabled = false;
        this.elements.refreshColors.disabled = false;
        this.elements.copyText.disabled = false;
        if (movement) {
          this.elements.loopToggle.style.display = 'none';
          this.elements.playPauseButton.textContent = 'Pause';
          this.elements.playPauseButton.classList.add('pause');
          this.elements.marqueeControlsContainer.style.display = 'none';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = 'none';
          this.elements.tabContent.style.display = 'none';
          this.elements.speakButton.style.display = 'none';
          this.animationTimer = setTimeout(animate, stepDelay);
        }
        return true;
      },

      pauseAnimation() {
        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
          this.animationTimer = null;
          this.elements.playPauseButton.textContent = 'Start';
          this.elements.playPauseButton.classList.remove('pause');
          this.elements.speakButton.style.display = '';
          this.elements.marqueeControlsContainer.style.display = '';
          this.elements.loopToggle.style.display = '';
          this.elements.colorDetails.style.display = this.elements.colorEncoderToggle.checked && this.elements.showColorInfoToggle.checked ? '' : 'none';
          this.elements.tabNavigation.style.display = '';
          this.elements.tabContent.style.display = '';
          this.updateProgressBar();
        }
      },

      processText(text, referenceText, shouldModify, colorize) {
        const escapeString = str => str.replace(/\\/g, '').replace(/"/g, '').replace(/'/g, "\\'");
        const textLines = text.split('\n');
        const refLines = referenceText.split('\n');
        return textLines.map((line, index) => {
          const words = line.split(/\s+/).filter(word => word);
          const refWords = refLines[index] ? refLines[index].split(/\s+/) : words;
          let processedWords = words;
          let processedRefWords = refWords;

          if (shouldModify && this.elements.wordShuffleSelect.value !== 'no') {
            const match = /(\d+)_words?/.exec(this.elements.wordShuffleSelect.value);
            if (match) {
              const groupSize = parseInt(match[1]);
              const shuffledIndices = this.shuffleWordGroups(words, groupSize);
              processedWords = shuffledIndices.map(i => words[i]);
              processedRefWords = shuffledIndices.map(i => refWords[i]);
            }
          }

          return processedWords.map((word, i) => {
            let modifiedWord = word;
            let skipShuffle = /^[A-Z\d']/.test(word) || /[\u2032\u2033\u2034\u2057\u2019\u0060\u00B4\uFF40\u02F4]/.test(word);

            if (shouldModify && this.elements.letterEliminationSelect.value !== 'no' && word.length > 1) {
              const vowelMatch = /(\d+)%_vowels/.exec(this.elements.letterEliminationSelect.value);
              const randomMatch = /(\d+)%_random/.exec(this.elements.letterEliminationSelect.value);
              if (vowelMatch) {
                modifiedWord = this.eliminateLetters(this.vowelPatternG, modifiedWord, parseInt(vowelMatch[1]) / 100);
              } else if (randomMatch) {
                modifiedWord = this.eliminateLetters(this.letterPatternG, modifiedWord, parseInt(randomMatch[1]) / 100);
              }
            }

            if (shouldModify && this.elements.letterShuffleSelect.value !== 'no' && (!skipShuffle || this.elements.letterShuffleSelect.value === 'very-hard')) {
              const parts = modifiedWord.split('-');
              modifiedWord = parts.map(part => {
                const threshold = this.elements.letterShuffleSelect.value === 'hard' || this.elements.letterShuffleSelect.value === 'very-hard' ? 0 :
                  this.elements.letterShuffleSelect.value === 'medium' || this.elements.letterShuffleSelect.value === 'medium_plus' ? 1 : Math.floor(part.length / 3);
                const suffixLength = this.elements.letterShuffleSelect.value === 'medium_plus' ? 0 : threshold;
                let letters = [];
                for (let x of part) {
                  if (this.isLetter(x)) {
                    letters.push(x);
                  }
                }
                const firstLetters = letters.slice(0, threshold);
                const midLetters = letters.slice(threshold, letters.length - suffixLength);
                const lastLetters = letters.slice(letters.length - suffixLength);
                const originalMiddle = Array.from(midLetters);
                const originalMiddleSize = new Set(originalMiddle).size;
                if (originalMiddleSize > 1) {
                  while (midLetters.join('') === originalMiddle.join('')) {
                    this.shuffleArray(midLetters);
                  }
                }
                const reordered = [...firstLetters, ...midLetters, ...lastLetters];
                let result = '';
                let j = 0;
                for (const char of part) {
                  result += this.isLetter(char) ? reordered[j++] : char;
                }
                return result;
              }).join('-');
            }

            const coloredWord = Array.from(modifiedWord).map(colorize).join('');
            return this.elements.letterShuffleSelect.value !== 'no' || this.elements.letterEliminationSelect.value !== 'no'
              ? `<span class="marquee-word-span clickable" onclick="MarqueeReader.showWordHint('${escapeString(modifiedWord)}', '${escapeString(processedRefWords[i] || word)}')">${coloredWord}</span>`
              : `<span class="marquee-word-span">${coloredWord}</span>`;
          }).join(' ');
        }).join('\n');
      },

      eliminateLetters(regex, word, percentOfLetters) {
        let lettersOnly = word;
        lettersOnly = word.replace(/[^\p{L}]/ug, '');
        let matchIndices = [];
        let isFirstMatch = true;
        regex.lastIndex = 0;
        while (true) {
          let match = regex.exec(word);
          if (match === null) break;
          if (isFirstMatch) {
            isFirstMatch = false;
            if (lettersOnly[0] === word[match.index]) continue;
          }
          matchIndices.push(match.index);
        }
        regex.lastIndex = 0;
        if (matchIndices.length > 0 && word.length >= 2 && regex === this.letterPatternG) {
          let lastIndex = matchIndices[matchIndices.length - 1];
          if (!this.vowelPattern.test(word[lastIndex]) || (lastIndex > 0 && this.vowelPattern.test(word[lastIndex - 1]))) {
            matchIndices.pop();
          }
        }
        let effectiveLength = lettersOnly.length;
        if (regex === this.vowelPatternG) {
          let vowelCount = 0;
          for (let char of word) {
            this.vowelPattern.lastIndex = 0;
            if (this.vowelPattern.test(char)) {
              vowelCount++;
            }
          }
          effectiveLength = vowelCount;
        }
        let numToRemove = Math.min(Math.floor(effectiveLength * percentOfLetters), matchIndices.length);
        let shuffledIndices = Array.from(matchIndices);
        this.shuffleArray(shuffledIndices);
        let duplicateIndices = [];
        let vowelIndices = [];
        let otherIndices = [];
        for (let index of shuffledIndices) {
          if (index > 0 && word[index - 1] === word[index]) {
            duplicateIndices.push(index);
          } else if (this.vowelPattern.test(word[index])) {
            vowelIndices.push(index);
          } else {
            otherIndices.push(index);
          }
        }
        const cmp = (a, b) => b - a;
        duplicateIndices.sort(cmp);
        vowelIndices.sort(cmp);
        otherIndices.sort(cmp);
        let indicesToRemove = [...duplicateIndices, ...vowelIndices, ...otherIndices].slice(0, numToRemove).sort((a, b) => a - b);
        let wordParts = [];
        let start = 0;
        for (let removeIndex of indicesToRemove) {
          if (start < removeIndex) {
            wordParts.push(word.slice(start, removeIndex));
          }
          start = removeIndex + 1;
        }
        if (start < word.length) {
          wordParts.push(word.slice(start));
        }
        return wordParts.join('');
      },

      shuffleWordGroups(words, groupSize) {
        let shuffledIndices = [];
        for (let start = 0; start < words.length;) {
          let groupWords = words.slice(start, start + groupSize);
          let subGroupWords = [groupWords[0]];
          let hasPunctuation = this.punctuationPattern.test(groupWords[0]);
          for (let j = 1; j < groupWords.length; j++) {
            if (hasPunctuation || this.punctuationPattern.test(groupWords[j])) {
              break;
            }
            subGroupWords.push(groupWords[j]);
          }
          groupWords = subGroupWords;
          let groupLength = groupWords.length;
          let shuffleableIndices = [];
          let fixedIndices = new Set();
          for (let j = 0; j < groupLength; j++) {
            if (this.punctuationPattern.test(groupWords[j])) {
              fixedIndices.add(j);
            } else {
              shuffleableIndices.push(j);
            }
          }
          this.shuffleArray(shuffleableIndices);
          let shufflePosition = 0;
          for (let j = 0; j < groupLength; j++) {
            if (fixedIndices.has(j)) {
              shuffledIndices.push(start + j);
            } else {
              shuffledIndices.push(start + shuffleableIndices[shufflePosition]);
              shufflePosition++;
            }
          }
          start += groupLength;
        }
        return shuffledIndices;
      },

      isLetter(char) {
        return /^[a-zA-Z]$/.test(char) || char.toLowerCase() !== char.toUpperCase() || (this.letterPattern && this.letterPattern.test(char));
      },

      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      },

      generateColors(count) {
        const colors = [];
        const isTooDarkOrLight = (r, g, b) => {
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance < 0.2 || luminance > 0.8;
        };
        for (let i = 0; i < count; i++) {
          let r, g, b;
          do {
            r = Math.floor(Math.random() * 256);
            g = Math.floor(Math.random() * 256);
            b = Math.floor(Math.random() * 256);
          } while (isTooDarkOrLight(r, g, b));
          colors.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
        }
        return colors;
      },

      formatTime(seconds) {
        if (seconds < 0) return '00:00:00';
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      },

      switchTheme() {
        const current = this.themes.find(theme => this.elements.body.classList.contains(theme));
        const next = this.themes[(this.themes.indexOf(current) + 1) % this.themes.length] || this.themes[0];
        this.themes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(next);
        localStorage.setItem(this.settingsNames.theme, next);
      },

      switchMarqueeTheme() {
        const current = this.marqueeThemes.find(theme => this.elements.body.classList.contains(theme));
        const next = this.marqueeThemes[(this.marqueeThemes.indexOf(current) + 1) % this.marqueeThemes.length] || this.marqueeThemes[0];
        this.marqueeThemes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(next);
        localStorage.setItem(this.settingsNames.marqueeThemeToggle, next);
        this.elements.marqueeThemeToggle.innerHTML = [...this.elements.marqueeThemeToggle.innerHTML.split(' ').slice(0, -1), `[${next.slice(-1)}]`].join(' ');
      },

      toggleFullSize() {
        const sizes = ['max-size', 'normal-size'];
        const container = document.querySelector('.container');
        const current = sizes.find(size => container.classList.contains(size));
        const next = sizes[(sizes.indexOf(current) + 1) % sizes.length] || sizes[0];
        sizes.forEach(size => container.classList.remove(size));
        container.classList.add(next);
        localStorage.setItem(this.settingsNames.appSize, next);
        if (this.currentPosition !== null) {
          this.updateCachedSizes();
          this.updateProgressBar();
        }
      },

      toggleLoop() {
        this.isLoopEnabled = !this.isLoopEnabled;
        this.elements.loopToggle.classList.toggle('active');
        localStorage.setItem(this.settingsNames.loop, this.isLoopEnabled);
      },

      switchTab(button) {
        this.elements.tabButtons.forEach(btn => {
          btn.classList.remove('active');
          btn.setAttribute('aria-selected', 'false');
        });
        button.classList.add('active');
        button.setAttribute('aria-selected', 'true');
        const tabId = button.getAttribute('data-tab');
        this.elements.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === tabId);
        });
        localStorage.setItem(this.settingsNames.activeTab, button.getAttribute('data-tab'))
      },

      restoreActiveTab() {
        const activeTab = localStorage.getItem(this.settingsNames.activeTab) || 'info-tab';
        if (activeTab) {
          var activeTabButton = document.querySelector(`.tab-button[data-tab="${activeTab}"]`);
          if (activeTabButton) {
            this.switchTab(activeTabButton);
          }
        }
      },

      adjustFontSize(value) {
        this.elements.fontSizeSlider.value = value;
        this.elements.fontSizeDisplay.value = value;
        this.elements.marqueeDisplay.style.fontSize = `${value}px`;
      },

      adjustSpeed(value) {
        this.elements.speedSlider.value = value;
        this.elements.speedDisplay.value = value;
      },

      rewind() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left) + Math.floor(containerWidth / 4)));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      fastForward() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left) - Math.floor(containerWidth / 4)));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      goToStartPosition() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = containerWidth;
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      goToEndPosition() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = -textWidth;
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeText() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          this.previousLetterShuffle = '';
          this.startAnimation(false, false);
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeColors() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          if (this.elements.colorEncoderToggle.checked) {
            this.colorMap.clear();
            this.colorList = [];
          }
          this.startAnimation(false, false);
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      copyMarqueeText() {
        if (this.currentPosition !== null) {
          navigator.clipboard.writeText(this.elements.marqueeDisplay.textContent);
        }
      },

      toggleColorEncoder(updateMarqueeTextBlock = true) {
        const isVisible = this.elements.colorEncoderToggle.checked;
        this.elements.colorInput.style.display = isVisible ? '' : 'none';
        this.elements.dumpColors.style.display = isVisible ? '' : 'none';
        this.elements.colorEncoderOptions.style.display = isVisible ? '' : 'none';
        this.elements.colorDetails.style.display = this.elements.showColorInfoToggle.checked && isVisible ? '' : 'none';
        this.elements.colorEncoderDiv.classList.remove('items-border');
        if (isVisible) {
          this.elements.colorEncoderDiv.classList.add('items-border');
        }
        if (updateMarqueeTextBlock) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          this.wasColorTaskChecked = false;
          if (this.elements.textInput.value) {
            this.startAnimation(false, false);
          }
          if (wasPlaying) this.startAnimation(true);
        }
      },

      toggleColorDetails() {
        const isVisible = this.elements.showColorInfoToggle.checked && this.elements.colorEncoderToggle.checked;
        this.elements.colorDetails.style.display = isVisible ? '' : 'none';
        localStorage.setItem(this.settingsNames.showColorInfoToggle, isVisible);
      },

      toggleAppendText() {
        localStorage.setItem(this.settingsNames.appendTextToggle, this.elements.appendTextToggle.checked);
      },

      dumpColorMap() {
        this.colorList.forEach(char => {
          const color = this.hexToRgb(this.colorMap.get(char));
          const entry = `${char.toUpperCase()} ${color}`;
          if (!this.elements.colorInput.value.includes(entry)) {
            this.elements.colorInput.value += (this.elements.colorInput.value && !this.elements.colorInput.value.endsWith('\n') ? '\n' : '') + entry + '\n';
          }
        });
      },

      clearInput() {
        this.elements.textInput.value = '';
        this.textIsModified = true;
      },

      fetchSentence() {
        if (this.animationTimer) {
          return;
        }
        const next = this.sentenceGenerator.next();
        if (!next.done) {
          const sentence = next.value;
          if (sentence) {
            const text = /[.!?]$/.test(sentence) ? sentence : `${sentence}.`;
            this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
            this.textIsModified = true;
          }
        }
      },

      fetchWikipedia() {
        if (this.animationTimer) {
          return;
        }
        fetch('https://en.wikipedia.org/api/rest_v1/page/random/summary')
          .then(response => response.json())
          .then(data => {
            const text = data.extract.trim();
            this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
            this.textIsModified = true;
          })
          .catch(() => alert('[Wiki] Data Fetching Error.'));
      },

      fetchMetaphorpsum() {
        if (this.animationTimer) {
          return;
        }
        fetch('http://metaphorpsum.com/sentences/1')
          .then(response => response.text())
          .then(text => {
            this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text.trim()}` : text.trim();
            this.textIsModified = true;
          })
          .catch(() => alert('[Metaphorpsum] Data Fetching Error.'));
      },

      loadFromFile() {
        if (this.animationTimer) {
          return;
        }
        const input = document.createElement('input');
        input.type = 'file';
        input.onchange = e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = event => {
              const text = event.target.result.trim();
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            };
            reader.readAsText(file);
          }
        };
        this.elements.body.appendChild(input);
        input.click();
        this.elements.body.removeChild(input);
      },

      savePosition() {
        if (this.lastSavedPosition !== null) {
          localStorage.setItem(this.settingsNames.lastPosition, this.lastSavedPosition);
        } else {
          localStorage.removeItem(this.settingsNames.lastPosition);
        }
      },

      updateColor(element) {
        const newColor = prompt('Enter color:', element.style.color);
        if (newColor) {
          this.colorMap.set(element.textContent.toLowerCase(), newColor);
          element.style.color = newColor;
          element.style.backgroundColor = newColor;
        }
      },

      showWordHint(shuffled, original) {
        alert(`${shuffled} -> ${original}`);
      },

      hexToRgb(hex) {
        if (!/^#[a-f0-9]{3,6}$/i.test(hex)) return hex;
        hex = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (_, r, g, b) => r + r + g + g + b + b);
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : hex;
      },

      handleKeyPress(event) {
        if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) return;
        event.preventDefault();
        switch (event.key) {
          case ' ': this.togglePlayback(); break;
          case 'ArrowUp': this.goToEndPosition(); break;
          case 'ArrowDown': this.goToStartPosition(); break;
          case 'ArrowLeft': this.rewind(); break;
          case 'ArrowRight': this.fastForward(); break;
          case 'l':
          case 'L': this.toggleLoop(); break;
          case 'e':
          case 'E': this.elements.colorEncoderToggle.click(); break;
          case 's':
          case 'S': this.stopPlayback(); break;
          case '+': if (!this.animationTimer) this.elements.speedDisplay.value = parseInt(this.elements.speedDisplay.value) + 1; this.adjustSpeed(this.elements.speedDisplay.value); break;
          case '-': if (!this.animationTimer) this.elements.speedDisplay.value = parseInt(this.elements.speedDisplay.value) - 1; this.adjustSpeed(this.elements.speedDisplay.value); break;
          case 't':
          case 'T': this.refreshMarqueeText(); break;
          case 'c':
          case 'C': this.refreshMarqueeColors(); break;
          case 'n':
          case 'N': this.fetchSentence(); break;
          case 'Escape': if (this.elements.colorEncoderToggle.checked) this.elements.showColorInfoToggle.click(); break;
        }
      },

      updateProgressBar() {
        if (this.currentPosition !== null) {
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;
          const progress = Math.min(100, Math.max(0, Math.floor(100 * (1 - (this.currentPosition - endPos) / (startPos - endPos)) * 10) / 10));
          this.elements.progressBar.style.width = `${progress}%`;
        } else {
          this.elements.progressBar.style.width = '0%';
        }
      },

      handleProgressBarClick(event) {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();

          const rect = this.elements.progressBarContainer.getBoundingClientRect();
          const scrollbarWidth = wasPlaying ? window.innerWidth - document.documentElement.clientWidth : 0;
          const clickX = event.clientX - rect.left - Math.min(20, Math.max(0, scrollbarWidth));

          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;

          const progress = clickX / rect.width;
          this.currentPosition = startPos - (startPos - endPos) * progress;
          this.currentPosition = Math.max(endPos, Math.min(startPos, this.currentPosition));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();

          if (wasPlaying) this.startAnimation(true);
        }
      },

      switchSettingsProfile(callback = null) {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentSettingsProfileName;
        if (!currentReader.database) {
          currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
          return;
        }
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to switch settings profile?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        currentReader.pauseAnimation();
        const selectedSettingsProfileName = currentReader.elements.settingsProfileSelect.value;
        if (selectedSettingsProfileName === currentReader.defaultSettingsProfileName) {
          currentReader.setSettingsProfile(JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfile) || '{}'));
          currentReader.settingsProfileIsModified = false;
          currentReader.currentSettingsProfileName = selectedSettingsProfileName;
          localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
          if (callback) {
            callback();
          }
        } else {
          const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readonly');
          const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
          const request = objectStore.get(selectedSettingsProfileName);
          request.onsuccess = () => {
            currentReader.setSettingsProfile(JSON.parse(request.result ? request.result.settings : ''));
            currentReader.settingsProfileIsModified = false;
            if (callback) {
              callback();
            }
          };
          currentReader.currentSettingsProfileName = selectedSettingsProfileName;
          localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
          request.onerror = () => {
            alert('Error loading text from IndexedDB.');
            currentReader.currentSettingsProfileName = currentReader.defaultSettingsProfileName;
            currentReader.elements.settingsProfileSelect.value = currentReader.defaultSettingsProfileName;
            localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
            currentReader.locationReload();
          };
        }
      },

      switchText(callback = null) {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (!currentReader.database) {
          currentReader.elements.textSelect.value = currentTextName;
          return;
        }
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to switch texts?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        currentReader.stopPlayback(true);
        const selectedTextName = currentReader.elements.textSelect.value;
        if (selectedTextName === currentReader.defaultTextName) {
          currentReader.elements.textInput.value = localStorage.getItem(currentReader.settingsNames.text) || '';
          currentReader.textIsModified = false;
          currentReader.currentTextName = selectedTextName;
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
          if (callback) {
            callback();
          }
        } else {
          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readonly');
          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
          const request = objectStore.get(selectedTextName);
          request.onsuccess = () => {
            currentReader.elements.textInput.value = request.result ? request.result.content : '';
            currentReader.textIsModified = false;
            if (callback) {
              callback();
            }
          };
          currentReader.currentTextName = selectedTextName;
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
          request.onerror = () => {
            alert('Error loading text from IndexedDB.');
            currentReader.currentTextName = currentReader.defaultTextName;
            currentReader.elements.textSelect.value = currentReader.defaultTextName;
            localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
            currentReader.locationReload();
          };
        }
      },

      createNewSettingsProfile() {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentTextName;
        const newSettingsProfile = JSON.stringify(currentReader.getCurrentSettingsProfile());
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to create a new settings profile?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        let name;
        do {
          name = prompt('Enter a unique name for the new settings profile:');
          if (!name) return;
          const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
          if (settingsProfiles.includes(name)) {
            alert('This settings profile name already exists. Please choose another one.');
            name = null;
          }
        } while (!name);
        currentReader.pauseAnimation();
        const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
        settingsProfiles.push(name);
        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
        objectStore.add({ name: name, settings: newSettingsProfile });
        localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        currentReader.elements.settingsProfileSelect.appendChild(option);
        currentReader.elements.settingsProfileSelect.value = name;
        currentReader.settingsProfileIsModified = false;
        currentReader.switchSettingsProfile();
      },

      createNewText() {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to create a new text?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        let name;
        do {
          name = prompt('Enter a unique name for the new text:');
          if (!name) return;
          const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          if (texts.includes(name)) {
            alert('This text name already exists. Please choose another one.');
            name = null;
          }
        } while (!name);
        currentReader.stopPlayback(true);
        const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
        texts.push(name);
        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
        const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
        objectStore.add({ title: name, content: '' });
        localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        currentReader.elements.textSelect.appendChild(option);
        currentReader.elements.textSelect.value = name;
        currentReader.textIsModified = false;
        currentReader.switchText();
      },

      saveCurrentSettingsProfile() {
        const currentReader = this;
        try {
          let currentSettings = JSON.stringify(currentReader.getCurrentSettingsProfile());
          if (currentReader.currentSettingsProfileName === currentReader.defaultSettingsProfileName) {
            localStorage.setItem(currentReader.settingsNames.settingsProfile, currentSettings);
          } else if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
            objectStore.put({ name: currentReader.currentSettingsProfileName, settings: currentSettings });
          }
          localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
          currentReader.settingsProfileIsModified = false;
        }
        catch (err) {
          console.error(err);
          alert(err);
        }
      },

      saveCurrentText() {
        const currentReader = this;
        try {
          if (currentReader.currentTextName === currentReader.defaultTextName) {
            localStorage.setItem(currentReader.settingsNames.text, currentReader.elements.textInput.value);
          } else if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
            objectStore.put({ title: currentReader.currentTextName, content: currentReader.elements.textInput.value });
          }
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
          currentReader.textIsModified = false;
        }
        catch (err) {
          console.error(err);
          alert(err);
        }
      },

      deleteCurrentSettingsProfile() {
        const currentReader = this;
        if (currentReader.currentSettingsProfileName === currentReader.defaultSettingsProfileName) {
          alert(`Cannot delete the ${currentReader.defaultSettingsProfileName} settings profile.`);
          return;
        }
        if (confirm(`Are you sure you want to delete the settings profile "${currentReader.currentSettingsProfileName}"?`)) {
          currentReader.pauseAnimation();
          const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
          const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
          objectStore.delete(currentReader.currentSettingsProfileName);
          let settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
          settingsProfiles = settingsProfiles.filter(profileName => profileName !== currentReader.currentSettingsProfileName);
          localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
          const option = currentReader.elements.settingsProfileSelect.querySelector(`option[value="${currentReader.currentSettingsProfileName}"]`);
          if (option) option.remove();
          currentReader.elements.settingsProfileSelect.value = currentReader.defaultSettingsProfileName;
          currentReader.settingsProfileIsModified = false;
          currentReader.switchSettingsProfile();
        }
      },

      deleteCurrentText() {
        const currentReader = this;
        if (currentReader.currentTextName === currentReader.defaultTextName) {
          alert(`Cannot delete the ${currentReader.defaultTextName} text.`);
          return;
        }
        if (confirm(`Are you sure you want to delete the text "${currentReader.currentTextName}"?`)) {
          currentReader.stopPlayback(true);
          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
          objectStore.delete(currentReader.currentTextName);
          let texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          texts = texts.filter(text => text !== currentReader.currentTextName);
          localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
          const option = currentReader.elements.textSelect.querySelector(`option[value="${currentReader.currentTextName}"]`);
          if (option) option.remove();
          currentReader.elements.textSelect.value = currentReader.defaultTextName;
          currentReader.textIsModified = false;
          currentReader.switchText();
        }
      },

      deleteAllSettingsProfiles() {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all settings profiles?')) {
          localStorage.removeItem(currentReader.settingsNames.settingsProfile);
          if (currentReader.database) {
            try {
              const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
              const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
              const request = objectStore.clear();
              request.onupgradeneeded = function (event) {
                currentReader.locationReload();
              };
              request.onsuccess = function (event) {
                localStorage.removeItem(currentReader.settingsNames.settingsProfiles);
                currentReader.locationReload();
              };
              request.onerror = function (event) {
                const message = `IndexedDB error: ${event.target.errorCode}`;
                alert(message);
                currentReader.locationReload();
              };
              request.onblocked = function (event) {
                const message = `IndexedDB blocked: ${event.target.errorCode}\nTry again later.`;
                alert(message);
                currentReader.locationReload();
              };
            }
            catch (err) {
              alert(err);
              currentReader.locationReload();
            }
          }
          else {
            currentReader.locationReload();
          }
        }
        else {
          currentReader.deleteDatabaseViewCounter += 1;
          if (currentReader.deleteDatabaseViewCounter >= currentReader.deleteDatabaseViewMax) {
            currentReader.elements.deleteDatabase.style.display = '';
          }
        }
      },

      deleteAllTexts() {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all texts?')) {
          currentReader.lastSavedPosition = null;
          localStorage.removeItem(currentReader.settingsNames.lastPosition);
          localStorage.removeItem(currentReader.settingsNames.text);
          if (currentReader.database) {
            try {
              const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
              const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
              const request = objectStore.clear();
              request.onupgradeneeded = function (event) {
                currentReader.locationReload();
              };
              request.onsuccess = function (event) {
                localStorage.removeItem(currentReader.settingsNames.texts);
                currentReader.locationReload();
              };
              request.onerror = function (event) {
                const message = `IndexedDB error: ${event.target.errorCode}`;
                alert(message);
                currentReader.locationReload();
              };
              request.onblocked = function (event) {
                const message = `IndexedDB blocked: ${event.target.errorCode}\nTry again later.`;
                alert(message);
                currentReader.locationReload();
              };
            }
            catch (err) {
              alert(err);
              currentReader.locationReload();
            }
          }
          else {
            currentReader.locationReload();
          }
        }
        else {
          currentReader.deleteDatabaseViewCounter += 1;
          if (currentReader.deleteDatabaseViewCounter >= currentReader.deleteDatabaseViewMax) {
            currentReader.elements.deleteDatabase.style.display = '';
          }
        }
      },

      deleteDatabase() {
        const currentReader = this;
        if (confirm('Are you sure you want to delete the database?')) {
          currentReader.lastSavedPosition = null;
          localStorage.removeItem(currentReader.settingsNames.lastPosition);
          localStorage.removeItem(currentReader.settingsNames.text);
          localStorage.removeItem(currentReader.settingsNames.settingsProfile);
          if (currentReader.database) {
            try {
              currentReader.database.close();
              const request = indexedDB.deleteDatabase(currentReader.databaseName);
              request.onupgradeneeded = function (event) {
                currentReader.locationReload();
              };
              request.onsuccess = function (event) {
                localStorage.removeItem(currentReader.settingsNames.texts);
                currentReader.locationReload();
              };
              request.onerror = function (event) {
                const message = `IndexedDB error: ${event.target.errorCode}`;
                alert(message);
                currentReader.locationReload();
              };
              request.onblocked = function (event) {
                const message = `IndexedDB blocked: ${event.target.errorCode}\nTry again later.`;
                alert(message);
                currentReader.locationReload();
              };
            }
            catch (err) {
              alert(err);
              currentReader.locationReload();
            }
          }
          else {
            currentReader.locationReload();
          }
        }
      },

      importAllSettingsProfiles() {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentTextName;
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to import new settings profiles?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        let element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            let f = event.target.files[0];
            if (f) {
              let r = new FileReader;
              r.addEventListener("load", (function (event) {
                try {
                  let jsonParsed = JSON.parse(event.target.result), newSettingsProfiles = [];
                  console.log(jsonParsed);
                  for (const jsonObject of jsonParsed[currentReader.settingsNames.settingsProfiles]) {
                    let name = jsonObject['name'], settings = JSON.stringify(jsonObject['settings']);
                    if (name && settings) {
                      newSettingsProfiles.push({
                        'name': name,
                        'settings': settings
                      });
                    }
                  }
                  if (newSettingsProfiles.length > 0) {
                    currentReader.pauseAnimation();
                    for (let newSettingsProfile of newSettingsProfiles) {
                      if (newSettingsProfile['name'] === currentReader.defaultSettingsProfileName) {
                        localStorage.setItem(currentReader.settingsNames.settingsProfile, newSettingsProfile['settings']);
                      }
                      else {
                        const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
                        if (!settingsProfiles.includes(newSettingsProfile['name'])) {
                          settingsProfiles.push(newSettingsProfile['name']);
                        }
                        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
                        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
                        objectStore.put({ name: newSettingsProfile['name'], settings: newSettingsProfile['settings'] });
                        localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
                      }
                    }
                  }
                  currentReader.locationReload();
                }
                catch (err) {
                  console.error(err);
                  alert(`Error importing settings profiles: ${err}`);
                }
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality not supported by your browser.")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAllTexts() {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentTextName;
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to import new settings profiles?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        let element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            let f = event.target.files[0];
            if (f) {
              let r = new FileReader;
              r.addEventListener("load", (function (event) {
                try {
                  let jsonParsed = JSON.parse(event.target.result), newTexts = [];
                  for (const jsonObject of jsonParsed[currentReader.settingsNames.texts]) {
                    let title = jsonObject['title'], content = jsonObject['content'];
                    if (title && content) {
                      newTexts.push({
                        'title': title,
                        'content': content
                      });
                    }
                  }
                  if (newTexts.length > 0) {
                    currentReader.pauseAnimation();
                    for (let newText of newTexts) {
                      if (newText['title'] === currentReader.defaultTextName) {
                        localStorage.setItem(currentReader.settingsNames.text, newText['content']);
                      }
                      else {
                        const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
                        if (!texts.includes(newText['title'])) {
                          texts.push(newText['title']);
                        }
                        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
                        const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
                        objectStore.put({ title: newText['title'], content: newText['content'] });
                        localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
                      }
                    }
                  }
                  currentReader.locationReload();
                }
                catch (err) {
                  console.error(err);
                  alert(`Error importing settings texts: ${err}`);
                }
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality not supported by your browser.")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAllSettingsProfilesAndTexts(afterSuccessCallback = null) {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentTextName;
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to import new settings profiles?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        let element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            let f = event.target.files[0];
            if (f) {
              let r = new FileReader;
              r.addEventListener("load", (function (event) {
                try {
                  let jsonParsed = JSON.parse(event.target.result), newSettingsProfiles = [], newTexts = [];
                  if (jsonParsed.hasOwnProperty(currentReader.settingsNames.settingsProfiles)) {
                    for (const jsonObject of jsonParsed[currentReader.settingsNames.settingsProfiles]) {
                      let name = jsonObject['name'], settings = JSON.stringify(jsonObject['settings']);
                      if (name && settings) {
                        newSettingsProfiles.push({
                          'name': name,
                          'settings': settings
                        });
                      }
                    }
                    if (newSettingsProfiles.length > 0) {
                      currentReader.pauseAnimation();
                      for (let newSettingsProfile of newSettingsProfiles) {
                        if (newSettingsProfile['name'] === currentReader.defaultSettingsProfileName) {
                          localStorage.setItem(currentReader.settingsNames.settingsProfile, newSettingsProfile['settings']);
                        }
                        else {
                          const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
                          if (!settingsProfiles.includes(newSettingsProfile['name'])) {
                            settingsProfiles.push(newSettingsProfile['name']);
                          }
                          const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
                          const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
                          objectStore.put({ name: newSettingsProfile['name'], settings: newSettingsProfile['settings'] });
                          localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
                        }
                      }
                    }
                  }
                  if (jsonParsed.hasOwnProperty(currentReader.settingsNames.texts)) {
                    for (const jsonObject of jsonParsed[currentReader.settingsNames.texts]) {
                      let title = jsonObject['title'], content = jsonObject['content'];
                      if (title && content) {
                        newTexts.push({
                          'title': title,
                          'content': content
                        });
                      }
                    }
                    if (newTexts.length > 0) {
                      currentReader.pauseAnimation();
                      for (let newText of newTexts) {
                        if (newText['title'] === currentReader.defaultTextName) {
                          localStorage.setItem(currentReader.settingsNames.text, newText['content']);
                        }
                        else {
                          const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
                          if (!texts.includes(newText['title'])) {
                            texts.push(newText['title']);
                          }
                          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
                          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
                          objectStore.put({ title: newText['title'], content: newText['content'] });
                          localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
                        }
                      }
                    }
                  }
                  if (afterSuccessCallback) {
                    afterSuccessCallback(jsonParsed);
                  }
                  currentReader.locationReload();
                }
                catch (err) {
                  console.error(err);
                  alert(`Error importing settings profiles and texts: ${err}`);
                }
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality not supported by your browser.")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAll() {
        const currentReader = this;
        currentReader.importAllSettingsProfilesAndTexts((jsonParsed) => {
          for (let [k, v] of Object.entries(jsonParsed)) {
            if (
              k !== currentReader.settingsNames.texts && k !== currentReader.settingsNames.text &&
              k !== currentReader.settingsNames.settingsProfiles && k !== currentReader.settingsNames.settingsProfile
            ) {
              localStorage.setItem(k, v);
            }
          }
        });
      },

      exportAllSettingsProfiles() {
        const currentReader = this;
        const defaultSettingsProfile = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfile) || '{}');
        const settingsProfilesKey = currentReader.settingsNames.settingsProfiles;
        let exportData = {};
        exportData[settingsProfilesKey] = [];
        exportData[settingsProfilesKey].push({
          name: currentReader.defaultSettingsProfileName,
          settings: defaultSettingsProfile
        });
        if (!currentReader.database) {
          currentReader.downloadExportFile(exportData);
          return;
        }
        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const profiles = request.result;
          profiles.forEach(profile => {
            exportData[settingsProfilesKey].push({
              name: profile.name,
              settings: JSON.parse(profile.settings)
            });
          });
          currentReader.downloadExportFile(exportData, 'settings_profiles');
        };
        request.onerror = () => {
          const message = `Error exporting settings profiles: ${request.error}`;
          console.error(request.error);
          alert(message);
        };
      },

      exportAllTexts() {
        const currentReader = this;
        const defaultText = localStorage.getItem(currentReader.settingsNames.text) || '';
        const textsKey = currentReader.settingsNames.texts;
        let exportData = {};
        exportData[textsKey] = [];
        exportData[textsKey].push({
          title: currentReader.defaultTextName,
          content: defaultText
        });
        if (!currentReader.database) {
          currentReader.downloadExportFile(exportData);
          return;
        }
        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const texts = request.result;
          texts.forEach(text => {
            exportData[textsKey].push({
              title: text.title,
              content: text.content
            });
          });
          currentReader.downloadExportFile(exportData, 'texts');
        };
        request.onerror = () => {
          const message = `Error exporting texts: ${request.error}`;
          console.error(request.error);
          alert(message);
        };
      },

      exportAllSettingsProfilesAndTexts(afterSuccessCallback = null) {
        const currentReader = this;
        const defaultSettingsProfile = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfile) || '{}');
        const defaultText = localStorage.getItem(currentReader.settingsNames.text) || '';
        const settingsProfilesKey = currentReader.settingsNames.settingsProfiles;
        const textsKey = currentReader.settingsNames.texts;
        let exportData = {};
        exportData[settingsProfilesKey] = [];
        exportData[settingsProfilesKey].push({
          name: currentReader.defaultSettingsProfileName,
          settings: defaultSettingsProfile
        });
        exportData[textsKey] = [];
        exportData[textsKey].push({
          title: currentReader.defaultTextName,
          content: defaultText
        });
        if (!currentReader.database) {
          currentReader.downloadExportFile(exportData);
          return;
        }
        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const profiles = request.result;
          profiles.forEach(profile => {
            exportData[settingsProfilesKey].push({
              name: profile.name,
              settings: JSON.parse(profile.settings)
            });
          });
          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readonly');
          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
          const nextRequest = objectStore.getAll();
          nextRequest.onsuccess = () => {
            const texts = nextRequest.result;
            texts.forEach(text => {
              exportData[textsKey].push({
                title: text.title,
                content: text.content
              });
            });
            let dataInfoTag = null;
            if (afterSuccessCallback) {
              dataInfoTag = afterSuccessCallback(exportData);
            }
            if (!dataInfoTag) {
              dataInfoTag = 'settings_profiles_and_texts';
            }
            currentReader.downloadExportFile(exportData, dataInfoTag);
          };
          nextRequest.onerror = () => {
            const message = `Error exporting settings profiles & [texts]: ${nextRequest.error}`;
            console.error(nextRequest.error);
            alert(message);
          };
        };
        request.onerror = () => {
          const message = `Error exporting [settings profiles] & texts: ${request.error}`;
          console.error(request.error);
          alert(message);
        };
      },

      exportAll() {
        const currentReader = this;
        currentReader.exportAllSettingsProfilesAndTexts((exportData) => {
          for (let localStorageSettingName of Object.values(currentReader.settingsNames)) {
            const localStorageSettingValue = localStorage.getItem(localStorageSettingName);
            if (!localStorageSettingValue) {
              continue;
            }
            if (
              localStorageSettingName !== currentReader.settingsNames.texts &&
              localStorageSettingName !== currentReader.settingsNames.text &&
              localStorageSettingName !== currentReader.settingsNames.settingsProfiles &&
              localStorageSettingName !== currentReader.settingsNames.settingsProfile
            ) {
              exportData[localStorageSettingName] = localStorageSettingValue;
            }
          }
          return 'all';
        });
      },

      getStrDateTime() {
        let dts = new Date((new Date().setHours(new Date().getHours() - (new Date().getTimezoneOffset() / 60)))).toISOString();
        dts = dts.replace('T', ' ').replaceAll('-', '.').slice(0, 19);
        return dts;
      },

      downloadExportFile(data, dataInfoTag) {
        const jsonString = JSON.stringify(data, null, 2);
        const blob = new Blob([jsonString], { type: 'application/json' });
        const url = window.URL.createObjectURL(blob);
        const link = document.createElement('a');
        link.href = url;
        let datetimeString = this.getStrDateTime().replaceAll(':', '.').replaceAll(' ', '_');
        link.download = `tae_${dataInfoTag}_${datetimeString}.json`;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
      },

      locationReload() {
        setTimeout(function () {
          location.reload();
        }, 1);
      },

      adjustSpeechRate(value) {
        this.speechRate = parseFloat(value);
        this.elements.speechRateSlider.value = value;
        this.elements.speechRateDisplay.value = value;
        localStorage.setItem(this.settingsNames.voiceSpeechRate, this.speechRate);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      loadVoices() {
        const updateVoices = () => {
          this.voices = this.speechSynthesis.getVoices();
          this.elements.voiceSelect.innerHTML = this.voices.map((voice, index) =>
            `<option value="${index}">${voice.name} (${voice.lang})</option>`
          ).join('');
        };
        this.speechSynthesis.onvoiceschanged = updateVoices;
        updateVoices();
      },

      updateVoice() {
        localStorage.setItem(this.settingsNames.voice, this.elements.voiceSelect.value);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      toggleSpeechButton() {
        this.elements.textToSpeechContainer.style.display = this.elements.showButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.voiceButton, this.elements.showButtonToggle.checked);
      },

      toggleSpeech() {
        if (!this.speechSynthesis) return;

        const currentReader = this;

        const startUpdate = function () {
          currentReader.isSpeaking = true;
          currentReader.elements.speakButton.textContent = 'Stop';
          currentReader.elements.playPauseButton.disabled = true;
          currentReader.elements.stopButton.disabled = true;
          currentReader.elements.rewindButton.disabled = true;
          currentReader.elements.fastForwardButton.disabled = true;
          currentReader.elements.refreshText.disabled = true;
          currentReader.elements.refreshColors.disabled = true;
          currentReader.elements.copyText.disabled = true;
          currentReader.elements.marqueeControlsContainer.style.display = 'none';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = 'none';
          currentReader.elements.tabContent.style.display = 'none';
          currentReader.elements.loopToggle.style.display = 'none';
          currentReader.animationStartTime = Date.now();
          this.isSpeaking = true;
        };

        const stopUpdate = function () {
          currentReader.speechSynthesis.cancel();
          currentReader.isSpeaking = false;
          currentReader.elements.speakButton.textContent = 'Speak';
          currentReader.elements.playPauseButton.disabled = false;
          currentReader.elements.stopButton.disabled = false;
          currentReader.elements.rewindButton.disabled = false;
          currentReader.elements.fastForwardButton.disabled = false;
          currentReader.elements.refreshText.disabled = false;
          currentReader.elements.refreshColors.disabled = false;
          currentReader.elements.copyText.disabled = false;
          currentReader.elements.marqueeControlsContainer.style.display = '';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = '';
          currentReader.elements.tabContent.style.display = '';
          currentReader.elements.loopToggle.style.display = '';
          this.isSpeaking = false;
        };

        if (this.isSpeaking) {
          stopUpdate();
          return;
        }

        currentReader.startAnimation(false, false);
        const text = this.previousText;
        if (!text) {
          return;
        }

        let startIndex = 0;
        this.previousPosition = this.currentPosition;
        if (this.currentPosition !== null) {
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;
          const progress = 1 - (this.currentPosition - endPos) / (startPos - endPos);
          startIndex = Math.floor(progress * text.length);
          startIndex = Math.min(startIndex, text.length - 1);
          while (startIndex > 0) {
            if (text[startIndex] != ' ') {
              startIndex--;
            }
            else {
              break;
            }
          }
        }

        const textToSpeak = text.slice(startIndex);
        if (!textToSpeak) {
          return;
        }
        const wordCount = textToSpeak.split(/\s+/).filter(word => word.length > 0).length;
        const utterance = new SpeechSynthesisUtterance(textToSpeak);

        const selectedVoiceIndex = parseInt(this.elements.voiceSelect.value);
        if (this.voices[selectedVoiceIndex]) {
          utterance.voice = this.voices[selectedVoiceIndex];
        }
        utterance.rate = this.speechRate / 100;

        utterance.onboundary = (event) => {
          if (event.name === 'word') {
            const containerWidth = currentReader.cachedContainerWidth;
            const textWidth = currentReader.cachedTextWidth;
            const startPos = containerWidth;
            const endPos = -textWidth;
            const previousPosition = currentReader.currentPosition;
            const progress = 1 - (currentReader.currentPosition - endPos) / (startPos - endPos);
            const charIndex = startIndex + event.charIndex;
            const nextCharIndex = Math.max(0, charIndex + (event.charLength * 2.5 * (0.5 - progress)));
            currentReader.updateTextPositionForSpeech(charIndex, nextCharIndex, text.length);
            const newPosition = currentReader.currentPosition;
            if (this.previousPosition > newPosition) {
              const newLastUpdateTime = Date.now();
              const actualStepDelay = Math.floor((newLastUpdateTime - currentReader.animationStartTime) / Math.max(1e-9, this.previousPosition - newPosition) * 10) / 10;
              const secondsRemaining = Math.floor(actualStepDelay * (newPosition - endPos) / 1000);
              currentReader.elements.progressDisplay.innerHTML = currentReader.formatTime(secondsRemaining);
              const totalSeconds = actualStepDelay * (startPos - endPos) / 1000;
              const wpm = totalSeconds ? Math.max(1, Math.floor(wordCount / (totalSeconds / 60))) : wordCount;
              currentReader.elements.progressDisplay.innerHTML += `<br>WPM: ${wpm}`;
              const progress100 = Math.floor(100 * progress);
              currentReader.elements.progressDisplay.innerHTML += `<br>Progress: ${progress100}%`;
            }
          }
        };

        utterance.onend = () => {
          const containerWidth = currentReader.cachedContainerWidth;
          const textWidth = currentReader.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;
          const newPosition = endPos;
          if (this.previousPosition > newPosition) {
            const progress = 1 - (newPosition - endPos) / (startPos - endPos);
            const newLastUpdateTime = Date.now();
            const actualStepDelay = Math.floor((newLastUpdateTime - currentReader.animationStartTime) / Math.max(1e-9, this.previousPosition - newPosition) * 10) / 10;
            const secondsRemaining = Math.floor(actualStepDelay * (newPosition - endPos) / 1000);
            currentReader.elements.progressDisplay.innerHTML = currentReader.formatTime(secondsRemaining);
            const totalSeconds = actualStepDelay * (startPos - endPos) / 1000;
            const wpm = totalSeconds ? Math.max(1, Math.floor(wordCount / (totalSeconds / 60))) : wordCount;
            currentReader.elements.progressDisplay.innerHTML += `<br>WPM: ${wpm}`;
            const progress100 = Math.floor(100 * progress);
            currentReader.elements.progressDisplay.innerHTML += `<br>Progress: ${progress100}%`;
          }
          currentReader.currentPosition = startPos;
          currentReader.elements.marqueeDisplay.style.left = `${currentReader.currentPosition}px`;
          currentReader.lastSavedPosition = currentReader.currentPosition;
          currentReader.updateProgressBar();
          stopUpdate();
          if (currentReader.elements.loopToggle.classList.contains('active')) {
            currentReader.currentPosition = null;
            setTimeout(() => {
              return currentReader.toggleSpeech();
            }, 50);
          }
        };

        startUpdate();
        this.speechSynthesis.speak(utterance);
      },

      updateTextPositionForSpeech(charIndex, nextCharIndex, totalLength) {
        if (!this.isSpeaking) return;

        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;

        const progress = charIndex / totalLength;
        const nextProgress = nextCharIndex / totalLength;
        const startPos = containerWidth;
        const endPos = -textWidth;

        this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, startPos - (startPos - endPos) * progress));
        this.lastSavedPosition = this.currentPosition;
        const nextPosition = Math.max(-textWidth, Math.min(containerWidth, startPos - (startPos - endPos) * nextProgress));

        this.elements.marqueeDisplay.style.left = `${nextPosition}px`;
        this.updateProgressBar();
      }

    };

    document.addEventListener('DOMContentLoaded', () => {
      const script = document.createElement('script');
      script.src = 'sentences.js?version=1';
      document.head.appendChild(script);
      MarqueeReader.initialize();
    });
  </script>
</body>
</html>