<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trial and Error Reading</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <style>
    :root {
      --background-color: #eeeeee;
      --text-color: #333;
      --container-background: #efefef;
      --border-color: rgb(90, 90, 90);
      --primary-button-background: rgb(25, 135, 84);
      --primary-button-hover: rgb(21, 115, 71);
      --pause-button-background: rgb(218, 104, 11);
      --pause-button-hover: rgb(194, 93, 10);
      --stop-button-background: rgb(187, 45, 59);
      --stop-button-hover: rgb(180, 25, 46);
      --theme-button-background: rgb(11, 166, 197);
      --theme-button-hover: rgb(9, 130, 153);
      --action-button-background: rgb(200, 200, 200);
      --action-button-text: rgb(0, 0, 0);
      --action-button-hover: rgb(210, 210, 210);
      --action-button-disabled-background: rgb(230, 230, 230);
      --action-button-disabled-text: rgb(173, 173, 173);
      --load-button-background: rgb(108, 117, 125);
      --load-button-hover: rgb(92, 99, 106);
      --save-button-background: rgb(13, 110, 253);
      --save-button-hover: rgb(11, 94, 215);
      --reset-button-background: rgb(33, 37, 41);
      --reset-button-hover: rgb(66, 70, 73);
    }

    body.dark {
      --background-color: #1a1a1a;
      --text-color: #e0e0e0;
      --container-background: #2a2a2a;
      --border-color: #e0e0e0;
      --action-button-background: rgb(90, 90, 90);
      --action-button-text: rgb(255, 255, 255);
      --action-button-hover: rgb(80, 80, 80);
      --action-button-disabled-background: rgb(90, 90, 90);
      --action-button-disabled-text: rgb(70, 70, 70);
    }

    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      background-color: var(--background-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    span {
      unicode-bidi: embed;
    }

    .container.normal-size {
      max-width: 768px;
      margin: 0 auto;
    }

    .container.max-size {
      max-width: 100%;
      margin: 0 auto;
    }

    #marquee-controls-container,
    #marquee-container,
    #controls-container,
    #additional-settings-container {
      text-align: center;
    }

    label {
      display: block;
    }

    #text-input {
      width: 100%;
      min-height: 300px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: var(--container-background);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    #color-input {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: var(--container-background);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    #marquee-container {
      width: 100%;
      height: 60px;
      overflow: hidden;
      position: relative;
      border: 2px solid var(--border-color);
      padding-left: 2px;
      padding-right: 2px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      direction: ltr;
      background-color: var(--container-background);
    }

    #marquee-display {
      position: absolute;
      white-space: nowrap;
      line-height: 60px;
      text-align: right;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin: 2px;
      background-color: var(--primary-button-background);
      color: white;
    }

    button:hover {
      background-color: var(--primary-button-hover);
    }

    #color-details {
      font-size: 22px;
    }

    #play-pause-button, #stop-button {
      min-width: 100px;
    }

    #play-pause-button.pause {
      background-color: var(--pause-button-background);
    }

    #play-pause-button.pause:hover {
      background-color: var(--pause-button-hover);
    }

    #stop-button {
      background-color: var(--stop-button-background);
    }

    #stop-button:hover {
      background-color: var(--stop-button-hover);
    }

    #theme-toggle,
    #marquee-theme-toggle,
    #full-size-toggle {
      background-color: var(--theme-button-background);
    }

    #theme-toggle:hover,
    #marquee-theme-toggle:hover,
    #full-size-toggle:hover {
      background-color: var(--theme-button-hover);
    }

    .action-button {
      background-color: var(--action-button-background);
      color: var(--action-button-text);
    }

    .action-button:hover {
      background-color: var(--action-button-hover);
    }

    .action-button:disabled {
      background-color: var(--action-button-disabled-background);
      color: var(--action-button-disabled-text);
    }

    #dump-colors,
    #clear-text,
    #load-sentence,
    #load-wiki,
    #load-metaphorpsum,
    #load-file {
      background-color: var(--load-button-background);
    }

    #dump-colors:hover,
    #clear-text:hover,
    #load-sentence:hover,
    #load-wiki:hover,
    #load-metaphorpsum:hover,
    #load-file:hover {
      background-color: var(--load-button-hover);
    }

    #save-settings {
      background-color: var(--save-button-background);
    }

    #save-settings:hover {
      background-color: var(--save-button-hover);
    }

    #reset-settings, #delete-all-texts {
      background-color: var(--reset-button-background);
    }

    #reset-settings:hover, #delete-all-texts:hover {
      background-color: var(--reset-button-hover);
    }

    .marquee-span {
      box-sizing: border-box;
    }

    body.light.marquee-theme-1 .marquee-span {
      border: 1px dashed white;
    }

    body.dark.marquee-theme-1 .marquee-span {
      border: 1px dashed black;
    }

    body.light.marquee-theme-2 .marquee-span,
    body.light.marquee-theme-3 .marquee-span,
    body.light.marquee-theme-4 .marquee-span {
      border: 1px solid black;
    }

    body.dark.marquee-theme-2 .marquee-span,
    body.dark.marquee-theme-3 .marquee-span,
    body.dark.marquee-theme-4 .marquee-span {
      border: 1px solid white;
    }

    body.light.marquee-theme-3 .marquee-word-span,
    body.dark.marquee-theme-3 .marquee-word-span {
      border: 1px solid var(--border-color);
    }

    body.light.marquee-theme-4 .marquee-word-span {
      border: 2px solid black;
    }

    body.dark.marquee-theme-4 .marquee-word-span {
      border: 2px solid white;
    }

    #marquee-display {
      letter-spacing: 1px;
      word-spacing: 1px;
    }

    .marquee-theme-2 #marquee-display {
      letter-spacing: 2px;
    }

    .marquee-theme-3 #marquee-display {
      letter-spacing: 3px;
      word-spacing: 5px;
    }

    .marquee-theme-4 #marquee-display {
      letter-spacing: 3px;
      word-spacing: 15px;
    }

    #speed-display,
    #font-size-display {
      text-align: center;
    }

    input[type="text"],
    input[type="number"],
    select {
      padding: 8px 4px;
      text-align: center;
    }

    .clickable {
      cursor: pointer;
    }

    #letter-shuffle-select,
    #letter-elimination-select,
    #word-shuffle-select {
      min-width: 150px;
    }

    .select-label {
      min-width: 150px;
      display: inline-block;
    }

    input[type="range"] {
      width: 225px;
      padding: 0 4px;
    }

    input[type="number"] {
      width: 70px;
    }

    input[type="checkbox"] {
      transform: scale(1.4);
      margin: 7px 4px;
    }

    kbd {
      border: 1px solid;
      border-radius: 3px;
      padding: 1px 4px;
      font-size: 12px;
      font-family: monospace;
    }

    body.light kbd {
      background-color: rgb(200, 200, 200);
      border-color: rgb(90, 90, 90);
      color: #333;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    body.dark kbd {
      background-color: rgb(60, 60, 60);
      border-color: rgb(200, 200, 200);
      color: #e0e0e0;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    a {
      text-decoration: none;
      font-weight: bold;
    }

    body.light a {
      color: #aaa;
    }

    body.light a:hover {
      color: #555;
    }

    body.dark a {
      color: #555;
    }

    body.dark a:hover {
      color: #aaa;
    }

    .mt-10 {
      margin-top: 10px;
    }

    .mt-20 {
      margin-top: 20px;
    }

    .mb-20 {
      margin-bottom: 20px;
    }

    #tab-navigation {
      display: flex;
      justify-content: space-around;
    }

    .tab-button {
      flex: 1;
      padding: 10px;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    body.light .tab-button {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
    }

    body.light .tab-button.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark .tab-button {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
    }

    body.dark .tab-button.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    .tab-content {
      display: none;
      text-align: center;
    }

    .tab-content.active {
      display: block;
      border-radius: 10px;
      padding: 2px;
    }

    body.light .tab-content {
      border: 2px solid rgb(230, 230, 230);
    }

    body.light .tab-content.active {
      border: 2px solid rgb(200, 200, 200);
    }

    body.dark .tab-content {
      border: 2px solid rgb(90, 90, 90);
    }

    body.dark .tab-content.active {
      border: 2px solid rgb(90, 90, 90);
    }

    body.light #loop-toggle {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
      min-width: 70px;
    }

    body.light #loop-toggle.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark #loop-toggle {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
      min-width: 70px;
    }

    body.dark #loop-toggle.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    #progress-bar-container {
        width: 100%;
        height: 20px;
        background-color: var(--container-background);
        border: 1px solid var(--border-color);
        position: relative;
        cursor: pointer;
        margin-bottom: 5px;
    }

    #progress-bar {
        height: 100%;
        background-color: var(--primary-button-background);
        width: 0%;
        transition: width 0.1s linear;
    }

    body.dark #progress-bar {
        background-color: var(--primary-button-hover);
    }

    #info-tab ul {
      list-style-type: disc;
      padding-left: 20px;
      text-align: left;
      max-width: 600px;
      margin: 0 auto;
    }
    #info-tab li {
      margin-bottom: 10px;
    }

    #text-select {
      min-width: 20%;
      max-width: 50%;
      padding: 8px;
      text-align: center;
    }

    @media (max-width: 600px) {
      button {
        width: 100%;
        margin: 10px 0;
      }
      kbd {
        display: none;
      }
      #text-select {
        min-width: 100%;
        max-width: 100%;
      }
      input[type="range"] {
        width: 30%;
        margin-right: 30%;
      }
      input[type="number"] {
        width: 30%;
      }
      #tab-navigation {
        flex-direction: column;
      }
      .tab-button {
        margin-bottom: 5px;
      }
    }
  </style>
</head>
<body class="">
  <div id="main-container" class="container normal-size">
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>

    <div id="marquee-container" class="mt-20">
      <span id="marquee-display"></span>
    </div>

    <div id="controls-container" class="mt-20">
      <span>
        <button id="rewind-button" class="action-button" disabled>&lt;&lt; <kbd>←</kbd></button>
        <button id="play-pause-button">Start <kbd>Space</kbd></button>
        <button id="stop-button">Stop <kbd>S</kbd></button>
        <button id="fast-forward-button" class="action-button" disabled>&gt;&gt; <kbd>→</kbd></button>
      </span>
      <div>
        <button id="loop-toggle">Loop <kbd>L</kbd></button>
        <div id="progress-display" class="mt-20" style="display: none;"></div>
        <div id="color-details" class="mt-20" style="display: none;"></div>
      </div>
    </div>

    <div id="tab-navigation" class="mt-20" role="tablist">
      <button class="tab-button active" data-tab="manipulations-tab" role="tab" aria-selected="true">Manipulations</button>
      <button class="tab-button" data-tab="texts-tab" role="tab" aria-selected="false">Texts</button>
      <button class="tab-button" data-tab="settings-tab" role="tab" aria-selected="false">Settings</button>
      <button class="tab-button" data-tab="info-tab" role="tab" aria-selected="false">Information</button>
    </div>

    <div id="tab-content">
      <div id="manipulations-tab" class="tab-content active">
        <div id="marquee-controls-container" class="mt-20">
          <button id="refresh-text" class="action-button" disabled>↻ Text ↻</button>
          <button id="refresh-colors" class="action-button" disabled>↻ Colors ↻</button>
          <button id="copy-text" class="action-button" disabled>⏏ Copy text ⏏</button>
        </div>
        <div class="mt-20">
          <div>Text size</div>
          <input type="range" id="font-size-slider" min="8" max="50" value="50">
          <input type="number" id="font-size-display" min="8" max="50" value="50">
        </div>
        <div class="mt-20">
          <div>Speed <kbd>+</kbd><kbd>-</kbd></div>
          <input type="number" id="speed-value" min="-1000" max="1000" value="10" style="display: none;">
          <input type="range" id="speed-slider" min="1" max="250" value="100">
          <input type="number" id="speed-display" min="-1000" max="1000" value="100">
        </div>
        <div class="mt-20">
          <span class="select-label">Shuffling letters:</span>
          <select id="letter-shuffle-select">
            <option value="no">-</option>
            <option value="easy">Easy</option>
            <option value="medium">Medium</option>
            <option value="medium_plus">Medium+</option>
            <option value="hard">Hard</option>
            <option value="very-hard">Very Hard</option>
          </select>
        </div>
        <div class="mt-20">
          <span class="select-label">Eliminating letters:</span>
          <select id="letter-elimination-select">
            <option value="no">-</option>
            <option value="20%_vowels">20% vowels</option>
            <option value="40%_vowels">40% vowels</option>
            <option value="60%_vowels">60% vowels</option>
            <option value="80%_vowels">80% vowels</option>
            <option value="100%_vowels">Almost all vowels</option>
            <option value="10%_random">10% smart-random</option>
            <option value="20%_random">20% smart-random</option>
            <option value="30%_random">30% smart-random</option>
            <option value="40%_random">40% smart-random</option>
          </select>
        </div>
        <div class="mt-20">
          <span class="select-label">Shuffling words:</span>
          <select id="word-shuffle-select">
            <option value="no">-</option>
            <option value="2_words">Two words</option>
            <option value="3_words">Three words</option>
            <option value="4_words">Four words</option>
            <option value="5_words">Five words</option>
          </select>
        </div>
        <div class="mt-20">
          <label><input type="checkbox" id="color-encoder-toggle" checked> Color encoder task <kbd>C</kbd></label>
          <div id="color-encoder-options">
            <span>Number of letters:</span>
            <input type="number" id="color-letter-count" min="0" max="32" value="1">
          </div>
          <button id="dump-colors">Dump colors</button>
          <textarea id="color-input" placeholder="&lt;letter&gt; &lt;color&gt;&#13;&#10;a rgb(0, 0, 0)&#13;&#10;b red&#13;&#10;..."></textarea>
        </div>
      </div>
      <div id="texts-tab" class="tab-content">
        <div class="mt-20">
          <select id="text-select">
          </select>
          <button id="new-text-button">New Text</button>
          <button id="delete-text-button">Delete Text</button>
        </div>
        <div class="mt-20">
          <label for="text-input">Text</label>
          <textarea id="text-input" placeholder="Enter text here"></textarea>
        </div>
        <div class="mt-20">
          <button id="load-sentence">Load [one of the 22831 sentences]</button>
          <button id="load-wiki">Load [random wiki summary]</button>
          <button id="load-file">Load [from file]</button>
          <button id="load-metaphorpsum" style="display: none;">Load [random sentence from metaphorpsum]</button>
          <label><input type="checkbox" id="append-text-toggle" checked> Append text after loading/fetching</label>
        </div>
        <div>
          <button id="clear-text">Clear</button>
        </div>
      </div>
      <div id="settings-tab" class="tab-content">
        <div>
          <button id="marquee-theme-toggle">Toggle Marquee Text Block Theme</button>
          <button id="theme-toggle">Toggle Theme</button>
          <button id="full-size-toggle">Toggle Full Size</button>
        </div>
        <label class="mt-20"><input type="checkbox" id="show-color-info" checked> Show letters-colors info <kbd>ESC</kbd></label>
        <div class="mt-20">
          <button id="reset-settings">Reset settings</button>
          <button id="delete-all-texts">Delete all texts</button>
        </div>
      </div>
      <div id="info-tab" class="tab-content">
        <div class="mt-20">
            <p>Here are some tips and recommendations to help you effectively use this website:</p>
            <ul>
                <li><strong>Resist checking answers too soon:</strong> Avoid looking up the solution until you're certain you don't know a word or have spent enough time trying to figure it out.</li>
                <li><strong>Take breaks:</strong> Regular breaks can improve your problem-solving efficiency and keep your mind fresh.</li>
                <li><strong>Be patient with progress:</strong> Improvements may take months and depends on how often you train, as well as your diet and sleep quality.</li>
                <li><strong>Short sessions are key:</strong> Training twice a day in short bursts is more effective than one long session daily.</li>
                <li><strong>Quality over quantity:</strong> Fully solving a few sentences per day is better than partially solving many.</li>
                <li><strong>Challenge yourself:</strong> Solving without changing the text combination on the go (via "↻ Text ↻" button) is harder and more beneficial than adjusting it mid-session.</li>
                <li><strong>Increase difficulty:</strong> Continuously ramp up the exercise difficulty to maintain progress, rather than staying at an easy level for too long.</li>
            </ul>
        </div>
        <div class="mb-20"></div>
      </div>
    </div>

    <div id="additional-settings-container">
      <div class="mt-20">
        <button id="save-settings">Save current text and settings</button>
      </div>
      <div class="mt-20">
        <a href="https://github.com/Quwarm/Trial-and-Error-Reading" target="_blank">GitHub</a>
      </div>
    </div>
  </div>

  <div id="text-helper" style="display: none;"></div>

  <script>
    const MarqueeReader = {
      animationTimer: null,
      currentPosition: null,
      animationStartTime: null,
      lastUpdateTime: null,
      colorMap: new Map(),
      colorList: [],
      previousText: null,
      previousLetterShuffle: '',
      previousWordShuffle: '',
      previousLetterElimination: '',
      previousColorInput: '',
      previousPosition: null,
      wasColorTaskEnabled: null,
      isLoopEnabled: false,
      wordCount: 0,
      lastSavedPosition: null,

      elements: {},

      databaseName: 'TrialAndErrorReadingDB',
      database: null,
      defaultTextName: 'Default',
      currentTextName: 'Default',
      isModified: false,

      vowelPattern: null,
      letterPattern: null,
      punctuationPattern: null,

      cachedContainerWidth: null,
      cachedTextWidth: null,

      settingsNames: {
        currentTextName: 'sle_current_text_name',
        text: 'sle_text',
        texts: 'sle_texts',
        colorTask: 'sle_color_task',
        colorTaskLetters: 'sle_color_task_letters',
        colorTaskColors: 'sle_color_task_colors',
        showTable: 'sle_show_table',
        speed: 'sle_speed',
        appendText: 'sle_append_text',
        shufflingLetters: 'sle_shuffling_letters',
        shufflingWords: 'sle_shuffling_words',
        eliminatingLetters: 'sle_eliminating_letters',
        loop: 'sle_loop',
        textSize: 'sle_text_size',
        theme: 'sle_theme',
        marqueeTheme: 'sle_marquee_theme',
        lastPosition: 'sle_last_position',
        appSize: 'sle_app_size',
        activeTab: 'sle_active_tab'
      },

      themes: [
        'dark',
        'light'
      ],

      marqueeThemes: [
        'marquee-theme-1',
        'marquee-theme-2',
        'marquee-theme-3',
        'marquee-theme-4'
      ],

      initialize() {
        const currentReader = this;
        console.info(currentReader);
        currentReader.cacheElements();
        currentReader.loadDb(function () {
          try {
            currentReader.setupPatterns();
            currentReader.bindEvents();
            currentReader.loadPreferences();
          }
          catch (err) {
            console.error(err);
            currentReader.elements.mainContainer.innerHTML = `Not supported:<br>${err}`;
          }
        });
      },

      cacheElements() {
        this.elements.body = document.body;
        this.elements.mainContainer = document.getElementById('main-container');
        this.elements.textInput = document.getElementById('text-input');
        this.elements.speedValue = document.getElementById('speed-value');
        this.elements.speedSlider = document.getElementById('speed-slider');
        this.elements.speedDisplay = document.getElementById('speed-display');
        this.elements.progressDisplay = document.getElementById('progress-display');
        this.elements.colorDetails = document.getElementById('color-details');
        this.elements.appendTextToggle = document.getElementById('append-text-toggle');
        this.elements.letterShuffleSelect = document.getElementById('letter-shuffle-select');
        this.elements.wordShuffleSelect = document.getElementById('word-shuffle-select');
        this.elements.letterEliminationSelect = document.getElementById('letter-elimination-select');
        this.elements.marqueeDisplay = document.getElementById('marquee-display');
        this.elements.marqueeControlsContainer = document.getElementById('marquee-controls-container');
        this.elements.additionalSettingsContainer = document.getElementById('additional-settings-container');
        this.elements.marqueeContainer = document.getElementById('marquee-container');
        this.elements.playPauseButton = document.getElementById('play-pause-button');
        this.elements.stopButton = document.getElementById('stop-button');
        this.elements.themeToggle = document.getElementById('theme-toggle');
        this.elements.fullSizeToggle = document.getElementById('full-size-toggle');
        this.elements.saveSettings = document.getElementById('save-settings');
        this.elements.resetSettings = document.getElementById('reset-settings');
        this.elements.deleteAllTexts = document.getElementById('delete-all-texts');
        this.elements.clearText = document.getElementById('clear-text');
        this.elements.loadSentence = document.getElementById('load-sentence');
        this.elements.loadWiki = document.getElementById('load-wiki');
        this.elements.loadMetaphorpsum = document.getElementById('load-metaphorpsum');
        this.elements.loadFile = document.getElementById('load-file');
        this.elements.colorEncoderToggle = document.getElementById('color-encoder-toggle');
        this.elements.colorEncoderOptions = document.getElementById('color-encoder-options');
        this.elements.colorLetterCount = document.getElementById('color-letter-count');
        this.elements.rewindButton = document.getElementById('rewind-button');
        this.elements.fastForwardButton = document.getElementById('fast-forward-button');
        this.elements.colorInput = document.getElementById('color-input');
        this.elements.dumpColors = document.getElementById('dump-colors');
        this.elements.showColorInfo = document.getElementById('show-color-info');
        this.elements.refreshText = document.getElementById('refresh-text');
        this.elements.refreshColors = document.getElementById('refresh-colors');
        this.elements.copyText = document.getElementById('copy-text');
        this.elements.textHelper = document.getElementById('text-helper');
        this.elements.marqueeThemeToggle = document.getElementById('marquee-theme-toggle');
        this.elements.loopToggle = document.getElementById('loop-toggle');
        this.elements.fontSizeSlider = document.getElementById('font-size-slider');
        this.elements.fontSizeDisplay = document.getElementById('font-size-display');
        this.elements.tabButtons = document.querySelectorAll('.tab-button');
        this.elements.tabNavigation = document.getElementById('tab-navigation');
        this.elements.tabContent = document.getElementById('tab-content');
        this.elements.tabContents = document.querySelectorAll('.tab-content');
        this.elements.progressBarContainer = document.getElementById('progress-bar-container');
        this.elements.progressBar = document.getElementById('progress-bar');
        this.elements.textSelect = document.getElementById('text-select');
        this.elements.newTextButton = document.getElementById('new-text-button');
        this.elements.deleteTextButton = document.getElementById('delete-text-button');
        this.cachedContainerWidth = null;
        this.cachedTextWidth = null;
      },

      loadDb(callback) {
        const currentReader = this;
        const hideTextSelectElements = function () {
          currentReader.elements.textSelect.style.display = 'none';
          currentReader.elements.newTextButton.style.display = 'none';
          currentReader.elements.deleteTextButton.style.display = 'none';
        }
        currentReader.database = null;
        try {
          const request = indexedDB.open(this.databaseName, 1);
          request.onupgradeneeded = function (event) {
            currentReader.database = event.target.result;
            currentReader.database.createObjectStore(currentReader.settingsNames.texts, { keyPath: "title" });
          };
          request.onsuccess = function (event) {
            currentReader.database = event.target.result;
            callback();
          };
          request.onerror = function (event) {
            currentReader.database = null;
            const message = `IndexedDB error: ${event.target.errorCode}`;
            console.error(message);
            hideTextSelectElements();
            alert(message);
            callback();
          };
          request.onblocked = function(event) {
            currentReader.database = null;
            const message = `IndexedDB blocked: ${event.target.errorCode}`;
            console.error(message);
            hideTextSelectElements();
            alert(message);
            callback();
          };
        } catch (err) {
          currentReader.database = null;
          console.error(err);
          hideTextSelectElements();
          callback();
        }
      },

      updateCachedSizes() {
        this.cachedContainerWidth = Math.ceil(this.elements.marqueeContainer.getBoundingClientRect().width);
        this.cachedTextWidth = Math.ceil(this.elements.marqueeDisplay.getBoundingClientRect().width);
      },

      setupPatterns() {
        this.vowelPattern = new RegExp('[\u0041\u0045\u0049\u004f\u0055\u0410\u0415\u0401\u0418\u041e\u0423\u042b\u042d\u042e\u042f\u0391\u0395\u0397\u0399\u039f\u03a5\u03a9\u0101\u012b\u016b\u0113\u014d]', 'ui');
        this.letterPattern = new RegExp(/\p{L}/, 'ui');
        this.punctuationPattern = new RegExp(/\p{S}|\p{Ps}|\p{Pe}|\p{Pi}|\p{Pf}|[!"#%&*,./:;?@^]|^-$/, 'ui');
        this.vowelPatternG = new RegExp(this.vowelPattern, 'uig');
        this.letterPatternG = new RegExp(this.letterPattern, 'uig');
      },

      bindEvents() {
        this.elements.playPauseButton.addEventListener('click', () => this.togglePlayback());
        this.elements.stopButton.addEventListener('click', () => this.stopPlayback());
        this.elements.themeToggle.addEventListener('click', () => this.switchTheme());
        this.elements.marqueeThemeToggle.addEventListener('click', () => this.switchMarqueeTheme());
        this.elements.fullSizeToggle.addEventListener('click', () => this.toggleFullSize());
        this.elements.saveSettings.addEventListener('click', () => this.savePreferences());
        this.elements.resetSettings.addEventListener('click', () => this.resetPreferences());
        this.elements.deleteAllTexts.addEventListener('click', () => this.deleteAllTexts());
        this.elements.clearText.addEventListener('click', () => this.clearInput());
        this.elements.loadSentence.addEventListener('click', () => this.fetchSentence());
        this.elements.loadWiki.addEventListener('click', () => this.fetchWikipedia());
        this.elements.loadMetaphorpsum.addEventListener('click', () => this.fetchMetaphorpsum());
        this.elements.loadFile.addEventListener('click', () => this.loadFromFile());
        this.elements.colorEncoderToggle.addEventListener('click', () => this.toggleColorEncoder());
        this.elements.dumpColors.addEventListener('click', () => this.dumpColorMap());
        this.elements.showColorInfo.addEventListener('click', () => this.toggleColorDetails());
        this.elements.refreshText.addEventListener('click', () => this.refreshMarqueeText());
        this.elements.refreshColors.addEventListener('click', () => this.refreshMarqueeColors());
        this.elements.copyText.addEventListener('click', () => this.copyMarqueeText());
        this.elements.loopToggle.addEventListener('click', () => this.toggleLoop());
        this.elements.rewindButton.addEventListener('click', () => this.rewind());
        this.elements.fastForwardButton.addEventListener('click', () => this.fastForward());
        this.elements.fontSizeSlider.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeSlider.value));
        this.elements.fontSizeDisplay.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeDisplay.value));
        this.elements.speedSlider.addEventListener('input', () => this.adjustSpeed(this.elements.speedSlider.value));
        this.elements.speedDisplay.addEventListener('input', () => this.adjustSpeed(this.elements.speedDisplay.value));
        this.elements.speedValue.addEventListener('input', () => this.syncSpeed(this.elements.speedValue.value));
        this.elements.tabButtons.forEach(button => button.addEventListener('click', () => this.switchTab(button)));
        this.elements.progressBarContainer.addEventListener('click', (e) => this.handleProgressBarClick(e));
        this.elements.textSelect.addEventListener('change', () => this.switchText());
        this.elements.newTextButton.addEventListener('click', () => this.createNewText());
        this.elements.deleteTextButton.addEventListener('click', () => this.deleteCurrentText());
        this.elements.textInput.addEventListener('input', () => { this.isModified = true; });
        window.addEventListener('resize', () => {
          if (this.currentPosition !== null) {
            this.updateCachedSizes();
            this.updateProgressBar();
          }
        });
        document.addEventListener('keydown', e => this.handleKeyPress(e));
        this.restoreActiveTab();
      },

      loadPreferences() {
        this.elements.textInput.value = '';
        this.elements.speedValue.value = localStorage.getItem(this.settingsNames.speed) || '10';
        this.syncSpeed(this.elements.speedValue.value);
        this.elements.body.classList.add(localStorage.getItem(this.settingsNames.theme) || this.themes[0]);
        const marqueeTheme = localStorage.getItem(this.settingsNames.marqueeTheme) || this.marqueeThemes[0];
        this.elements.body.classList.add(marqueeTheme);
        this.elements.marqueeThemeToggle.innerHTML += ` [${marqueeTheme.slice(-1)}]`;
        this.elements.appendTextToggle.checked = localStorage.getItem(this.settingsNames.appendText) !== 'false';
        this.elements.colorEncoderToggle.checked = localStorage.getItem(this.settingsNames.colorTask) === 'true';
        this.toggleColorEncoder();
        this.elements.colorInput.value = localStorage.getItem(this.settingsNames.colorTaskColors) || '';
        this.elements.colorLetterCount.value = localStorage.getItem(this.settingsNames.colorTaskLetters) || '1';
        this.elements.showColorInfo.checked = localStorage.getItem(this.settingsNames.showTable) !== 'false';
        this.toggleColorDetails();
        this.elements.letterShuffleSelect.value = localStorage.getItem(this.settingsNames.shufflingLetters) || 'no';
        this.elements.letterEliminationSelect.value = localStorage.getItem(this.settingsNames.eliminatingLetters) || 'no';
        this.elements.wordShuffleSelect.value = localStorage.getItem(this.settingsNames.shufflingWords) || 'no';
        const fontSize = localStorage.getItem(this.settingsNames.textSize) || '42';
        this.elements.fontSizeSlider.value = fontSize;
        this.elements.fontSizeDisplay.value = fontSize;
        this.elements.marqueeDisplay.style.fontSize = `${fontSize}px`;
        this.isLoopEnabled = localStorage.getItem(this.settingsNames.loop) === 'true';
        if (this.isLoopEnabled) this.elements.loopToggle.classList.add('active');
        this.elements.mainContainer.classList.add(localStorage.getItem(this.settingsNames.appSize) || 'normal-size');
        this.elements.rewindButton.disabled = true;
        this.elements.fastForwardButton.disabled = true;
        this.elements.refreshText.disabled = true;
        this.elements.refreshColors.disabled = true;
        this.elements.copyText.disabled = true;

        const currentTextName = localStorage.getItem(this.settingsNames.currentTextName) || this.defaultTextName;
        const texts = JSON.parse(localStorage.getItem(this.settingsNames.texts) || '[]');
        this.elements.textSelect.innerHTML = `<option value="${this.defaultTextName}">${this.defaultTextName}</option>` + texts.map(text => `<option value="${text}">${text}</option>`).join('');
        this.currentTextName = this.defaultTextName;
        if (texts.includes(currentTextName)) {
          this.currentTextName = currentTextName;
        }
        this.elements.textSelect.value = this.currentTextName;
        this.isModified = false;

        const currentReader = this;
        currentReader.switchText(function () {
          currentReader.lastSavedPosition = localStorage.getItem(currentReader.settingsNames.lastPosition);
          if (currentReader.lastSavedPosition && currentReader.elements.textInput.value && confirm('Resume from last position?')) {
            currentReader.currentPosition = parseInt(currentReader.lastSavedPosition);
            setTimeout(() => {
              currentReader.startAnimation(false, false);
              currentReader.elements.progressDisplay.style.display = 'none';
            }, 1);
          } else {
            currentReader.lastSavedPosition = null;
          }
          setInterval(() => currentReader.savePosition(), 500);
        });
      },

      togglePlayback() {
        this.animationTimer ? this.pauseAnimation() : this.startAnimation();
      },

      stopPlayback(fully = false) {
        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
          this.animationTimer = null;
        }
        this.elements.playPauseButton.textContent = 'Start';
        this.elements.playPauseButton.classList.remove('pause');
        this.currentPosition = this.cachedContainerWidth;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.elements.marqueeControlsContainer.style.display = '';
        this.elements.additionalSettingsContainer.style.display = '';
        this.elements.progressDisplay.style.display = 'none';
        this.elements.colorDetails.style.display = 'none';
        this.elements.loopToggle.style.display = '';
        this.lastSavedPosition = null;
        this.elements.tabNavigation.style.display = '';
        this.elements.tabContent.style.display = '';
        this.updateProgressBar();
        if (fully && this.previousText !== null) {
          this.animationStartTime = null;
          this.currentPosition = null;
          this.previousText = '';
          this.wordCount = 0;
          this.elements.rewindButton.disabled = true;
          this.elements.fastForwardButton.disabled = true;
          this.elements.refreshText.disabled = true;
          this.elements.refreshColors.disabled = true;
          this.elements.copyText.disabled = true;
        }
      },

      startAnimation(resume = false, movement = true) {
        let htmlValue = this.elements.textInput.value.replace(/\s+/g, ' ').trim();
        try {
          htmlValue = htmlValue.replace(/\p{Z}+/ug, ' ');
          htmlValue = htmlValue.replace(/\p{C}+/ug, '');
        }
        catch (err) {
          console.error(err);
        }
        if (!htmlValue) {
          alert('Please add text');
          return false;
        }

        this.elements.textHelper.textContent = htmlValue;
        const cleanedText = this.elements.textHelper.textContent || this.elements.textHelper.innerText || "";
        this.elements.textHelper.textContent = '';

        if (this.previousText !== cleanedText) {
          this.wordCount = cleanedText.split(/\s+/).filter(word => word.length > 0).length;
          if (this.wordCount < 10) this.wordCount = 0;
        }

        let palleteChanged = false;

        if (!resume && this.elements.colorEncoderToggle.checked) {
          palleteChanged = true;
          const targetSize = parseInt(this.elements.colorLetterCount.value, 10);
          const preservedColors = new Map();
          const preservedLetters = [];
          this.elements.colorInput.value.split('\n').forEach(line => {
            const [letter, ...colorParts] = line.split(/\s+/);
            if (letter && colorParts.length) {
              const color = colorParts.join(' ');
              letter.toLowerCase().split('').forEach(char => {
                preservedLetters.push(char);
                preservedColors.set(char, color);
              });
            }
          });

          if (this.colorMap.size < targetSize || this.previousColorInput !== this.elements.colorInput.value) {
            const newColors = this.generateColors(targetSize);
            const letters = [...this.colorList];
            preservedLetters.forEach(char => {
              if (letters.length < targetSize && cleanedText.includes(char) && !letters.includes(char)) {
                letters.push(char);
              }
            });
            let index = 0;
            for (let i = 0; i < cleanedText.length && letters.length < targetSize; i++) {
              const char = cleanedText[i].toLowerCase();
              if (this.isLetter(char) && !letters.includes(char)) {
                letters.push(char);
                index++;
              }
            }
            letters.sort();
            index = 0;
            letters.forEach(char => {
              if (!this.colorMap.has(char)) {
                this.colorMap.set(char, preservedColors.get(char) || newColors[index++]);
                this.colorList.push(char);
              }
            });
          }
          this.colorList.reverse();
          for (let x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              if (preservedColors.get(x) == null) {
                this.colorMap.delete(x);
                this.colorList.splice(this.colorList.indexOf(x), 1);
              }
            }
            else {
              break;
            }
          }
          this.colorList.sort((a, b) => (preservedLetters.indexOf(a) - preservedLetters.indexOf(b)));
          this.colorList.reverse();
          for (let x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              this.colorMap.delete(x);
              this.colorList.splice(this.colorList.indexOf(x), 1);
            }
            else {
              break;
            }
          }
          this.colorList.sort();
          this.elements.colorDetails.style.display = this.elements.showColorInfo.checked ? '' : 'none';
        } else if (!resume && movement) {
          this.elements.colorDetails.style.display = 'none';
        }

        if (!resume) {
          this.elements.colorDetails.innerHTML = this.colorList
            .map((char, index) => {
              let postElem = '';
              if (index !== 0 && index % 5 === 0) {
                postElem = '<br><br>'
              }
              const color = this.colorMap.get(char);
              return `${postElem}${char.toUpperCase()}<span style="background-color:${color};color:${color};" class="marquee-span clickable" onclick="MarqueeReader.updateColor(this)">${char.toUpperCase()}</span>`;
            })
            .join('  ');
        }

        const needsUpdate = this.currentPosition == null || this.previousText !== cleanedText ||
          this.previousLetterShuffle !== this.elements.letterShuffleSelect.value ||
          this.previousLetterElimination !== this.elements.letterEliminationSelect.value ||
          this.previousWordShuffle !== this.elements.wordShuffleSelect.value ||
          this.wasColorTaskEnabled !== this.elements.colorEncoderToggle.checked ||
          (this.elements.colorEncoderToggle.checked && this.previousColorInput !== this.elements.colorInput.value);

        if (palleteChanged || needsUpdate) {
          const colorize = this.elements.colorEncoderToggle.checked
            ? char => this.colorMap.has(char.toLowerCase())
              ? `<span style="background-color:${this.colorMap.get(char.toLowerCase())};color:${this.colorMap.get(char.toLowerCase())};" class="marquee-span">${char}</span>`
              : char
            : char => char;
          this.elements.marqueeDisplay.innerHTML = this.processText(
            needsUpdate ? cleanedText : this.elements.marqueeDisplay.textContent,
            cleanedText,
            needsUpdate,
            colorize
          );
        }

        if (!resume) {
          this.updateCachedSizes();
        }

        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = containerWidth;
        const endPos = -textWidth;
        const stepSize = this.elements.speedDisplay.value > 100 ? (this.elements.speedDisplay.value - 100) / 10 + 1 : 1;
        let stepInterval = Math.max(1, parseInt(this.elements.speedValue.value, 10));
        if (this.elements.speedDisplay.value < 20) {
          stepInterval += (20 - Math.floor(this.elements.speedDisplay.value % 100)) * 20;
        }

        this.animationStartTime = Date.now();
        this.lastUpdateTime = this.animationStartTime;
        if (this.currentPosition == null || this.currentPosition <= endPos) this.currentPosition = startPos;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.lastSavedPosition = this.currentPosition;

        this.previousText = cleanedText;
        this.previousLetterShuffle = this.elements.letterShuffleSelect.value;
        this.previousWordShuffle = this.elements.wordShuffleSelect.value;
        this.previousLetterElimination = this.elements.letterEliminationSelect.value;
        this.previousColorInput = this.elements.colorInput.value;
        this.previousPosition = this.currentPosition;
        this.wasColorTaskEnabled = this.elements.colorEncoderToggle.checked;

        const animate = () => {
          const newPosition = parseInt(this.elements.marqueeDisplay.style.left, 10) - stepSize;
          this.lastSavedPosition = newPosition;
          this.lastUpdateTime = Date.now();
          const timePerStep = Math.floor((this.lastUpdateTime - this.animationStartTime) / Math.max(1e-9, this.previousPosition - newPosition) * 10) / 10;
          const secondsRemaining = Math.floor(timePerStep * (newPosition - endPos) / 1000);
          this.elements.progressDisplay.innerHTML = this.formatTime(secondsRemaining);
          if (this.wordCount > 5) {
            const totalSeconds = Math.floor(timePerStep * (startPos - endPos) / 1000);
            if (totalSeconds >= 1) {
              const wpm = Math.max(1, Math.floor(this.wordCount / (totalSeconds / 60)));
              this.elements.progressDisplay.innerHTML += `<br>WPM: ${wpm}`;
            }
          }
          const progress = Math.floor(100 * (1 - (newPosition - endPos) / (startPos - endPos)));
          this.elements.progressDisplay.innerHTML += `<br>Progress: ${progress}%`;

          if (newPosition <= endPos) {
            if (this.isLoopEnabled) {
              this.animationStartTime = Date.now();
              this.currentPosition = startPos;
              this.previousPosition = this.currentPosition;
              this.updateProgressBar();
              this.elements.marqueeDisplay.style.left = `${startPos}px`;
              this.lastSavedPosition = null;
              if (this.animationTimer) this.animationTimer = setTimeout(animate, stepInterval);
            } else {
              this.currentPosition = endPos;
              this.previousPosition = this.currentPosition;
              this.updateProgressBar();
              this.elements.marqueeDisplay.style.left = `${endPos}px`;
              clearTimeout(this.animationTimer);
              this.animationTimer = null;
              this.elements.playPauseButton.textContent = 'Start';
              this.elements.playPauseButton.classList.remove('pause');
              this.elements.marqueeControlsContainer.style.display = '';
              this.elements.additionalSettingsContainer.style.display = '';
              this.elements.colorDetails.style.display = this.elements.colorEncoderToggle.checked && this.elements.showColorInfo.checked ? '' : 'none';
              this.elements.loopToggle.style.display = '';
              this.lastSavedPosition = null;
              this.elements.tabNavigation.style.display = '';
              this.elements.tabContent.style.display = '';
            }
          } else {
            this.elements.marqueeDisplay.style.left = `${newPosition}px`;
            this.currentPosition = newPosition;
            this.updateProgressBar();
            if (this.animationTimer) this.animationTimer = setTimeout(animate, stepInterval);
          }
        };

        this.updateProgressBar();
        this.elements.rewindButton.disabled = false;
        this.elements.fastForwardButton.disabled = false;
        this.elements.refreshText.disabled = false;
        this.elements.refreshColors.disabled = false;
        this.elements.copyText.disabled = false;
        if (movement) {
          this.elements.loopToggle.style.display = 'none';
          this.elements.playPauseButton.textContent = 'Pause';
          this.elements.playPauseButton.classList.add('pause');
          this.elements.marqueeControlsContainer.style.display = 'none';
          this.elements.additionalSettingsContainer.style.display = 'none';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = 'none';
          this.elements.tabContent.style.display = 'none';
          this.animationTimer = setTimeout(animate, stepInterval);
        }
        return true;
      },

      pauseAnimation() {
        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
          this.animationTimer = null;
          this.elements.playPauseButton.textContent = 'Start';
          this.elements.playPauseButton.classList.remove('pause');
          this.elements.marqueeControlsContainer.style.display = '';
          this.elements.additionalSettingsContainer.style.display = '';
          this.elements.loopToggle.style.display = '';
          if (this.elements.colorEncoderToggle.checked) {
            this.elements.colorDetails.style.display = this.elements.showColorInfo.checked ? '' : 'none';
          }
          this.elements.tabNavigation.style.display = '';
          this.elements.tabContent.style.display = '';
          this.updateProgressBar();
        }
      },

      processText(text, referenceText, shouldModify, colorize) {
        const escapeString = str => str.replace(/\\/g, '').replace(/"/g, '').replace(/'/g, "\\'");
        const textLines = text.split('\n');
        const refLines = referenceText.split('\n');
        return textLines.map((line, index) => {
          const words = line.split(/\s+/).filter(word => word);
          const refWords = refLines[index] ? refLines[index].split(/\s+/) : words;
          let processedWords = words;
          let processedRefWords = refWords;

          if (shouldModify && this.elements.wordShuffleSelect.value !== 'no') {
            const match = /(\d+)_words?/.exec(this.elements.wordShuffleSelect.value);
            if (match) {
              const groupSize = parseInt(match[1]);
              const shuffledIndices = this.shuffleWordGroups(words, groupSize);
              processedWords = shuffledIndices.map(i => words[i]);
              processedRefWords = shuffledIndices.map(i => refWords[i]);
            }
          }

          return processedWords.map((word, i) => {
            let modifiedWord = word;
            let skipShuffle = /^[A-Z\d']/.test(word) || /[\u2032\u2033\u2034\u2057\u2019\u0060\u00B4\uFF40\u02F4]/.test(word);

            if (shouldModify && this.elements.letterEliminationSelect.value !== 'no' && word.length > 1) {
              const vowelMatch = /(\d+)%_vowels/.exec(this.elements.letterEliminationSelect.value);
              const randomMatch = /(\d+)%_random/.exec(this.elements.letterEliminationSelect.value);
              if (vowelMatch) {
                modifiedWord = this.eliminateLetters(this.vowelPatternG, modifiedWord, parseInt(vowelMatch[1]) / 100);
              } else if (randomMatch) {
                modifiedWord = this.eliminateLetters(this.letterPatternG, modifiedWord, parseInt(randomMatch[1]) / 100);
              }
            }

            if (shouldModify && this.elements.letterShuffleSelect.value !== 'no' && (!skipShuffle || this.elements.letterShuffleSelect.value === 'very-hard')) {
              const parts = modifiedWord.split('-');
              modifiedWord = parts.map(part => {
                const threshold = this.elements.letterShuffleSelect.value === 'hard' || this.elements.letterShuffleSelect.value === 'very-hard' ? 0 :
                  this.elements.letterShuffleSelect.value === 'medium' || this.elements.letterShuffleSelect.value === 'medium_plus' ? 1 : Math.floor(part.length / 3);
                const suffixLength = this.elements.letterShuffleSelect.value === 'medium_plus' ? 0 : threshold;
                let letters = [];
                for (let x of part) {
                  if (this.isLetter(x)) {
                    letters.push(x);
                  }
                }
                const firstLetters = letters.slice(0, threshold);
                const midLetters = letters.slice(threshold, letters.length - suffixLength);
                const lastLetters = letters.slice(letters.length - suffixLength);
                const originalMiddle = [...midLetters];
                const originalMiddleSize = new Set(originalMiddle).size;
                if (originalMiddleSize > 1) {
                  while (midLetters.join('') === originalMiddle.join('')) {
                    this.shuffleArray(midLetters);
                  }
                }
                const reordered = [...firstLetters, ...midLetters, ...lastLetters];
                let result = '';
                let j = 0;
                for (const char of part) {
                  result += this.isLetter(char) ? reordered[j++] : char;
                }
                return result;
              }).join('-');
            }

            const coloredWord = modifiedWord.split('').map(colorize).join('');
            return this.elements.letterShuffleSelect.value !== 'no' || this.elements.letterEliminationSelect.value !== 'no'
              ? `<span class="marquee-word-span clickable" onclick="MarqueeReader.showWordHint('${escapeString(modifiedWord)}', '${escapeString(processedRefWords[i] || word)}')">${coloredWord}</span>`
              : `<span class="marquee-word-span">${coloredWord}</span>`;
          }).join(' ');
        }).join('\n');
      },

      eliminateLetters(regex, word, percentOfLetters) {
        let lettersOnly = word;
        try {
          lettersOnly = word.replace(/[^\p{L}]/ug, '');
        } catch (err) {
          console.error(err);
        }
        let matchIndices = [];
        let isFirstMatch = true;
        regex.lastIndex = 0;
        while (true) {
          let match = regex.exec(word);
          if (match === null) break;
          if (isFirstMatch) {
            isFirstMatch = false;
            if (lettersOnly[0] === word[match.index]) continue;
          }
          matchIndices.push(match.index);
        }
        regex.lastIndex = 0;
        if (matchIndices.length > 0 && word.length >= 2 && regex === this.letterPatternG) {
          let lastIndex = matchIndices[matchIndices.length - 1];
          if (!this.vowelPattern.test(word[lastIndex]) || (lastIndex > 0 && this.vowelPattern.test(word[lastIndex - 1]))) {
            matchIndices.pop();
          }
        }
        let effectiveLength = lettersOnly.length;
        if (regex === this.vowelPatternG) {
          let vowelCount = 0;
          for (let char of word) {
            this.vowelPattern.lastIndex = 0;
            if (this.vowelPattern.test(char)) {
              vowelCount++;
            }
          }
          effectiveLength = vowelCount;
        }
        let numToRemove = Math.min(Math.floor(effectiveLength * percentOfLetters), matchIndices.length);
        let shuffledIndices = [...matchIndices];
        this.shuffleArray(shuffledIndices);
        let duplicateIndices = [];
        let vowelIndices = [];
        let otherIndices = [];
        for (let index of shuffledIndices) {
          if (index > 0 && word[index - 1] === word[index]) {
            duplicateIndices.push(index);
          } else if (this.vowelPattern.test(word[index])) {
            vowelIndices.push(index);
          } else {
            otherIndices.push(index);
          }
        }
        const cmp = (a, b) => b - a;
        duplicateIndices.sort(cmp);
        vowelIndices.sort(cmp);
        otherIndices.sort(cmp);
        let indicesToRemove = [...duplicateIndices, ...vowelIndices, ...otherIndices].slice(0, numToRemove).sort((a, b) => a - b);
        let wordParts = [];
        let start = 0;
        for (let removeIndex of indicesToRemove) {
          if (start < removeIndex) {
            wordParts.push(word.slice(start, removeIndex));
          }
          start = removeIndex + 1;
        }
        if (start < word.length) {
          wordParts.push(word.slice(start));
        }
        return wordParts.join('');
      },

      shuffleWordGroups(words, groupSize) {
        let shuffledIndices = [];
        for (let start = 0; start < words.length;) {
          let groupWords = words.slice(start, start + groupSize);
          let subGroupWords = [groupWords[0]];
          let hasPunctuation = this.punctuationPattern.test(groupWords[0]);
          for (let j = 1; j < groupWords.length; j++) {
            if (hasPunctuation || this.punctuationPattern.test(groupWords[j])) {
              break;
            }
            subGroupWords.push(groupWords[j]);
          }
          groupWords = subGroupWords;
          let groupLength = groupWords.length;
          let shuffleableIndices = [];
          let fixedIndices = new Set();
          for (let j = 0; j < groupLength; j++) {
            if (this.punctuationPattern.test(groupWords[j])) {
              fixedIndices.add(j);
            } else {
              shuffleableIndices.push(j);
            }
          }
          this.shuffleArray(shuffleableIndices);
          let shufflePosition = 0;
          for (let j = 0; j < groupLength; j++) {
            if (fixedIndices.has(j)) {
              shuffledIndices.push(start + j);
            } else {
              shuffledIndices.push(start + shuffleableIndices[shufflePosition]);
              shufflePosition++;
            }
          }
          start += groupLength;
        }
        return shuffledIndices;
      },

      isLetter(char) {
        return /^[a-zA-Z]$/.test(char) || char.toLowerCase() !== char.toUpperCase() || (this.letterPattern && this.letterPattern.test(char));
      },

      shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      },

      generateColors(count) {
        const colors = [];
        const isTooDarkOrLight = (r, g, b) => {
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance < 0.2 || luminance > 0.8;
        };
        for (let i = 0; i < count; i++) {
          let r, g, b;
          do {
            r = Math.floor(Math.random() * 256);
            g = Math.floor(Math.random() * 256);
            b = Math.floor(Math.random() * 256);
          } while (isTooDarkOrLight(r, g, b));
          colors.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
        }
        return colors;
      },

      formatTime(seconds) {
        if (seconds < 0) return '00:00:00';
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      },

      switchTheme() {
        const current = this.themes.find(theme => this.elements.body.classList.contains(theme));
        const next = this.themes[(this.themes.indexOf(current) + 1) % this.themes.length] || this.themes[0];
        this.themes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(next);
        localStorage.setItem(this.settingsNames.theme, next);
      },

      switchMarqueeTheme() {
        const current = this.marqueeThemes.find(theme => this.elements.body.classList.contains(theme));
        const next = this.marqueeThemes[(this.marqueeThemes.indexOf(current) + 1) % this.marqueeThemes.length] || this.marqueeThemes[0];
        this.marqueeThemes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(next);
        localStorage.setItem(this.settingsNames.marqueeTheme, next);
        this.elements.marqueeThemeToggle.innerHTML = [...this.elements.marqueeThemeToggle.innerHTML.split(' ').slice(0, -1), `[${next.slice(-1)}]`].join(' ');
      },

      toggleFullSize() {
        const sizes = ['max-size', 'normal-size'];
        const container = document.querySelector('.container');
        const current = sizes.find(size => container.classList.contains(size));
        const next = sizes[(sizes.indexOf(current) + 1) % sizes.length] || sizes[0];
        sizes.forEach(size => container.classList.remove(size));
        container.classList.add(next);
        localStorage.setItem(this.settingsNames.appSize, next);
        if (this.currentPosition !== null) {
          this.updateCachedSizes();
          this.updateProgressBar();
        }
      },

      toggleLoop() {
        this.isLoopEnabled = !this.isLoopEnabled;
        this.elements.loopToggle.classList.toggle('active');
        localStorage.setItem(this.settingsNames.loop, this.isLoopEnabled);
      },

      switchTab(button) {
        this.elements.tabButtons.forEach(btn => {
          btn.classList.remove('active');
          btn.setAttribute('aria-selected', 'false');
        });
        button.classList.add('active');
        button.setAttribute('aria-selected', 'true');
        const tabId = button.getAttribute('data-tab');
        this.elements.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === tabId);
        });
        localStorage.setItem(this.settingsNames.activeTab, button.getAttribute('data-tab'))
      },

      restoreActiveTab() {
        const activeTab = localStorage.getItem(this.settingsNames.activeTab) || 'info-tab';
        if (activeTab) {
          var activeTabButton = document.querySelector(`.tab-button[data-tab="${activeTab}"]`);
          if (activeTabButton) {
            this.switchTab(activeTabButton);
          }
        }
      },

      adjustFontSize(value) {
        this.elements.fontSizeSlider.value = value;
        this.elements.fontSizeDisplay.value = value;
        this.elements.marqueeDisplay.style.fontSize = `${value}px`;
      },

      adjustSpeed(value) {
        this.elements.speedSlider.value = value;
        this.elements.speedDisplay.value = value;
        this.elements.speedValue.value = 100 - value;
      },

      syncSpeed(value) {
        this.elements.speedValue.value = value;
        this.elements.speedSlider.value = 100 - value;
        this.elements.speedDisplay.value = 100 - value;
      },

      rewind() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left, 10) + Math.floor(containerWidth / 4)));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      fastForward() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left, 10) - Math.floor(containerWidth / 4)));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeText() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          this.previousLetterShuffle = '';
          this.startAnimation(false, false);
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeColors() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();
          this.colorMap.clear();
          this.colorList = [];
          this.startAnimation(false, false);
          this.updateProgressBar();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      copyMarqueeText() {
        if (this.currentPosition !== null) {
          navigator.clipboard.writeText(this.elements.marqueeDisplay.textContent);
        }
      },

      toggleColorEncoder() {
        const isVisible = this.elements.showColorInfo.checked && this.elements.colorEncoderToggle.checked;
        this.elements.colorInput.style.display = isVisible ? '' : 'none';
        this.elements.dumpColors.style.display = isVisible ? '' : 'none';
        this.elements.colorEncoderOptions.style.display = this.elements.colorEncoderToggle.checked ? '' : 'none';
      },

      toggleColorDetails() {
        this.elements.colorDetails.style.display = this.elements.showColorInfo.checked ? '' : 'none';
        const isVisible = this.elements.showColorInfo.checked && this.elements.colorEncoderToggle.checked;
        this.elements.colorInput.style.display = isVisible ? '' : 'none';
        this.elements.dumpColors.style.display = isVisible ? '' : 'none';
      },

      dumpColorMap() {
        this.colorList.forEach(char => {
          const color = this.hexToRgb(this.colorMap.get(char));
          const entry = `${char.toUpperCase()} ${color}`;
          if (!this.elements.colorInput.value.includes(entry)) {
            this.elements.colorInput.value += (this.elements.colorInput.value && !this.elements.colorInput.value.endsWith('\n') ? '\n' : '') + entry + '\n';
          }
        });
      },

      clearInput() {
        this.elements.textInput.value = '';
        this.isModified = true;
      },

      fetchSentence() {
        let sentences = [];
        try {
          sentences = getSentences();
        } catch (e) {
          alert('[Sentences.js] Sentences not found!');
          return;
        }
        const sentence = sentences[Math.floor(Math.random() * sentences.length)];
        if (sentence) {
          const text = /[.!?]$/.test(sentence) ? sentence : `${sentence}.`;
          this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
          this.isModified = true;
        }
      },

      fetchWikipedia() {
        fetch('https://en.wikipedia.org/api/rest_v1/page/random/summary')
          .then(response => response.json())
          .then(data => {
            const text = data.extract.trim();
            this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
            this.isModified = true;
          })
          .catch(() => alert('[Wiki] Data Fetching Error.'));
      },

      fetchMetaphorpsum() {
        fetch('http://metaphorpsum.com/sentences/1')
          .then(response => response.text())
          .then(text => {
            this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text.trim()}` : text.trim();
            this.isModified = true;
          })
          .catch(() => alert('[Metaphorpsum] Data Fetching Error.'));
      },

      loadFromFile() {
        const input = document.createElement('input');
        input.type = 'file';
        input.onchange = e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = event => {
              const text = event.target.result.trim();
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.isModified = true;
            };
            reader.readAsText(file);
          }
        };
        this.elements.body.appendChild(input);
        input.click();
        this.elements.body.removeChild(input);
      },

      savePreferences() {
        try {
          if (this.currentTextName === this.defaultTextName) {
            localStorage.setItem(this.settingsNames.text, this.elements.textInput.value);
          } else if (this.database) {
            const transaction = this.database.transaction([this.settingsNames.texts], 'readwrite');
            const objectStore = transaction.objectStore(this.settingsNames.texts);
            objectStore.put({ title: this.currentTextName, content: this.elements.textInput.value });
          }
          this.isModified = false;
        }
        catch (err) {
          console.error(err);
          alert(err);
        }
        localStorage.setItem(this.settingsNames.colorTask, this.elements.colorEncoderToggle.checked);
        localStorage.setItem(this.settingsNames.colorTaskLetters, this.elements.colorLetterCount.value);
        localStorage.setItem(this.settingsNames.colorTaskColors, this.elements.colorInput.value);
        localStorage.setItem(this.settingsNames.showTable, this.elements.showColorInfo.checked);
        localStorage.setItem(this.settingsNames.speed, this.elements.speedValue.value);
        localStorage.setItem(this.settingsNames.appendText, this.elements.appendTextToggle.checked);
        localStorage.setItem(this.settingsNames.shufflingLetters, this.elements.letterShuffleSelect.value);
        localStorage.setItem(this.settingsNames.shufflingWords, this.elements.wordShuffleSelect.value);
        localStorage.setItem(this.settingsNames.eliminatingLetters, this.elements.letterEliminationSelect.value);
        localStorage.setItem(this.settingsNames.loop, this.isLoopEnabled);
        localStorage.setItem(this.settingsNames.textSize, this.elements.fontSizeDisplay.value);
        localStorage.setItem(this.settingsNames.currentTextName, this.currentTextName);
      },

      resetPreferences() {
        const currentReader = this;
        if (confirm('Are you sure you want to reset the settings?')) {
          currentReader.lastSavedPosition = null;
          for (let v of Object.values(currentReader.settingsNames)) {
            if (v === currentReader.settingsNames.texts || v === currentReader.settingsNames.text) {
              continue;
            }
            localStorage.removeItem(v);
          }
          currentReader.locationReload();
        }
      },

      deleteAllTexts() {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all texts?')) {
          currentReader.lastSavedPosition = null;
          localStorage.removeItem(currentReader.settingsNames.text);
          if (currentReader.database) {
            try {
              currentReader.database.close();
              const request = indexedDB.deleteDatabase(currentReader.databaseName);
              request.onsuccess = function (event) {
                localStorage.removeItem(currentReader.settingsNames.texts);
                currentReader.locationReload();
              };
              request.onerror = function (event) {
                const message = `IndexedDB error: ${event.target.errorCode}`;
                console.error(message);
                alert(message);
                currentReader.locationReload();
              };
              request.onblocked = function (event) {
                const message = `IndexedDB blocked: ${event.target.errorCode}\nTry again later.`;
                console.error(message);
                alert(message);
                currentReader.locationReload();
              };
            }
            catch (err) {
              console.error(err);
              alert(err);
              currentReader.locationReload();
            }
          }
        }
      },

      savePosition() {
        if (this.lastSavedPosition !== null) {
          localStorage.setItem(this.settingsNames.lastPosition, this.lastSavedPosition);
        } else {
          localStorage.removeItem(this.settingsNames.lastPosition);
        }
      },

      updateColor(element) {
        const newColor = prompt('Enter color:', element.style.color);
        if (newColor) {
          this.colorMap.set(element.textContent.toLowerCase(), newColor);
          element.style.color = newColor;
          element.style.backgroundColor = newColor;
        }
      },

      showWordHint(shuffled, original) {
        alert(`${shuffled} -> ${original}`);
      },

      hexToRgb(hex) {
        if (!/^#[a-f0-9]{3,6}$/i.test(hex)) return hex;
        hex = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (_, r, g, b) => r + r + g + g + b + b);
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : hex;
      },

      handleKeyPress(event) {
        if (['INPUT', 'TEXTAREA'].includes(event.target.tagName)) return;
        event.preventDefault();
        switch (event.key) {
          case ' ': this.togglePlayback(); break;
          case 'ArrowLeft': if (this.currentPosition !== null) this.rewind(); break;
          case 'ArrowRight': if (this.currentPosition !== null) this.fastForward(); break;
          case 'l':
          case 'L': this.toggleLoop(); break;
          case 'c':
          case 'C': if (!this.animationTimer) this.elements.colorEncoderToggle.click(); break;
          case 's':
          case 'S': this.stopPlayback(); break;
          case '+': if (!this.animationTimer) this.elements.speedDisplay.value = parseInt(this.elements.speedDisplay.value) + 1; this.adjustSpeed(this.elements.speedDisplay.value); break;
          case '-': if (!this.animationTimer) this.elements.speedDisplay.value = parseInt(this.elements.speedDisplay.value) - 1; this.adjustSpeed(this.elements.speedDisplay.value); break;
          case 'Escape': if (!this.animationTimer) this.elements.showColorInfo.click(); break;
        }
      },

      updateProgressBar() {
        if (this.currentPosition !== null) {
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;
          const progress = Math.min(100, Math.max(0, Math.floor(100 * (1 - (this.currentPosition - endPos) / (startPos - endPos)) * 10) / 10));
          this.elements.progressBar.style.width = `${progress}%`;
        } else {
          this.elements.progressBar.style.width = '0%';
        }
      },

      handleProgressBarClick(event) {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer !== null;
          if (wasPlaying) this.pauseAnimation();

          const rect = this.elements.progressBarContainer.getBoundingClientRect();
          const scrollbarWidth = wasPlaying ? window.innerWidth - document.documentElement.clientWidth : 0;
          const clickX = event.clientX - rect.left - Math.min(20, Math.max(0, scrollbarWidth));

          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;

          const progress = clickX / rect.width;
          this.currentPosition = startPos - (startPos - endPos) * progress;
          this.currentPosition = Math.max(endPos, Math.min(startPos, this.currentPosition));
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.lastSavedPosition = this.currentPosition;
          this.updateProgressBar();

          if (wasPlaying) this.startAnimation(true);
        }
      },

      switchText(callback = null) {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (!currentReader.database) {
          currentReader.elements.textSelect.value = currentTextName;
          return;
        }
        if (currentReader.isModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to switch texts?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        currentReader.stopPlayback(true);
        const selectedTextName = currentReader.elements.textSelect.value;
        if (selectedTextName === currentReader.defaultTextName) {
          currentReader.elements.textInput.value = localStorage.getItem(currentReader.settingsNames.text) || '';
          currentReader.isModified = false;
          currentReader.currentTextName = selectedTextName;
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
          if (callback) {
            callback();
          }
        } else {
          const transaction = currentReader.database.transaction([this.settingsNames.texts], 'readonly');
          const objectStore = transaction.objectStore(this.settingsNames.texts);
          const request = objectStore.get(selectedTextName);
          request.onsuccess = () => {
            currentReader.elements.textInput.value = request.result ? request.result.content : '';
            currentReader.isModified = false;
            if (callback) {
              callback();
            }
          };
          currentReader.currentTextName = selectedTextName;
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
          request.onerror = () => {
            alert('Error loading text from IndexedDB.');
            currentReader.currentTextName = currentReader.defaultTextName;
            currentReader.elements.textSelect.value = currentReader.defaultTextName;
            localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
            currentReader.locationReload();
          };
        }
      },

      createNewText() {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (currentReader.isModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to create a new text?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        let name;
        do {
          name = prompt('Enter a unique name for the new text:');
          if (!name) return;
          const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          if (texts.includes(name)) {
            alert('This text name already exists. Please choose another one.');
            name = null;
          }
        } while (!name);
        currentReader.stopPlayback(true);
        const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
        texts.push(name);
        const transaction = currentReader.database.transaction([this.settingsNames.texts], 'readwrite');
        const objectStore = transaction.objectStore(this.settingsNames.texts);
        objectStore.add({ title: name, content: '' });
        localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
        const option = document.createElement('option');
        option.value = name;
        option.textContent = name;
        currentReader.elements.textSelect.appendChild(option);
        currentReader.elements.textSelect.value = name;
        currentReader.isModified = false;
        currentReader.switchText();
      },

      deleteCurrentText() {
        const currentReader = this;
        if (currentReader.currentTextName === currentReader.defaultTextName) {
          alert(`Cannot delete the ${currentReader.defaultTextName} text.`);
          return;
        }
        if (confirm(`Are you sure you want to delete the text "${currentReader.currentTextName}"?`)) {
          currentReader.stopPlayback(true);
          const transaction = currentReader.database.transaction([this.settingsNames.texts], 'readwrite');
          const objectStore = transaction.objectStore(this.settingsNames.texts);
          objectStore.delete(currentReader.currentTextName);
          let texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          texts = texts.filter(text => text !== currentReader.currentTextName);
          localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
          const option = currentReader.elements.textSelect.querySelector(`option[value="${currentReader.currentTextName}"]`);
          if (option) option.remove();
          currentReader.elements.textSelect.value = currentReader.defaultTextName;
          currentReader.isModified = false;
          currentReader.switchText();
        }
      },

      locationReload() {
        setTimeout(function(){
          location.reload();
        }, 1);
      }
    };

    document.addEventListener('DOMContentLoaded', () => {
      const script = document.createElement('script');
      script.src = 'sentences.js?version=1';
      document.head.appendChild(script);
      MarqueeReader.initialize();
    });
  </script>
</body>
</html>