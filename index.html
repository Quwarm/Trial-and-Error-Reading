<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trial and Error Reading</title>
  <link rel="icon" type="image/png" href="favicon.png" author="meaicon" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }

    .container {
      max-width: 600px;
      margin: 0 auto;
    }

    #input-container, #marquee-container, #control-container, #other-settings-container {
      margin-bottom: 20px;
      text-align: center;
    }

    label {
      font-weight: bold;
      display: block;
      margin-bottom: 5px;
    }

    #marquee-input {
      width: 100%;
      min-height: 300px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #color-input {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #delay-input {
      width: 100px;
      padding: 5px;
      font-size: 16px;
      text-align: center;
    }

    #marquee-container {
      width: 100%;
      height: 60px;
      overflow: hidden;
      position: relative;
      border: 2px solid;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      direction: ltr;
    }

    #marquee-text {
      position: absolute;
      white-space: nowrap;
      font-size: 42px;
      line-height: 60px;
      text-align: right;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #colors-info {
      font-size: 22px;
      font-weight: bold;
    }

    #start-pause-button, #stop-button {
      background-color: rgb(25, 135, 84);
      color: white;
    }

    #start-pause-button.pause {
      background-color: rgb(218, 104, 11);
    }

    #start-pause-button:hover:not(.pause) {
      background-color: rgb(21, 115, 71);
    }

    #start-pause-button.pause:hover {
      background-color: rgb(194, 93, 10);
    }

    #stop-button {
      background-color: rgb(187, 45, 59);
    }

    #stop-button:hover {
      background-color: rgb(180, 25, 46);
    }

    #theme-button {
      background-color: rgb(11, 166, 197);
      color: white;
    }

    #theme-button:hover {
      background-color: rgb(9, 130, 153);
    }

    body.light #back-button, body.light #forward-button, body.light #update-colors-button {
      background-color: rgb(239, 239, 239);
      color: rgb(0, 0, 0);
      display: inline-block;
    }

    body.light #back-button:hover, body.light #forward-button:hover, body.light #update-colors-button:hover {
      background-color: rgb(229, 229, 229);
      color: rgb(0, 0, 0);
    }

    body.light #back-button:disabled, body.light #forward-button:disabled, body.light #update-colors-button:disabled {
      background-color: rgb(246, 246, 246);
      color: rgb(173, 173, 173);
    }

    body.dark #back-button, body.dark #forward-button, body.dark #update-colors-button {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
      display: inline-block;
    }

    body.dark #back-button:hover, body.dark #forward-button:hover, body.dark #update-colors-button:hover {
      background-color: rgb(80, 80, 80);
      color: rgb(255, 255, 255);
    }

    body.dark #back-button:disabled, body.dark #forward-button:disabled, body.dark #update-colors-button:disabled {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
    }

    #update-colors-button {
      max-width: 60px;
    }

    #dump-colors-button, #clear-button, #fetch-1-button, #fetch-2-button, #fetch-3-button, #load-from-file-button {
      background-color: rgb(108, 117, 125);
      color: white;
      display: inline-block;
    }

    #dump-colors-button:hover, #clear-button:hover, #fetch-1-button:hover, #fetch-2-button:hover, #fetch-3-button:hover, #load-from-file-button:hover {
      background-color: rgb(92, 99, 106);
    }

    body.light .span-in-marquee {
      border: 1px dashed white;
    }

    body.dark .span-in-marquee {
      border: 1px dashed black;
    }

    #save-button {
      background-color: rgb(13, 110, 253);
      color: white;
      display: inline-block;
    }

    #save-button:hover {
      background-color: rgb(11, 94, 215);
    }

    #reset-button {
      background-color: rgb(33, 37, 41);
      color: white;
      display: inline-block;
    }

    #reset-button:hover {
      background-color: rgb(66, 70, 73);
    }

    select {
      padding: 4px 4px 4px 4px;
    }

    input[type=text], input[type=number], select {
      padding: 8px 10px 8px 10px;
    }

    input[type=range] {
      padding: 0px 4px 0px 4px;
      width: 250px;
      margin: auto auto;
    }

    input[type=checkbox] {
      padding: 0px 4px 0px 4px;
    }

    body.light {
      background-color: #f9f9f9;
      color: #333;
    }

    body.light #marquee-container {
      background-color: #f0f0f0;
      border-color: #333;
    }

    body.light #marquee-input, body.light #color-input {
      background-color: #f0f0f0;
      border-color: #333;
      color: black;
    }

    body.dark {
      background-color: #1a1a1a;
      color: #e0e0e0;
    }

    body.dark #marquee-container {
      background-color: #2a2a2a;
      border-color: #e0e0e0;
    }

    body.dark #marquee-input, body.dark #color-input {
      background-color: #2a2a2a;
      border-color: #e0e0e0;
      color: white;
    }

    @media (max-width: 600px) {
      button {
        width: 100%;
        margin-bottom: 10px;
      }
    }
  </style>
</head>
<body class="light">
  <div class="container">

    <div id="marquee-container">
      <span id="marquee-text"></span>
    </div>

    <div id="control-container">
      <button id="back-button" disabled>&lt;&lt;</button>
      <button id="start-pause-button">Start</button>
      <button id="stop-button">Stop</button>
      <button id="forward-button" disabled>&gt;&gt;</button>
      <br>
      <span id="duration-info" style="display: none;">0</span>
      <br><br>
      <span id="colors-info" style="display: none;"></span>
    </div>

    <div id="input-container">
      <label for="speed-input">Speed</label>
      <input type="number" id="speed-input" min="0" max="100" value="10" style="display: none;">
      <input type="range" id="delay-slider" min="0" max="100" value="100">
      <input type="number" id="delay-info" min="0" max="100" value="100">
      <br><br>
      <label>Difficulty of shuffling:
        <select id="difficulty-select">
          <option value="no">-</option>
          <option value="easy">Easy</option>
          <option value="medium">Medium</option>
          <option value="hard">Hard</option>
          <option value="very-hard">Very Hard</option>
        </select>
      </label>
      <br>
      <label><input type="checkbox" id="color-task-checkbox" checked> Color encoder task</label>
      <label for="color-task-letters" id="color-task-letters-label">Number of letters:
        <input type="number" id="color-task-letters" min="0" max="32" value="1">
        <button id="update-colors-button" disabled>&#128260;</button>
      </label>
      <br>
      <button id="dump-colors-button">Dump colors above</button>
      <textarea id="color-input" placeholder="&lt;letter&gt; &lt;color&gt;&#13;&#10;a rgb(0, 0, 0)&#13;&#10;b red&#13;&#10;..."></textarea>
      <br><br>
      <label for="marquee-input">Text</label>
      <textarea id="marquee-input" placeholder="Enter text here"></textarea>
      <br>
      <button id="fetch-1-button">Load [meaningful:sentences.js]</button>
      <button id="fetch-2-button">Fetch [meaningful:wiki]</button>
      <button id="load-from-file-button">Load [from file]</button>
      <button id="fetch-3-button" style="display: none;">Fetch [random:metaphorpsum]</button>
      <button id="clear-button">Clear</button>
      <label><input type="checkbox" id="append-checkbox" checked> Append text after loading/fetching (uncheck to clear and append)</label>
      <br>
      <label><input type="checkbox" id="show-text-checkbox" checked> Show text</label>
      <label><input type="checkbox" id="show-table-checkbox" checked> Show letters-colors info</label>
      <br><br>
      <button id="save-button">Save text and settings</button>
    </div>

    <div id="other-settings-container">
      <button id="theme-button">Toggle Theme</button>
      <button id="reset-button">Reset settings</button>
    </div>

  </div>

  <script>
    function loadScript(url, head_or_body = 'head') {
        var script = document.createElement("script");
        script.src = url;
        if (head_or_body == 'head') {
            document.head.appendChild(script);
        }
        else {
            document.body.appendChild(script);
        }
    }

    let animationId = null;
    let lastPosition = null;
    let startTime = null, lastTime = null;
    let prevLength = 0, currentPallete = new Map(), currentPalleteList = [];

    function changeColor(elem) {
      let text = prompt("Enter color:", elem.style.color);
      if (text) {
        currentPallete.set(elem.innerHTML.toLowerCase(), text);
        elem.style.color = text;
        elem.style.backgroundColor = text;
      }
    }

    document.addEventListener('DOMContentLoaded', function() {
      loadScript('sentences.js');
      let sentences = [];
      const input = document.getElementById('marquee-input');
      const speedInput = document.getElementById('speed-input');
      const delaySlider = document.getElementById('delay-slider');
      const delayInfo = document.getElementById('delay-info');
      const durationInfo = document.getElementById('duration-info');
      const colorsInfo = document.getElementById('colors-info');
      const appendCheckbox = document.getElementById('append-checkbox');
      const difficultySelect = document.getElementById('difficulty-select');
      const textElement = document.getElementById('marquee-text');
      const inputContainer = document.getElementById('input-container');
      const otherSettingsContainer = document.getElementById('other-settings-container');
      const container = document.getElementById('marquee-container');
      const startPauseButton = document.getElementById('start-pause-button');
      const stopButton = document.getElementById('stop-button');
      const themeButton = document.getElementById('theme-button');
      const saveButton = document.getElementById('save-button');
      const resetButton = document.getElementById('reset-button');
      const clearButton = document.getElementById('clear-button');
      const fetch1Button = document.getElementById('fetch-1-button');
      const fetch2Button = document.getElementById('fetch-2-button');
      const fetch3Button = document.getElementById('fetch-3-button');
      const loadFromFileButton = document.getElementById('load-from-file-button');
      const colorTaskCheckbox = document.getElementById('color-task-checkbox');
      const colorTaskLettersLabel = document.getElementById('color-task-letters-label');
      const colorTaskLettersInput = document.getElementById('color-task-letters');
      const backButton = document.getElementById('back-button');
      const forwardButton = document.getElementById('forward-button');
      const colorInput = document.getElementById('color-input');
      const dumpColorsButton = document.getElementById('dump-colors-button');
      const showTextCheckbox = document.getElementById('show-text-checkbox');
      const showTableCheckbox = document.getElementById('show-table-checkbox');
      const updateColorsButton = document.getElementById('update-colors-button');

      const savedText = localStorage.getItem('sle_text');
      if (savedText) input.value = savedText;
      const savedDelay = localStorage.getItem('sle_speed');
      if (savedDelay) speedInput.value = savedDelay;
      delaySlider.value = 100 - speedInput.value;
      delayInfo.value = delaySlider.value;
      const savedTheme = localStorage.getItem('sle_theme');
      document.body.className = savedTheme || 'dark';
      const savedAppend = localStorage.getItem('sle_append_text') || 'true';
      appendCheckbox.checked = savedAppend !== 'false';
      const colorTask = localStorage.getItem('sle_color_task') || 'false';
      colorTaskCheckbox.checked = colorTask == 'true';
      colorTaskLettersLabel.style.display = colorTaskCheckbox.checked ? '' : 'none';
      dumpColorsButton.style.display = colorTaskCheckbox.checked ? '' : 'none';
      const colorInputValue = localStorage.getItem('sle_color_task_colors') || '';
      colorInput.value = colorInputValue;
      const colorTaskLetters = localStorage.getItem('sle_color_task_letters') || '1';
      colorTaskLettersInput.value = colorTaskLetters;
      const showTextBool = localStorage.getItem('sle_show_text') || 'true';
      showTextCheckbox.checked = showTextBool === 'true';
      input.style.display = showTextCheckbox.checked ? '' : 'none';
      const showTableBool = localStorage.getItem('sle_show_table') || 'true';
      showTableCheckbox.checked = showTableBool === 'true';
      colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
      colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
      dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
      const savedDifficulty = localStorage.getItem('sle_difficulty') || 'no';
      difficultySelect.value = savedDifficulty;
      let prevDifficulty = difficultySelect.value;
      let prevColorInputValue = colorInputValue;

      updateColorsButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let to_play = animationId != null;
          if (to_play) {
            pauseView();
          }
          currentPallete.clear();
          currentPalleteList = [];
          let currentValue = colorInput.value;
          startView(false);
          pauseView();
          if (to_play) {
            startView(true);
          }
        }
      });

      showTextCheckbox.addEventListener('click', function() {
        input.style.display = showTextCheckbox.checked ? '' : 'none';
      });
      
      showTableCheckbox.addEventListener('click', function() {
        colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
        colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
    });

      colorTaskCheckbox.addEventListener('click', function() {
        colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        colorTaskLettersLabel.style.display = colorTaskCheckbox.checked ? '' : 'none';
      });

      dumpColorsButton.addEventListener('click', function() {
        let currentPalleteInfo = '';
        for (let k of currentPalleteList) {
          let v = currentPallete.get(k);
          k = k.toUpperCase();
          v = hexToRgb(v);
          currentPalleteInfo = currentPalleteInfo.concat(`${k} ${v}`);
          if (colorInput.value.indexOf(currentPalleteInfo) < 0) {
            let last = colorInput.value.slice(-1);
            if (last.length > 0 && last != '\n') {
              colorInput.value = colorInput.value.concat('\n');
            }
            colorInput.value = colorInput.value.concat(currentPalleteInfo).concat('\n');
          }
          currentPalleteInfo = '';
        }
      });

      speedInput.addEventListener('input', function() {
        delaySlider.value = 100 - this.value;
        delayInfo.value = delaySlider.value;
      });
      delayInfo.addEventListener('input', function() {
        speedInput.value = Math.max(0, 100 - this.value);
        delaySlider.value = this.value;
      });
      delaySlider.addEventListener('input', function() {
        speedInput.value = Math.max(0, 100 - this.value);
        delayInfo.value = this.value;
      });

      themeButton.addEventListener('click', function() {
        document.body.classList.toggle('light');
        document.body.classList.toggle('dark');
        const currentTheme = document.body.classList.contains('dark') ? 'dark' : 'light';
        localStorage.setItem('sle_theme', currentTheme);
      });

      clearButton.addEventListener('click', function() {
        input.value = '';
      });

      fetch1Button.addEventListener('click', function() {
        loadSentence();
      });

      fetch2Button.addEventListener('click', function() {
        fetchWiki();
      });

      fetch3Button.addEventListener('click', function() {
        fetchMetaphorpsum();
      });

      loadFromFileButton.addEventListener('click', function() {
        uploadTextFile();
      });

      backButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let to_play = animationId != null;
          if (to_play) {
            pauseView();
          }
          const containerWidth = Math.ceil(container.getBoundingClientRect().width);
          const startPosition = containerWidth;
          const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
          const endPosition = -textWidth;
          lastPosition = Math.max(endPosition, Math.min(startPosition, parseInt(textElement.style.left, 10) + Math.floor(containerWidth / 2)));
          prevLastPosition = lastPosition;
          textElement.style.left = lastPosition + 'px';
          if (to_play) {
            startView(true);
          }
        }
      });

      forwardButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let to_play = animationId != null;
          if (to_play) {
            pauseView();
          }
          const containerWidth = Math.ceil(container.getBoundingClientRect().width);
          const startPosition = containerWidth;
          const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
          const endPosition = -textWidth;
          lastPosition = Math.max(endPosition, Math.min(startPosition, parseInt(textElement.style.left, 10) - Math.floor(containerWidth / 2)));
          prevLastPosition = lastPosition;
          textElement.style.left = lastPosition + 'px';
          if (to_play) {
            startView(true);
          }
        }
      });

      function hexToRgb(hex) {
        if (!hex.match(/^#[a-f0-9]{3}$/i) && !hex.match(/^#[a-f0-9]{6}$/i)) {
          return hex;
        }
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : hex;
      }

      function uploadTextFile(event) {
        let element = document.createElement('input');
        element.id = 'text_file_upload';
        element.type = 'file';
        element.onchange = function (event) {
            if (window.File && window.FileReader && window.FileList && window.Blob) {
                let f = event.target.files[0];
                if (f) {
                    let r = new FileReader;
                    r.addEventListener("load", (function(event) {
                        let text = event.target.result;
                        input.value += (input.value ? '\n\n' : '') + text;
                    }));
                    r.readAsText(f);
                }
            } else {
                alert("This functionality not supported by your browser.")
            }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
     }

      function loadSentence() {
        if (sentences.length == 0) {
            try {
              sentences = getSentences();
            }
            catch(err) {
              sentences = [];
              console.log(err);
            }
        }
        if (sentences.length == 0) {
            alert('[Sentences.js] Sentences not found!');
            return;
        }
        let text = sentences[Math.floor(Math.random() * sentences.length)];
        if (text) {
            if (!text.endsWith('.') && !text.endsWith('?') && !text.endsWith('!') && !text.endsWith(',')) {
                text += '.';
            }
            if (appendCheckbox.checked) {
                input.value += (input.value ? '\n\n' : '') + text;
            } else {
                input.value = text;
            }
        }
      }

      function fetchWiki() {
        fetch('https://en.wikipedia.org/api/rest_v1/page/random/summary', {
            method: 'GET',
            accept: "application/problem+json"
        })
        .then(response => response.text())
        .then(data => {
            data = JSON.parse(data);
            text = data['extract'];
            text = text.trim();
            if (text) {
                if (appendCheckbox.checked) {
                  input.value += (input.value ? '\n\n' : '') + text;
                } else {
                  input.value = text;
                }
            }
        })
        .catch(() => {
            alert('[Wiki] Data Fetching Error.');
        });
      }

      function fetchMetaphorpsum() {
        fetch('http://metaphorpsum.com/sentences/1', {
            method: 'GET',
        })
        .then(response => response.text())
        .then(data => {
            text = data.trim();
            if (text) {
                if (appendCheckbox.checked) {
                  input.value += (input.value ? '\n\n' : '') + text;
                } else {
                  input.value = text;
                }
            }
        })
        .catch(() => {
            alert('[Metaphorpsum] Data Fetching Error.');
        });
      }

      saveButton.addEventListener('click', saveSettings);
      function saveSettings() {
        localStorage.setItem('sle_text', input.value);
        localStorage.setItem('sle_color_task', colorTaskCheckbox.checked);
        localStorage.setItem('sle_color_task_letters', colorTaskLettersInput.value);
        localStorage.setItem('sle_color_task_colors', colorInput.value);
        localStorage.setItem('sle_show_text', showTextCheckbox.checked);
        localStorage.setItem('sle_show_table', showTableCheckbox.checked);
        localStorage.setItem('sle_speed', speedInput.value);
        localStorage.setItem('sle_append_text', '' + appendCheckbox.checked);
        localStorage.setItem('sle_difficulty', difficultySelect.value);
      }

      resetButton.addEventListener('click', resetSettings);
      function resetSettings() {
        if (confirm('Are you sure you want to reset the settings?')) {
            localStorage.removeItem('sle_text');
            localStorage.removeItem('sle_color_task');
            localStorage.removeItem('sle_color_task_letters');
            localStorage.removeItem('sle_color_task_colors');
            localStorage.removeItem('sle_show_text');
            localStorage.removeItem('sle_show_table');
            localStorage.removeItem('sle_speed');
            localStorage.removeItem('sle_append_text');
            localStorage.removeItem('sle_difficulty');
            localStorage.removeItem('sle_theme');
            location.reload();
        }
      }

      function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
          }
      }

      function shuffleLetters(text) {
        const sentences = text.split('\n');
        const r = [];
        for (const sentence of sentences) {
            const words = sentence.split(/\s+/);
            const currentSentence = [];
            let skipWord = false;
            for (const word of words) {
                if (word[0] == word[0].toUpperCase() || /\d|\'/.test(word)) {
                    skipWord = true;
                }
                if (difficultySelect.value == "no") {
                  skipWord = true;
                }
                if ((difficultySelect.value == "easy" && word.length > 3 || difficultySelect.value != "easy") && (skipWord == false || difficultySelect.value == 'very-hard')) {
                    const wordParts = word.split(/\-/);
                    let newWord = [];
                    for (const wordPart of wordParts) {
                      const m = (difficultySelect.value == "hard" || difficultySelect.value == "very-hard") ? 0 : (difficultySelect.value == "medium" ? 1 : Math.floor(wordPart.length / 3));
                      const chars = [];
                      for (const c of wordPart) {
                          if (/^[a-zA-Z]$/.test(c)) {
                              chars.push(c);
                          }
                      }
                      const firstLetters = chars.slice(0, m);
                      const midLetters = chars.slice(m, chars.length - m);
                      const lastLetters = chars.slice(chars.length - m);
                      const origMidLetters = [...midLetters];
                      const uniqueMid = new Set(origMidLetters).size;
                      while (uniqueMid > 1 && midLetters.toString() == origMidLetters.toString()) {
                          shuffleArray(midLetters);
                      }
                      const allLetters = [...firstLetters, ...midLetters, ...lastLetters];
                      let newWordPart = [];
                      let i = 0;
                      for (const c of wordPart) {
                          if (/^[a-zA-Z]$/.test(c)) {
                            newWordPart.push(allLetters[i]);
                            i++;
                          } else {
                            newWordPart.push(c);
                          }
                      }
                      newWord.push(newWordPart.join(""));
                    }
                    currentSentence.push(newWord.join('-'));
                } else {
                    currentSentence.push(word);
                    skipWord = false;
                }
                if (word.indexOf('.') >= 0) {
                    skipWord = true;
                }
            }
            r.push(currentSentence);
        }
        return r.map(sentence => sentence.join(' ')).join('\n');
      }

      function formatSeconds(seconds) {
        if (typeof seconds !== 'number' || seconds < 0) {
            return '00:00:00';
        }
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        const formatNumber = (num) => num < 10 ? `0${num}` : num;
        return `${formatNumber(hours)}:${formatNumber(minutes)}:${formatNumber(remainingSeconds)}`;
      }

      function generateColorPalette(n) {
        const colors = [];
        function isTooDarkOrLight(r, g, b) {
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance < 0.1 || luminance > 0.9;
        }
        for (let i = 0; i < n; i++) {
            let r, g, b, color;
            do {
                r = Math.floor(Math.random() * 256);
                g = Math.floor(Math.random() * 256);
                b = Math.floor(Math.random() * 256);
                
                color = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            } while (isTooDarkOrLight(r, g, b));
            colors.push(color);
        }
        return colors;
      }

      function startAnimation(continue_view = false) {
        const text = input.value.trim();
        if (!text) {
          alert('Please add text');
          return false;
        }

        let newDifficulty = difficultySelect.value;
        let singleLineText = textElement.textContent;
        if (continue_view) {
          singleLineText = textElement.innerHTML;
        }
        else if (!lastPosition || text.length != prevLength || newDifficulty != prevDifficulty) {
          singleLineText = shuffleLetters(text.replace(/\n/g, ' ').trim());
        }

        if (continue_view == false && colorTaskCheckbox.checked) {
          let newPalleteSize = parseInt(colorTaskLettersInput.value, 10);

          let preserveValues = colorInput.value.split('\n');
          let preserveMap = new Map();
          let preserveLetters = [];
          for (let x of preserveValues) {
            let x_splitted = x.split(/\s+/);
            if (x_splitted.length >= 2) {
              for (let letter of x_splitted[0].toLowerCase()) {
                preserveLetters.push(letter);
                preserveMap.set(letter, [...x_splitted.slice(1)].join(' '));
              }
            }
          }

          if (currentPallete.size < newPalleteSize || colorInput.value != prevColorInputValue) {
            let paletteColors = generateColorPalette(newPalleteSize);
            let letters = currentPalleteList.slice();

            for (let x of preserveLetters) {
              if (letters.length < newPalleteSize && singleLineText.indexOf(x) >= 0) {
                let currentLetter = x.toLowerCase();
                const currentLetterColor = preserveMap.get(currentLetter);
                if (letters.includes(currentLetter) == false && currentLetterColor) {
                  letters.push(currentLetter);
                }
              }
            }
            for (let i = 0, j = 0; i < singleLineText.length && letters.length < newPalleteSize; ++i) {
              let currentLetter = singleLineText[i].toLowerCase();
              const currentLetterColor = preserveMap.get(currentLetter);
              if (letters.includes(currentLetter) == false && currentLetterColor) {
                letters.push(currentLetter);
              }
            }
            for (let i = 0, j = 0; i < singleLineText.length && j < paletteColors.length && letters.length < newPalleteSize; ++i) {
              let currentLetter = singleLineText[i].toLowerCase();
              if (/^[a-zA-Z]$/.test(currentLetter) && letters.includes(currentLetter) == false) {
                letters.push(currentLetter);
                ++j;
              }
            }
            letters.sort();
            let j = 0;
            for (let currentLetter of letters) {
              if (currentPallete.get(currentLetter) == null) {
                if (preserveMap.get(currentLetter) != null) {
                  currentPallete.set(currentLetter, preserveMap.get(currentLetter));
                  currentPalleteList.push(currentLetter);
                }
                else {
                  currentPallete.set(currentLetter, paletteColors[j]);
                  currentPalleteList.push(currentLetter);
                  ++j;
                }
              }
            }
          }
          currentPalleteList.reverse();
          for (let x of currentPalleteList.slice()) {
            if (currentPallete.size > newPalleteSize) {
              if (preserveMap.get(x) == null) {
                currentPallete.delete(x);
                currentPalleteList.splice(currentPalleteList.indexOf(x), 1);
              }
            }
            else {
              break;
            }
          }
          currentPalleteList.sort((a, b) => (preserveLetters.indexOf(a) - preserveLetters.indexOf(b)));
          currentPalleteList.reverse();
          for (let x of currentPalleteList.slice()) {
            if (currentPallete.size > newPalleteSize) {
              currentPallete.delete(x);
              currentPalleteList.splice(currentPalleteList.indexOf(x), 1);
            }
            else {
              break;
            }
          }
          currentPalleteList.sort();

          let newText = '';
          for (let i = 0; i < singleLineText.length; ++i) {
            let currentLetter = singleLineText[i].toLowerCase();
            let currentColor = currentPallete.get(currentLetter);
            if (currentColor != null) {
              newText = newText.concat(`<span style="background-color:${currentColor};color:${currentColor};" class="span-in-marquee">${singleLineText[i]}</span>`);
            }
            else {
              newText = newText.concat(singleLineText[i]);
            }
          }
          singleLineText = newText;
          colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
        }
        else if (continue_view == false && !colorTaskCheckbox.checked) {
          colorsInfo.style.display = 'none';
        }

        let currentPalleteString = '';
        if (continue_view == false) {
          let g = 0;
          for (let k of currentPalleteList) {
            let v = currentPallete.get(k);
            k = k.toUpperCase();
            currentPalleteString = currentPalleteString.concat(`${k}<span style="background-color:${v};color:${v};cursor:pointer;" class="span-in-marquee" onclick="javascript:changeColor(this)">${k}</span>`);
            ++g;
            if (g !== 0 && g % 5 == 0) {
              currentPalleteString = currentPalleteString.concat('<br><br>');
            }
            else {
              currentPalleteString = currentPalleteString.concat('  ');
            }
          }
        }

        textElement.innerHTML = singleLineText;

        const oneStepSize = 2;
        const containerWidth = Math.ceil(container.getBoundingClientRect().width);
        const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
        const startPosition = containerWidth;
        const endPosition = -textWidth;
        const stepTime = Math.max(1, parseInt(speedInput.value, 10));
        startTime = Date.now();
        lastTime = startTime;
        if (continue_view == false) {
          durationInfo.innerHTML = 'Target time: ' + formatSeconds(Math.floor(stepTime * (startPosition - endPosition) / 1000 / oneStepSize));
          colorsInfo.innerHTML = currentPalleteString;
        }

        if (!lastPosition) {
          textElement.style.left = startPosition + 'px';
          lastPosition = startPosition;
        } else {
          textElement.style.left = lastPosition + 'px';
        }

        let prevLastPosition = lastPosition;

        prevLength = text.length;
        prevDifficulty = newDifficulty;
        prevColorInputValue = colorInput.value;

        let flag = continue_view;
        let curStartTime = continue_view ? startTime : Date.now();
        if (flag) {
          colorsInfo.style.display = 'none';
        }

        function animate() {
          const currentLeft = parseInt(textElement.style.left, 10) - oneStepSize;

          lastTime = Date.now();
          let curStepTime = (lastTime - startTime) / (prevLastPosition - currentLeft);
          if (flag) {
            let viewStepTime = Math.floor(curStepTime * 10) / 10;
            durationInfo.innerHTML = formatSeconds(Math.floor(viewStepTime * (currentLeft - endPosition) / 1000));
          }
          else if (lastTime - curStartTime >= 3000) {
            flag = true;
            colorsInfo.style.display = 'none';
          }

          if (currentLeft <= endPosition) {
            textElement.style.left = endPosition + 'px';
            clearTimeout(animationId);
            animationId = null;
            startPauseButton.textContent = 'Start';
            startPauseButton.classList.remove('pause');
            durationInfo.style.display = 'none';
            lastPosition = null;
            inputContainer.style.display = '';
            otherSettingsContainer.style.display = '';
          } else {
            textElement.style.left = currentLeft + 'px';
            lastPosition = currentLeft;
            if (animationId) {
              animationId = setTimeout(animate, stepTime);
            }
          }
        }

        animationId = setTimeout(animate, stepTime);
        return true;
      }

      function startView(continue_view = false) {
        if (startAnimation(continue_view)) {
            backButton.disabled = false;
            forwardButton.disabled = false;
            updateColorsButton.disabled = false;
            startPauseButton.textContent = 'Pause';
            startPauseButton.classList.add('pause');
            inputContainer.style.display = 'none';
            otherSettingsContainer.style.display = 'none';
            durationInfo.style.display = '';
          }
      }

      function pauseView() {
        if (animationId) {
          clearTimeout(animationId);
          animationId = null;
          startPauseButton.textContent = 'Start';
          startPauseButton.classList.remove('pause');
          inputContainer.style.display = '';
          otherSettingsContainer.style.display = '';
          durationInfo.style.display = 'none';
          if (colorTaskCheckbox.checked) {
            colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
          }
        }
      }

      function stopView() {
        const containerWidth = Math.ceil(container.getBoundingClientRect().width);
        if (animationId) {
          clearTimeout(animationId);
          animationId = null;
        }
        startPauseButton.textContent = 'Start';
        startPauseButton.classList.remove('pause');
        textElement.style.left = containerWidth + 'px';
        lastPosition = null;
        inputContainer.style.display = '';
        otherSettingsContainer.style.display = '';
        durationInfo.style.display = 'none';
        colorsInfo.style.display = 'none';
        currentPallete.clear();
        currentPalleteList = [];
        backButton.disabled = true;
        forwardButton.disabled = true;
        updateColorsButton.disabled = true;
        startTime = null;
        lastTime = null;
        prevLength = 0;
      }

      startPauseButton.addEventListener('click', function() {
        if (animationId) {
          pauseView();
        } else {
          startView();
        }
      });

      stopButton.addEventListener('click', function() {
        stopView();
      });

    });

  </script>
</body>
</html>