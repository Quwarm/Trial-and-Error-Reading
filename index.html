<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trial and Error Reading</title>
  <link rel="icon" type="image/png" href="favicon.png" author="meaicon" />
  <style>
    body {
      font-family: Arial, sans-serif;
      margin: 0;
      padding: 20px;
      transition: background-color 0.3s, color 0.3s;
    }

    span { unicode-bidi: embed; }

    .container {
      max-width: 768px;
      margin: 0 auto;
    }

    #input-container, #marquee-container, #control-container, #other-settings-container {
      margin-bottom: 20px;
      text-align: center;
    }

    label {
      font-weight: bold;
      display: block;
    }

    #marquee-input {
      width: 100%;
      min-height: 300px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #color-input {
      width: 100%;
      min-height: 100px;
      padding: 10px;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
    }

    #delay-input {
      width: 100px;
      padding: 5px;
      font-size: 16px;
      text-align: center;
    }

    #marquee-container {
      width: 100%;
      height: 60px;
      overflow: hidden;
      position: relative;
      border: 2px solid;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      direction: ltr;
    }

    #marquee-text {
      position: absolute;
      white-space: nowrap;
      font-size: 42px;
      line-height: 60px;
      text-align: right;
    }

    button {
      padding: 10px 20px;
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    #colors-info {
      font-size: 22px;
      font-weight: bold;
    }

    #start-pause-button, #stop-button {
      background-color: rgb(25, 135, 84);
      color: white;
      min-width: 100px;
    }

    #start-pause-button.pause {
      background-color: rgb(218, 104, 11);
    }

    #start-pause-button:hover:not(.pause) {
      background-color: rgb(21, 115, 71);
    }

    #start-pause-button.pause:hover {
      background-color: rgb(194, 93, 10);
    }

    #stop-button {
      background-color: rgb(187, 45, 59);
    }

    #stop-button:hover {
      background-color: rgb(180, 25, 46);
    }

    #theme-button, #color-boxes-theme-button {
      background-color: rgb(11, 166, 197);
      color: white;
    }

    #theme-button:hover, #color-boxes-theme-button:hover {
      background-color: rgb(9, 130, 153);
    }

    #update-colors-button {
      font-size: 20px;
    }

    body.light #back-button, body.light #forward-button, body.light #update-colors-button {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
      display: inline-block;
      min-width: 70px;
    }

    body.light #back-button:hover, body.light #forward-button:hover, body.light #update-colors-button:hover {
      background-color: rgb(210, 210, 210);
      color: rgb(0, 0, 0);
    }

    body.light #back-button:disabled, body.light #forward-button:disabled, body.light #update-colors-button:disabled {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
    }

    body.dark #back-button, body.dark #forward-button, body.dark #update-colors-button {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
      display: inline-block;
      min-width: 70px;
    }

    body.dark #back-button:hover, body.dark #forward-button:hover, body.dark #update-colors-button:hover {
      background-color: rgb(80, 80, 80);
      color: rgb(255, 255, 255);
    }

    body.dark #back-button:disabled, body.dark #forward-button:disabled, body.dark #update-colors-button:disabled {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
    }

    #update-colors-button {
      margin: 5px 0px 20px 0px;
    }

    #dump-colors-button, #clear-button, #fetch-1-button, #fetch-2-button, #fetch-3-button, #load-from-file-button {
      background-color: rgb(108, 117, 125);
      color: white;
      display: inline-block;
    }

    #dump-colors-button:hover, #clear-button:hover, #fetch-1-button:hover, #fetch-2-button:hover, #fetch-3-button:hover, #load-from-file-button:hover {
      background-color: rgb(92, 99, 106);
    }

    .span-in-marquee {
      box-sizing: border-box;
      -moz-box-sizing: border-box;
      -webkit-box-sizing: border-box;
    }

    body.light.color-boxes-theme-1 .span-in-marquee {
      border: 1px dashed white;
    }

    body.dark.color-boxes-theme-1 .span-in-marquee {
      border: 1px dashed black;
    }

    body.light.color-boxes-theme-2 .span-in-marquee {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-2 .span-in-marquee {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-3 .span-in-marquee {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-3 .span-in-marquee {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-3 .span-in-marquee-for-word {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-3 .span-in-marquee-for-word {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-4 .span-in-marquee {
      border: 1px solid black;
    }

    body.dark.color-boxes-theme-4 .span-in-marquee {
      border: 1px solid white;
    }

    body.light.color-boxes-theme-4 .span-in-marquee-for-word {
      border: 2px solid black;
    }

    body.dark.color-boxes-theme-4 .span-in-marquee-for-word {
      border: 2px solid white;
    }

    body.light #marquee-text {
      letter-spacing: 1px;
      word-spacing: 1px;
    }

    body.dark #marquee-text {
      letter-spacing: 1px;
      word-spacing: 1px;
    }

    body.light.color-boxes-theme-2 #marquee-text {
      letter-spacing: 2px;
    }

    body.dark.color-boxes-theme-2 #marquee-text {
      letter-spacing: 2px;
    }

    body.light.color-boxes-theme-3 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 5px;
    }

    body.dark.color-boxes-theme-3 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 5px;
    }

    body.light.color-boxes-theme-4 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 15px;
    }

    body.dark.color-boxes-theme-4 #marquee-text {
      letter-spacing: 3px;
      word-spacing: 15px;
    }

    #delay-info {
      text-align: center;
    }

    #save-button {
      background-color: rgb(13, 110, 253);
      color: white;
      display: inline-block;
    }

    #save-button:hover {
      background-color: rgb(11, 94, 215);
    }

    #reset-button {
      background-color: rgb(33, 37, 41);
      color: white;
      display: inline-block;
    }

    #reset-button:hover {
      background-color: rgb(66, 70, 73);
    }

    select {
      padding: 8px 4px 8px 4px;
      text-align: center;
    }

    input[type=text], input[type=number], select {
      padding: 8px 4px 8px 4px;
      text-align: center;
    }

    input[type=range] {
      padding: 0px 4px 0px 4px;
      width: 225px;
      margin: auto auto;
      text-align: center;
    }

    input[type=checkbox] {
      -ms-transform: scale(1.4); /* IE */
      -moz-transform: scale(1.4); /* FF */
      -webkit-transform: scale(1.4); /* Safari and Chrome */
      -o-transform: scale(1.4); /* Opera */
      transform: scale(1.4);
      padding: 0px 4px 0px 4px;
    }

    body.light {
      background-color: #eeeeee;
      color: #333;
    }

    body.light #marquee-container {
      background-color: #efefef;
      border-color: #333;
    }

    body.light #marquee-input, body.light #color-input {
      background-color: #eeeeee;
      border-color: #333;
      color: black;
    }

    body.dark {
      background-color: #1a1a1a;
      color: #e0e0e0;
    }

    body.dark #marquee-container {
      background-color: #2a2a2a;
      border-color: #e0e0e0;
    }

    body.dark #marquee-input, body.dark #color-input {
      background-color: #2a2a2a;
      border-color: #e0e0e0;
      color: white;
    }

    #loop-button {
      margin-top: 3px;
    }

    body.light #loop-button {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
      display: inline-block;
      min-width: 70px;
    }

    body.light #loop-button.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark #loop-button {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
      display: inline-block;
      min-width: 70px;
    }

    body.dark #loop-button.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    @media (max-width: 600px) {
      button {
        width: 100%;
        margin-bottom: 10px;
      }
    }
  </style>
</head>
<body class="">
  <div class="container">

    <div id="marquee-container">
      <span id="marquee-text"></span>
    </div>

    <div id="control-container">
      <button id="back-button" disabled>&lt;&lt;</button>
      <button id="start-pause-button">Start</button>
      <button id="stop-button">Stop</button>
      <button id="forward-button" disabled>&gt;&gt;</button>
      <br>
      <button id="loop-button">Loop</button>
      <span id="duration-info" style="display: none;">0</span>
      <br><br>
      <span id="colors-info" style="display: none;"></span>
    </div>

    <div id="input-container">
      <label for="speed-input">Speed</label>
      <input type="number" id="speed-input" min="-1000" max="1000" value="10" style="display: none;">
      <input type="range" id="delay-slider" min="1" max="250" value="100">
      <input type="number" id="delay-info" min="-1000" max="1000" value="100">
      <br><br>
      <label>Difficulty of shuffling:
        <select id="difficulty-select">
          <option value="no">-</option>
          <option value="easy">Easy</option>
          <option value="medium">Medium</option>
          <option value="medium_plus">Medium+</option>
          <option value="hard">Hard</option>
          <option value="very-hard">Very Hard</option>
        </select>
      </label>
      <br>
      <button id="update-colors-button" disabled>&#8635;</button>
      <br>
      <label><input type="checkbox" id="color-task-checkbox" checked> Color encoder task</label>
      <br>
      <label for="color-task-letters" id="color-task-letters-label">Number of letters:
        <input type="number" id="color-task-letters" min="0" max="32" value="1">
      </label>
      <br>
      <button id="dump-colors-button">Dump colors above</button>
      <textarea id="color-input" placeholder="&lt;letter&gt; &lt;color&gt;&#13;&#10;a rgb(0, 0, 0)&#13;&#10;b red&#13;&#10;..."></textarea>
      <br><br>
      <label for="marquee-input">Text</label>
      <textarea id="marquee-input" placeholder="Enter text here"></textarea>
      <br>
      <button id="fetch-1-button">Load [one of the 22831 sentences]</button>
      <button id="fetch-2-button">Load [random wiki summary]</button>
      <button id="load-from-file-button">Load [from file]</button>
      <button id="fetch-3-button" style="display: none;">Load [random sentence from metaphorpsum]</button>
      <button id="clear-button">Clear</button>
      <br><br>
      <label><input type="checkbox" id="append-checkbox" checked> Append text after loading/fetching (uncheck to clear and append)</label>
      <br>
      <label><input type="checkbox" id="show-text-checkbox" checked> Show text</label>
      <br>
      <label><input type="checkbox" id="show-table-checkbox" checked> Show letters-colors info</label>
      <br><br>
      <button id="save-button">Save text and settings</button>
    </div>

    <div id="other-settings-container">
      <button id="color-boxes-theme-button">Toggle Marquee Text Block Theme</button>
      <button id="theme-button">Toggle Theme</button>
      <button id="reset-button">Reset settings</button>
    </div>

  </div>

  <div id="view-helper" style="display: none;"></div>

  <script>
    function loadScript(url, headOrBody = 'head') {
        var script = document.createElement("script");
        script.src = url;
        if (headOrBody == 'head') {
            document.head.appendChild(script);
        }
        else {
            document.body.appendChild(script);
        }
    }

    let animationId = null;
    let lastPosition = null;
    let startTime = null, lastTime = null;
    let currentPallete = new Map(), currentPalleteList = [];
    let prevHtmlValue = '', prevDifficulty = '', prevColorInputValue = '', isLooping = false;

    function changeColor(elem) {
      let text = prompt("Enter color:", elem.style.color);
      if (text) {
        currentPallete.set(elem.innerHTML.toLowerCase(), text);
        elem.style.color = text;
        elem.style.backgroundColor = text;
      }
    }

    function showWordInfo(shuffledWord, word) {
      alert(`${shuffledWord} -> ${word}`);
    }

    document.addEventListener('DOMContentLoaded', function() {
      loadScript('sentences.js?version=1');
      let sentences = [];
      const input = document.getElementById('marquee-input');
      const speedInput = document.getElementById('speed-input');
      const delaySlider = document.getElementById('delay-slider');
      const delayInfo = document.getElementById('delay-info');
      const durationInfo = document.getElementById('duration-info');
      const colorsInfo = document.getElementById('colors-info');
      const appendCheckbox = document.getElementById('append-checkbox');
      const difficultySelect = document.getElementById('difficulty-select');
      const textElement = document.getElementById('marquee-text');
      const inputContainer = document.getElementById('input-container');
      const otherSettingsContainer = document.getElementById('other-settings-container');
      const container = document.getElementById('marquee-container');
      const startPauseButton = document.getElementById('start-pause-button');
      const stopButton = document.getElementById('stop-button');
      const themeButton = document.getElementById('theme-button');
      const saveButton = document.getElementById('save-button');
      const resetButton = document.getElementById('reset-button');
      const clearButton = document.getElementById('clear-button');
      const fetch1Button = document.getElementById('fetch-1-button');
      const fetch2Button = document.getElementById('fetch-2-button');
      const fetch3Button = document.getElementById('fetch-3-button');
      const loadFromFileButton = document.getElementById('load-from-file-button');
      const colorTaskCheckbox = document.getElementById('color-task-checkbox');
      const colorTaskLettersLabel = document.getElementById('color-task-letters-label');
      const colorTaskLettersInput = document.getElementById('color-task-letters');
      const backButton = document.getElementById('back-button');
      const forwardButton = document.getElementById('forward-button');
      const colorInput = document.getElementById('color-input');
      const dumpColorsButton = document.getElementById('dump-colors-button');
      const showTextCheckbox = document.getElementById('show-text-checkbox');
      const showTableCheckbox = document.getElementById('show-table-checkbox');
      const updateColorsButton = document.getElementById('update-colors-button');
      const viewHelper = document.getElementById('view-helper');
      const colorBoxesThemeButton = document.getElementById('color-boxes-theme-button');
      const loopButton = document.getElementById('loop-button');

      const savedText = localStorage.getItem('sle_text');
      if (savedText) input.value = savedText;
      const savedDelay = localStorage.getItem('sle_speed');
      if (savedDelay) speedInput.value = savedDelay;
      delayInfo.value = 100 - speedInput.value;
      delaySlider.value = delayInfo.value;
      const savedTheme = localStorage.getItem('sle_theme') || 'dark';
      document.body.classList.add(savedTheme);
      const savedColorBoxesTheme = localStorage.getItem('sle_color_boxes_theme') || 'color-boxes-theme-1';
      document.body.classList.add(savedColorBoxesTheme);
      colorBoxesThemeButton.innerHTML += ' [' + (savedColorBoxesTheme.at(-1) || '1') + ']';
      const savedAppend = localStorage.getItem('sle_append_text') || 'true';
      appendCheckbox.checked = savedAppend !== 'false';
      const colorTask = localStorage.getItem('sle_color_task') || 'false';
      colorTaskCheckbox.checked = colorTask == 'true';
      colorTaskLettersLabel.style.display = colorTaskCheckbox.checked ? '' : 'none';
      dumpColorsButton.style.display = colorTaskCheckbox.checked ? '' : 'none';
      const colorInputValue = localStorage.getItem('sle_color_task_colors') || '';
      colorInput.value = colorInputValue;
      const colorTaskLetters = localStorage.getItem('sle_color_task_letters') || '1';
      colorTaskLettersInput.value = colorTaskLetters;
      const showTextBool = localStorage.getItem('sle_show_text') || 'true';
      showTextCheckbox.checked = showTextBool === 'true';
      input.style.display = showTextCheckbox.checked ? '' : 'none';
      const showTableBool = localStorage.getItem('sle_show_table') || 'true';
      showTableCheckbox.checked = showTableBool === 'true';
      colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
      colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
      dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
      const savedDifficulty = localStorage.getItem('sle_difficulty') || 'no';
      difficultySelect.value = savedDifficulty;
      isLooping = (localStorage.getItem('sle_loop') || 'false') == 'true';
      if (isLooping) {
        loopButton.classList.toggle('active');
      }

      loopButton.addEventListener('click', function() {
          isLooping = !isLooping;
          loopButton.classList.toggle('active');
      });

      updateColorsButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let continueViewParam = animationId != null;
          if (continueViewParam) {
            pauseView();
          }
          currentPallete.clear();
          currentPalleteList = [];
          let currentValue = colorInput.value;
          startView(false);
          pauseView();
          if (continueViewParam) {
            startView(true);
          }
        }
      });

      showTextCheckbox.addEventListener('click', function() {
        input.style.display = showTextCheckbox.checked ? '' : 'none';
      });
      
      showTableCheckbox.addEventListener('click', function() {
        colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
        colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
    });

      colorTaskCheckbox.addEventListener('click', function() {
        colorInput.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        dumpColorsButton.style.display = showTableCheckbox.checked && colorTaskCheckbox.checked ? '' : 'none';
        colorTaskLettersLabel.style.display = colorTaskCheckbox.checked ? '' : 'none';
      });

      dumpColorsButton.addEventListener('click', function() {
        let currentPalleteInfo = '';
        for (let k of currentPalleteList) {
          let v = currentPallete.get(k);
          k = k.toUpperCase();
          v = hexToRgb(v);
          currentPalleteInfo = currentPalleteInfo.concat(`${k} ${v}`);
          if (colorInput.value.indexOf(currentPalleteInfo) < 0) {
            let last = colorInput.value.slice(-1);
            if (last.length > 0 && last != '\n') {
              colorInput.value = colorInput.value.concat('\n');
            }
            colorInput.value = colorInput.value.concat(currentPalleteInfo).concat('\n');
          }
          currentPalleteInfo = '';
        }
      });

      speedInput.addEventListener('input', function() {
        delaySlider.value = 100 - this.value;
        delayInfo.value = delaySlider.value;
      });
      delayInfo.addEventListener('input', function() {
        speedInput.value = 100 - this.value;
        delaySlider.value = this.value;
      });
      delaySlider.addEventListener('input', function() {
        speedInput.value = 100 - this.value;
        delayInfo.value = this.value;
      });

      themeButton.addEventListener('click', function() {
        let themes = [
          "light",
          "dark",
        ];
        let currentThemeIndex = -1, i;
        for (i = 0; i < themes.length; ++i) {
          if (document.body.classList.contains(themes[i])) {
            currentThemeIndex = i;
            break;
          }
        }
        if (i < 0) {
          document.body.classList.add(themes[0]);
          localStorage.setItem('sle_theme', themes[0]);
          return;
        }
        for (i = 0; i < themes.length; ++i) {
          document.body.classList.remove(themes[i]);
        }
        let nextTheme = themes[(currentThemeIndex + 1) % themes.length];
        document.body.classList.add(nextTheme);
        localStorage.setItem('sle_theme', nextTheme);
      });

      colorBoxesThemeButton.addEventListener('click', function() {
        let themes = [
          "color-boxes-theme-1",
          "color-boxes-theme-2",
          "color-boxes-theme-3",
          "color-boxes-theme-4",
        ];
        let currentThemeIndex = -1, i;
        for (i = 0; i < themes.length; ++i) {
          if (document.body.classList.contains(themes[i])) {
            currentThemeIndex = i;
            break;
          }
        }
        if (i < 0) {
          document.body.classList.add(nextTheme);
          localStorage.setItem('sle_color_boxes_theme', nextTheme);
          colorBoxesThemeButton.innerHTML = colorBoxesThemeButton.innerHTML.slice(0, -4) + ' [' + (nextTheme.at(-1) || '1') + ']';
        return;
        }
        for (i = 0; i < themes.length; ++i) {
          document.body.classList.remove(themes[i]);
        }
        let nextTheme = themes[(currentThemeIndex + 1) % themes.length];
        document.body.classList.add(nextTheme);
        localStorage.setItem('sle_color_boxes_theme', nextTheme);
        colorBoxesThemeButton.innerHTML = colorBoxesThemeButton.innerHTML.slice(0, -4) + ' [' + (nextTheme.at(-1) || '1') + ']';
      });

      clearButton.addEventListener('click', function() {
        input.value = '';
      });

      fetch1Button.addEventListener('click', function() {
        loadSentence();
      });

      fetch2Button.addEventListener('click', function() {
        fetchWiki();
      });

      fetch3Button.addEventListener('click', function() {
        fetchMetaphorpsum();
      });

      loadFromFileButton.addEventListener('click', function() {
        uploadTextFile();
      });

      backButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let continueViewParam = animationId != null;
          if (continueViewParam) {
            pauseView();
          }
          const containerWidth = Math.ceil(container.getBoundingClientRect().width);
          const startPosition = containerWidth;
          const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
          const endPosition = -textWidth;
          lastPosition = Math.max(endPosition, Math.min(startPosition, parseInt(textElement.style.left, 10) + Math.floor(containerWidth / 2)));
          textElement.style.left = lastPosition + 'px';
          if (continueViewParam) {
            startView(true);
          }
        }
      });

      forwardButton.addEventListener('click', function() {
        if (lastPosition != null) {
          let continueViewParam = animationId != null;
          if (continueViewParam) {
            pauseView();
          }
          const containerWidth = Math.ceil(container.getBoundingClientRect().width);
          const startPosition = containerWidth;
          const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
          const endPosition = -textWidth;
          lastPosition = Math.max(endPosition, Math.min(startPosition, parseInt(textElement.style.left, 10) - Math.floor(containerWidth / 2)));
          textElement.style.left = lastPosition + 'px';
          if (continueViewParam) {
            startView(true);
          }
        }
      });

      function hexToRgb(hex) {
        if (!hex.match(/^#[a-f0-9]{3}$/i) && !hex.match(/^#[a-f0-9]{6}$/i)) {
          return hex;
        }
        var shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, function(m, r, g, b) {
          return r + r + g + g + b + b;
        });
        var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : hex;
      }

      function uploadTextFile(event) {
        let element = document.createElement('input');
        element.id = 'text_file_upload';
        element.type = 'file';
        element.onchange = function (event) {
            if (window.File && window.FileReader && window.FileList && window.Blob) {
                let f = event.target.files[0];
                if (f) {
                    let r = new FileReader;
                    r.addEventListener("load", (function(event) {
                        let text = event.target.result;
                        input.value += (input.value ? '\n\n' : '') + text;
                    }));
                    r.readAsText(f);
                }
            } else {
                alert("This functionality not supported by your browser.")
            }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
     }

      function loadSentence() {
        if (sentences.length == 0) {
            try {
              sentences = getSentences();
            }
            catch(err) {
              sentences = [];
              console.log(err);
            }
        }
        if (sentences.length == 0) {
            alert('[Sentences.js] Sentences not found!');
            return;
        }
        let text = sentences[Math.floor(Math.random() * sentences.length)];
        if (text) {
            if (!text.endsWith('.') && !text.endsWith('?') && !text.endsWith('!') && !text.endsWith(',')) {
                text += '.';
            }
            if (appendCheckbox.checked) {
                input.value += (input.value ? '\n\n' : '') + text;
            } else {
                input.value = text;
            }
        }
      }

      function fetchWiki() {
        fetch('https://en.wikipedia.org/api/rest_v1/page/random/summary', {
            method: 'GET',
            accept: "application/problem+json"
        })
        .then(response => response.text())
        .then(data => {
            data = JSON.parse(data);
            text = data['extract'];
            text = text.trim();
            if (text) {
                if (appendCheckbox.checked) {
                  input.value += (input.value ? '\n\n' : '') + text;
                } else {
                  input.value = text;
                }
            }
        })
        .catch(() => {
            alert('[Wiki] Data Fetching Error.');
        });
      }

      function fetchMetaphorpsum() {
        fetch('http://metaphorpsum.com/sentences/1', {
            method: 'GET',
        })
        .then(response => response.text())
        .then(data => {
            text = data.trim();
            if (text) {
                if (appendCheckbox.checked) {
                  input.value += (input.value ? '\n\n' : '') + text;
                } else {
                  input.value = text;
                }
            }
        })
        .catch(() => {
            alert('[Metaphorpsum] Data Fetching Error.');
        });
      }

      saveButton.addEventListener('click', saveSettings);
      function saveSettings() {
        localStorage.setItem('sle_text', input.value);
        localStorage.setItem('sle_color_task', colorTaskCheckbox.checked);
        localStorage.setItem('sle_color_task_letters', colorTaskLettersInput.value);
        localStorage.setItem('sle_color_task_colors', colorInput.value);
        localStorage.setItem('sle_show_text', showTextCheckbox.checked);
        localStorage.setItem('sle_show_table', showTableCheckbox.checked);
        localStorage.setItem('sle_speed', speedInput.value);
        localStorage.setItem('sle_append_text', '' + appendCheckbox.checked);
        localStorage.setItem('sle_difficulty', difficultySelect.value);
        localStorage.setItem('sle_loop', isLooping);
      }

      resetButton.addEventListener('click', resetSettings);
      function resetSettings() {
        if (confirm('Are you sure you want to reset the settings?')) {
            localStorage.removeItem('sle_text');
            localStorage.removeItem('sle_color_task');
            localStorage.removeItem('sle_color_task_letters');
            localStorage.removeItem('sle_color_task_colors');
            localStorage.removeItem('sle_show_text');
            localStorage.removeItem('sle_show_table');
            localStorage.removeItem('sle_speed');
            localStorage.removeItem('sle_append_text');
            localStorage.removeItem('sle_difficulty');
            localStorage.removeItem('sle_theme');
            localStorage.removeItem('sle_color_boxes_theme');
            localStorage.removeItem('sle_loop');
            location.reload();
        }
      }

      function shuffleArray(array) {
          for (let i = array.length - 1; i > 0; i--) {
              const j = Math.floor(Math.random() * (i + 1));
              [array[i], array[j]] = [array[j], array[i]];
          }
      }

      function isLetter(ch) {
        try {
          if (/^[a-zA-Z]+$/.test(ch)) {
            return true;
          }
          if (ch.toLowerCase() !== ch.toUpperCase()) {
            return true;
          }
          if (/^\p{L}+$/u.test(ch)) {
            return true;
          }
        }
        catch (err) {
          console.log(`${err}`);
        }
        return false;
      }

      function shuffleLetters(editedText, helperText, bShuffle, translateFunction = null) {
        const escapeWord = function (word) {
          return word.replace(/\\/g, "").replace(/\"/g, "").replace(/\'/g, "\\\'");
        };
        const sentences = editedText.split('\n');
        const helperSentences = helperText.split('\n');
        const r = [];
        for (let slS = 0; slS < sentences.length; ++slS) {
            const sentence = sentences[slS];
            const helperSentence = helperSentences[slS];
            const words = sentence.split(/\s+/);
            const helperWords = helperSentence.split(/\s+/);
            const currentSentence = [];
            let skipWord = false;
            for (let slW = 0; slW < words.length; ++slW) {
                const word = words[slW];
                const helperWord = helperWords[slW];
                if (word.length == 0) {
                  continue;
                }
                let resultWord = '';
                if (/^[^a-zA-Z]*[A-Z]/.test(word) || /[0-9]|\'/.test(word)) {
                  skipWord = true;
                }
                try {
                  if (/\u2032|\u2033|\u2034|\u2057|\u2019|\u0060|\u00B4|\uFF40|\u02F4/u.test(word)) {
                    skipWord = true;
                  }
                  if (/^[^\p{L}]*\p{Lu}/u.test(word) || /\p{N}/u.test(word)) {
                    skipWord = true;
                  }
                }
                catch (err) {
                  console.log(err);
                }
                if (difficultySelect.value == "no") {
                  skipWord = true;
                }
                if (bShuffle && (difficultySelect.value == "easy" && word.length > 3 || difficultySelect.value != "easy") && (skipWord == false || difficultySelect.value == "very-hard")) {
                    const wordParts = word.split(/\-/);
                    let lettersList = [];
                    for (const wordPart of wordParts) {
                      const m = (difficultySelect.value == "hard" || difficultySelect.value == "very-hard") ? 0 : (difficultySelect.value == "medium" || difficultySelect.value == "medium_plus" ? 1 : Math.floor(wordPart.length / 3));
                      const chars = [];
                      for (const c of wordPart) {
                          if (isLetter(c)) {
                              chars.push(c);
                          }
                      }
                      const firstLetters = chars.slice(0, m);
                      const midLetters = chars.slice(m, chars.length - (difficultySelect.value == "medium_plus" ? 0 : m));
                      const lastLetters = chars.slice(chars.length - (difficultySelect.value == "medium_plus" ? 0 : m));
                      const origMidLetters = [...midLetters];
                      const uniqueMid = new Set(origMidLetters).size;
                      while (uniqueMid > 1 && midLetters.toString() == origMidLetters.toString()) {
                          shuffleArray(midLetters);
                      }
                      const allLetters = [...firstLetters, ...midLetters, ...lastLetters];
                      let lettersListPart = [];
                      let i = 0;
                      for (const c of wordPart) {
                          if (isLetter(c)) {
                            lettersListPart.push(allLetters[i]);
                            i++;
                          } else {
                            lettersListPart.push(c);
                          }
                      }
                      lettersList.push(lettersListPart.join(""));
                    }
                    resultWord = lettersList.join('-');
                } else {
                    resultWord = word;
                }
                let result = resultWord;
                if (translateFunction) {
                  result = '';
                  for (let i = 0; i < resultWord.length; ++i) {
                    result = result.concat(translateFunction(resultWord[i]));
                  }
                  if (difficultySelect.value !== "no") {
                    const helperWordEscaped = escapeWord(helperWord);
                    const shuffledWordEscaped = escapeWord(resultWord);
                    result = `<span class="span-in-marquee-for-word" onclick="javascript:showWordInfo('${shuffledWordEscaped}', '${helperWordEscaped}')" style="cursor:pointer;">${result}</span>`;
                  }
                  else {
                    result = `<span class="span-in-marquee-for-word">${result}</span>`;
                  }
                }
                currentSentence.push(result);
                skipWord = false;
                if (word.indexOf('.') >= 0) {
                    skipWord = true;
                }
            }
            r.push(currentSentence);
        }
        return r.map(sentence => sentence.join(' ')).join('\n');
      }

      function formatSeconds(seconds) {
        if (typeof seconds !== 'number' || seconds < 0) {
            return '00:00:00';
        }
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const remainingSeconds = Math.floor(seconds % 60);
        const formatNumber = (num) => num < 10 ? `0${num}` : num;
        return `${formatNumber(hours)}:${formatNumber(minutes)}:${formatNumber(remainingSeconds)}`;
      }

      function generateColorPalette(n) {
        const colors = [];
        function isTooDarkOrLight(r, g, b) {
            const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
            return luminance < 0.1 || luminance > 0.9;
        }
        for (let i = 0; i < n; i++) {
            let r, g, b, color;
            do {
                r = Math.floor(Math.random() * 256);
                g = Math.floor(Math.random() * 256);
                b = Math.floor(Math.random() * 256);
                
                color = `#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`;
            } while (isTooDarkOrLight(r, g, b));
            colors.push(color);
        }
        return colors;
      }

      function startAnimation(continueViewParam = false) {
        let htmlValue = input.value.replace(/\s+/g, ' ').trim();
        try {
          htmlValue = htmlValue.replace(/\p{Z}+/ug, ' ');
          htmlValue = htmlValue.replace(/\p{C}+/ug, '');
        }
        catch (err) {
          console.log(err);
        }
        if (!htmlValue) {
          alert('Please add text');
          return false;
        }

        viewHelper.innerHTML = htmlValue;
        let textFromHtmlValue = viewHelper.textContent || viewHelper.innerText || "";
        let singleLineHtml = textElement.innerHTML;
        let singleLineText = textElement.textContent || textElement.innerText || "";

        let palleteChanged = false;

        if (continueViewParam == false && colorTaskCheckbox.checked) {
          palleteChanged = true;

          let newPalleteSize = parseInt(colorTaskLettersInput.value, 10);

          let preserveValues = colorInput.value.split('\n');
          let preserveMap = new Map();
          let preserveLetters = [];
          for (let x of preserveValues) {
            let xSplitted = x.split(/\s+/);
            if (xSplitted.length >= 2) {
              for (let letter of xSplitted[0].toLowerCase()) {
                preserveLetters.push(letter);
                preserveMap.set(letter, [...xSplitted.slice(1)].join(' '));
              }
            }
          }

          if (currentPallete.size < newPalleteSize || colorInput.value != prevColorInputValue) {
            let paletteColors = generateColorPalette(newPalleteSize);
            let letters = currentPalleteList.slice();

            for (let x of preserveLetters) {
              if (letters.length < newPalleteSize && textFromHtmlValue.indexOf(x) >= 0) {
                let currentLetter = x.toLowerCase();
                const currentLetterColor = preserveMap.get(currentLetter);
                if (letters.includes(currentLetter) == false && currentLetterColor) {
                  letters.push(currentLetter);
                }
              }
            }
            for (let i = 0, j = 0; i < textFromHtmlValue.length && letters.length < newPalleteSize; ++i) {
              let currentLetter = textFromHtmlValue[i].toLowerCase();
              const currentLetterColor = preserveMap.get(currentLetter);
              if (letters.includes(currentLetter) == false && currentLetterColor) {
                letters.push(currentLetter);
              }
            }
            for (let i = 0, j = 0; i < textFromHtmlValue.length && j < paletteColors.length && letters.length < newPalleteSize; ++i) {
              let currentLetter = textFromHtmlValue[i].toLowerCase();
              if (isLetter(currentLetter) && letters.includes(currentLetter) == false) {
                letters.push(currentLetter);
                ++j;
              }
            }
            letters.sort();
            let j = 0;
            for (let currentLetter of letters) {
              if (currentPallete.get(currentLetter) == null) {
                if (preserveMap.get(currentLetter) != null) {
                  currentPallete.set(currentLetter, preserveMap.get(currentLetter));
                  currentPalleteList.push(currentLetter);
                }
                else {
                  currentPallete.set(currentLetter, paletteColors[j]);
                  currentPalleteList.push(currentLetter);
                  ++j;
                }
              }
            }
          }
          currentPalleteList.reverse();
          for (let x of currentPalleteList.slice()) {
            if (currentPallete.size > newPalleteSize) {
              if (preserveMap.get(x) == null) {
                currentPallete.delete(x);
                currentPalleteList.splice(currentPalleteList.indexOf(x), 1);
              }
            }
            else {
              break;
            }
          }
          currentPalleteList.sort((a, b) => (preserveLetters.indexOf(a) - preserveLetters.indexOf(b)));
          currentPalleteList.reverse();
          for (let x of currentPalleteList.slice()) {
            if (currentPallete.size > newPalleteSize) {
              currentPallete.delete(x);
              currentPalleteList.splice(currentPalleteList.indexOf(x), 1);
            }
            else {
              break;
            }
          }
          currentPalleteList.sort();
          colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
        }
        else if (continueViewParam == false && !colorTaskCheckbox.checked) {
          colorsInfo.style.display = 'none';
        }

        let currentPalleteString = '';
        if (continueViewParam == false) {
          let g = 0;
          for (let k of currentPalleteList) {
            let v = currentPallete.get(k);
            k = k.toUpperCase();
            currentPalleteString = currentPalleteString.concat(`${k}<span style="background-color:${v};color:${v};cursor:pointer;" class="span-in-marquee" onclick="javascript:changeColor(this)">${k}</span>`);
            ++g;
            if (g !== 0 && g % 5 == 0) {
              currentPalleteString = currentPalleteString.concat('<br><br>');
            }
            else {
              currentPalleteString = currentPalleteString.concat('  ');
            }
          }
        }

        if (palleteChanged || lastPosition == null || prevColorTaskCheckboxChecked != colorTaskCheckbox.checked || colorTaskCheckbox.checked && prevColorInputValue != colorInput.value || prevHtmlValue != textFromHtmlValue || prevDifficulty != difficultySelect.value) {
          let translateFunction = null;
          if (colorTaskCheckbox.checked) {
            translateFunction = function (symbol) {
              let currentSymbol = symbol.toLowerCase();
              let currentColor = currentPallete.get(currentSymbol);
              if (currentColor != null) {
                return `<span style="background-color:${currentColor};color:${currentColor};" class="span-in-marquee">${symbol}</span>`;
              }
              else {
                return symbol;
              }
            };
          }
          else {
            translateFunction = function (symbol) {
              return symbol;
            };
          }
          const bShuffle = (lastPosition == null || prevHtmlValue != textFromHtmlValue || prevDifficulty != difficultySelect.value);
          singleLineHtml = shuffleLetters(
            bShuffle ? textFromHtmlValue : singleLineText,
            textFromHtmlValue,
            bShuffle,
            translateFunction);
        }

        textElement.innerHTML = singleLineHtml;

        const containerWidth = Math.ceil(container.getBoundingClientRect().width);
        const textWidth = Math.ceil(textElement.getBoundingClientRect().width);
        const startPosition = containerWidth;
        const endPosition = -textWidth;
        const oneStepSize = delayInfo.value > 100 ? ((delayInfo.value - 100) / 10 + 1) : 1;
        let stepTime = Math.max(0, Math.max(1, parseInt(speedInput.value, 10)));
        if (delayInfo.value < 20) {
          stepTime += (20 - Math.floor(delayInfo.value % 100)) * 20;
        }

        startTime = Date.now();
        lastTime = startTime;
        if (continueViewParam == false) {
          colorsInfo.innerHTML = currentPalleteString;
        }

        if (lastPosition == null) {
          lastPosition = startPosition;
        }
        textElement.style.left = lastPosition + 'px';
        let prevLastPosition = lastPosition;

        prevHtmlValue = textFromHtmlValue;
        prevDifficulty = difficultySelect.value;
        prevColorInputValue = colorInput.value;
        prevColorTaskCheckboxChecked = colorTaskCheckbox.checked;

        let flag = continueViewParam;
        let curStartTime = continueViewParam ? startTime : Date.now();
        if (flag) {
          colorsInfo.style.display = 'none';
        }

        function animate() {
          const currentLeft = parseInt(textElement.style.left, 10) - oneStepSize;

          lastTime = Date.now();
          let curStepTime = (lastTime - startTime) / Math.max(1e-9, prevLastPosition - currentLeft);
          if (!flag && lastTime - curStartTime >= 1000) {
            flag = true;
            colorsInfo.style.display = 'none';
          }
          let viewStepTime = Math.floor(curStepTime * 10) / 10;
          durationInfo.innerHTML = formatSeconds(Math.floor(viewStepTime * (currentLeft - endPosition) / 1000));

          if (currentLeft <= endPosition) {
            if (isLooping) {
              startTime = Date.now();
              textElement.style.left = startPosition + 'px';
              lastPosition = startPosition;
              prevLastPosition = lastPosition;
              if (animationId) {
                animationId = setTimeout(animate, stepTime);
              }
            }
            else {
              textElement.style.left = endPosition + 'px';
              clearTimeout(animationId);
              animationId = null;
              startPauseButton.textContent = 'Start';
              startPauseButton.classList.remove('pause');
              inputContainer.style.display = '';
              otherSettingsContainer.style.display = '';
              durationInfo.style.display = 'none';
              if (colorTaskCheckbox.checked) {
                colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
              }
              loopButton.style.display = '';
            }
          } else {
            textElement.style.left = currentLeft + 'px';
            lastPosition = currentLeft;
            if (animationId) {
              animationId = setTimeout(animate, stepTime);
            }
          }
        }

        animationId = setTimeout(animate, stepTime);
        return true;
      }

      function startView(continueViewParam = false) {
        if (startAnimation(continueViewParam)) {
            loopButton.style.display = 'none';
            backButton.disabled = false;
            forwardButton.disabled = false;
            updateColorsButton.disabled = false;
            startPauseButton.textContent = 'Pause';
            startPauseButton.classList.add('pause');
            inputContainer.style.display = 'none';
            otherSettingsContainer.style.display = 'none';
            durationInfo.style.display = '';
          }
      }

      function pauseView() {
        if (animationId) {
          clearTimeout(animationId);
          animationId = null;
          startPauseButton.textContent = 'Start';
          startPauseButton.classList.remove('pause');
          inputContainer.style.display = '';
          otherSettingsContainer.style.display = '';
          durationInfo.style.display = 'none';
          loopButton.style.display = '';
          if (colorTaskCheckbox.checked) {
            colorsInfo.style.display = showTableCheckbox.checked ? '' : 'none';
          }
        }
      }

      function stopView() {
        const containerWidth = Math.ceil(container.getBoundingClientRect().width);
        if (animationId) {
          clearTimeout(animationId);
          animationId = null;
        }
        startPauseButton.textContent = 'Start';
        startPauseButton.classList.remove('pause');
        textElement.style.left = containerWidth + 'px';
        lastPosition = containerWidth;
        inputContainer.style.display = '';
        otherSettingsContainer.style.display = '';
        durationInfo.style.display = 'none';
        colorsInfo.style.display = 'none';
        loopButton.style.display = '';
        backButton.disabled = true;
        forwardButton.disabled = true;
        updateColorsButton.disabled = true;
        startTime = null;
        lastTime = null;
      }

      startPauseButton.addEventListener('click', function() {
        if (animationId) {
          pauseView();
        } else {
          startView();
        }
      });

      stopButton.addEventListener('click', function() {
        stopView();
      });

    });

  </script>
</body>
</html>