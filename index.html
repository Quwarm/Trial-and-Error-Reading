<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Trial and Error Reading</title>
  <link rel="icon" type="image/png" href="favicon.png" />
  <script src="js/alphabets.js" type="text/javascript"></script>
  <script src="js/chart.js" type="text/javascript"></script>
  <script src="js/hammer.js" type="text/javascript"></script>
  <script src="js/chartjs-plugin-zoom.js" type="text/javascript"></script>
  <script src="sentences/merriam_webster.js" type="text/javascript"></script>
  <script src="sentences/wordsmyth1.js" type="text/javascript"></script>
  <script src="sentences/wordsmyth2.js" type="text/javascript"></script>
  <script src="sentences/wordsmyth3.js" type="text/javascript"></script>
  <link href="fonts/style.css" rel="stylesheet">
<style>
    :root {
      --background-color: #eeeeee;
      --text-color: #333;
      --container-background: #efefef;
      --border-color: rgb(90, 90, 90);
      --border-color-inv: #e0e0e0;
      --green-button-background: rgb(25, 135, 84);
      --green-button-hover: rgb(21, 115, 71);
      --purple-button-background: rgb(84, 25, 135);
      --purple-button-hover: rgb(71, 21, 115);
      --chocolate-button-background: rgb(102, 52, 46);
      --chocolate-button-hover: rgb(84, 43, 38);
      --dark-cyan-button-background: rgb(25, 103, 134);
      --dark-cyan-button-hover: rgb(21, 89, 116);
      --dark-blue-button-background: rgb(25, 48, 134);
      --dark-blue-button-hover: rgb(21, 42, 116);
      --orange-button-background: rgb(218, 104, 11);
      --orange-button-hover: rgb(194, 93, 10);
      --red-button-background: rgb(187, 45, 59);
      --red-button-hover: rgb(180, 25, 46);
      --cyan-button-background: rgb(11, 166, 197);
      --cyan-button-hover: rgb(9, 130, 153);
      --gray-button-background: rgb(190, 190, 190);
      --gray-button-text: rgb(0, 0, 0);
      --gray-button-hover: rgb(200, 200, 200);
      --gray-button-disabled-background: rgb(230, 230, 230);
      --gray-button-disabled-text: rgb(173, 173, 173);
      --blue-button-background: rgb(13, 110, 253);
      --blue-button-hover: rgb(11, 94, 215);
      --dark-button-background: rgb(55, 55, 55);
      --dark-button-hover: rgb(66, 70, 73);
    }

    canvas {
      user-select: none;
      -moz-user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
    }

    body.dark {
      --background-color: #1a1a1a;
      --text-color: #e0e0e0;
      --container-background: #2a2a2a;
      --border-color: #e0e0e0;
      --border-color-inv: rgb(90, 90, 90);
      --gray-button-background: rgb(90, 90, 90);
      --gray-button-text: rgb(255, 255, 255);
      --gray-button-hover: rgb(80, 80, 80);
      --gray-button-disabled-background: rgb(90, 90, 90);
      --gray-button-disabled-text: rgb(70, 70, 70);
    }

    body {
      font-size: 16px;
      font-family: 'Open Sans', sans-serif;
      font-weight: normal;
      font-style: normal;
      margin: 0;
      padding: 10px;
      background-color: var(--background-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
    }

    body button, body input, body select {
      font-family: inherit;
      font-weight: inherit;
      font-style: inherit;
    }

    body textarea {
      font-family: monospace;
    }

    h3 {
      font-size: 16px;
      font-weight: bold;
      padding: 8px 0px;
    }

    h4 {
      font-size: 16px;
      font-weight: normal;
      padding: 8px 0px;
    }

    label {
      display: block;
      padding: 8px 0px;
    }

    span {
      unicode-bidi: embed;
    }

    hr {
      height: 1px;
      border: 0;
    }

    body.light hr {
      background-color: rgb(200, 200, 200);
    }

    body.dark hr {
      background-color: rgb(90, 90, 90);
    }

    select,
    #font-input,
    input[type="number"],
    input[type="text"],
    input[type="range"] {
      text-align: center;
      vertical-align: middle;
    }

    input[type="checkbox"], input[type="radio"] {
      transform: scale(1.3);
      padding-left: 3px;
    }

    .rotate-1 {
      transform: rotate(1deg);
    }

    .rotate-2 {
      transform: rotate(2deg);
    }

    .rotate-181 {
      transform: rotate(181deg);
    }

    .rotate-182 {
      transform: rotate(182deg);
    }

    .rotate--1 {
      transform: rotate(-1deg);
    }

    .rotate--2 {
      transform: rotate(-2deg);
    }

    .rotate--181 {
      transform: rotate(-181deg);
    }

    .rotate--182 {
      transform: rotate(-182deg);
    }

    .rotate-180 {
      transform: rotate(180deg);
    }

    .rotate-90 {
      transform: rotate(90deg);
    }

    .rotate-270 {
      transform: rotate(270deg);
    }

    .mirror-x {
      transform: scaleX(-1);
    }

    .mirror-y {
      transform: scaleY(-1);
    }

    .mirror-xy {
      transform: scaleX(-1) scaleY(-1);
    }

    .ta-center {
      text-align: center;
    }

    .w50 {
      width: 50%;
      margin: 0 auto !important;
    }

    label > select, label > #font-input, label > input[type="text"] {
      width: 15%;
      vertical-align: middle;
    }

    label > input[type="number"] {
      width: 15%;
      vertical-align: middle;
    }

    label > span, label > button {
      display: inline-block;
      width: 15%;
      vertical-align: middle;
    }

    label input[type="checkbox"] + span, label input[type="radio"] + span {
      width: auto;
    }

    /* Margin */

    .tab-content * {
      margin: 1px;
    }

    #progress-display, #color-details {
      margin-top: 5px;
      margin-bottom: 5px;
    }

    /* Padding */

    button, .tab-button {
      padding: 10px 15px;
      min-height: 42px;
    }

    select, #font-input, input[type="text"], input[type="number"] {
      padding: 8px 0px;
    }

    #text-input, #color-input {
      padding: 5px;
    }

    kbd {
      padding: 1px 4px;
    }

    /* A tag */

    a {
      text-decoration: none;
      font-weight: bold;
    }

    body.light a {
      color: #aaa;
    }

    body.light a:hover {
      color: #555;
    }

    body.dark a {
      color: #555;
    }

    body.dark a:hover {
      color: #aaa;
    }

    /* Buttons */

    button {
      font-size: 16px;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s;
      margin: 2px;
      background-color: var(--gray-button-background);
      color: white;
    }

    button:active {
      transform: scale(0.99);
    }

    button:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    .green-button {
      background-color: var(--green-button-background);
    }

    .green-button:hover {
      background-color: var(--green-button-hover);
    }

    .purple-button {
      background-color: var(--purple-button-background);
    }

    .purple-button:hover {
      background-color: var(--purple-button-hover);
    }

    .chocolate-button {
      background-color: var(--chocolate-button-background);
    }

    .chocolate-button:hover {
      background-color: var(--chocolate-button-hover);
    }

    .dark-cyan-button {
      background-color: var(--dark-cyan-button-background);
    }

    .dark-cyan-button:hover {
      background-color: var(--dark-cyan-button-hover);
    }

    .dark-blue-button {
      background-color: var(--dark-blue-button-background);
    }

    .dark-blue-button:hover {
      background-color: var(--dark-blue-button-hover);
    }

    .orange-button {
      background-color: var(--orange-button-background);
    }

    .orange-button:hover {
      background-color: var(--orange-button-hover);
    }

    .red-button {
      background-color: var(--red-button-background);
    }

    .red-button:hover {
      background-color: var(--red-button-hover);
    }

    .cyan-button {
      background-color: var(--cyan-button-background);
    }

    .cyan-button:hover {
      background-color: var(--cyan-button-hover);
    }

    .blue-button {
      background-color: var(--blue-button-background);
    }

    .blue-button:hover {
      background-color: var(--blue-button-hover);
    }

    body.light .dark-button {
      background-color: var(--gray-button-background);
    }

    body.light .dark-button:hover {
      background-color: var(--gray-button-hover);
    }

    body.dark .dark-button {
      background-color: var(--dark-button-background);
    }

    body.dark .dark-button:hover {
      background-color: var(--dark-button-hover);
    }

    .gray-button {
      background-color: var(--gray-button-background);
      color: var(--gray-button-text);
    }

    .gray-button:hover {
      background-color: var(--gray-button-hover);
    }

    #play-pause-button {
      background-color: var(--green-button-background);
    }
    
    #play-pause-button:hover {
      background-color: var(--green-button-hover);
    }

    #play-pause-button.pause {
      background-color: var(--orange-button-background);
    }

    #play-pause-button.pause:hover {
      background-color: var(--orange-button-hover);
    }

    #play-pause-button:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    #stop-button {
      background-color: var(--red-button-background);
    }

    #stop-button:hover {
      background-color: var(--red-button-hover);
    }

    #stop-button:disabled {
      background-color: var(--gray-button-disabled-background);
      color: var(--gray-button-disabled-text);
    }

    body.light #loop-toggle {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
      min-width: 70px;
    }

    body.light #loop-toggle.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark #loop-toggle {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
      min-width: 70px;
    }

    body.dark #loop-toggle.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    /* Tabs */

    .container-items-in-center {
      text-align: center;
    }

    .tab-button {
      flex: 1;
      border: none;
      cursor: pointer;
      transition: background-color 0.3s;
    }

    body.light .tab-button {
      background-color: rgb(230, 230, 230);
      color: rgb(173, 173, 173);
    }

    body.light .tab-button.active {
      background-color: rgb(200, 200, 200);
      color: rgb(0, 0, 0);
    }

    body.dark .tab-button {
      background-color: rgb(90, 90, 90);
      color: rgb(70, 70, 70);
    }

    body.dark .tab-button.active {
      background-color: rgb(90, 90, 90);
      color: rgb(255, 255, 255);
    }

    .tab-content {
      display: none;
    }

    .tab-content.active {
      display: block;
    }

    #tab-navigation {
      display: flex;
      justify-content: space-around;
    }
    
    .with-rounded-border {
      border-radius: 10px;
      padding: 2px;
      border-width: 2px;
      border-style: solid;
    }

    body.light .with-rounded-border {
      border-color: rgb(200, 200, 200);
    }

    body.light .with-rounded-border.active {
      border-color: rgb(200, 200, 200);
    }

    body.dark .with-rounded-border {
      border-color: rgb(90, 90, 90);
    }

    body.dark .with-rounded-border.active {
      border-color: rgb(90, 90, 90);
    }

    /* By ID */

    #main-container.normal-size {
      max-width: 1000px;
      margin: 0 auto;
    }

    #main-container.max-size {
      max-width: 100%;
      margin: 0 auto;
    }

    #controls-container button {
      min-width: 100px;
    }

    #color-details {
      font-size: 22px;
    }

    #text-input, #color-input {
      width: 100%;
      font-size: 16px;
      resize: vertical;
      box-sizing: border-box;
      white-space: pre-wrap;
      word-wrap: break-word;
      background-color: var(--container-background);
      border-color: var(--border-color);
      color: var(--text-color);
    }

    #text-input {
      min-height: 300px;
    }

    #color-input {
      min-height: 150px;
    }

    #main-container.max-size #text-input {
      min-height: 600px;
    }

    #main-container.max-size #color-input {
      min-height: 300px;
    }

    /* kbd tags */

    kbd {
      border: 1px solid;
      border-radius: 3px;
      font-size: 12px;
      font-family: monospace;
    }

    body.light kbd {
      background-color: rgb(200, 200, 200);
      border-color: rgb(90, 90, 90);
      color: #333;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    body.dark kbd {
      background-color: rgb(60, 60, 60);
      border-color: rgb(200, 200, 200);
      color: #e0e0e0;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    /* Translations */

    .translation {
      border: 1px solid;
      border-radius: 3px;
      font-family: monospace;
      padding: 3px;
      margin: 10px 5px;
      display: inline-block;
    }

    body.light .translation {
      background-color: rgb(200, 200, 200);
      border-color: rgb(90, 90, 90);
      color: #333;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    body.dark .translation {
      background-color: rgb(60, 60, 60);
      border-color: rgb(200, 200, 200);
      color: #e0e0e0;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
    }

    #rot-n-language-info {
      width: 50%;
      margin: 0 auto;
    }

    /* Progress bar & Marquee */

    #progress-bar-container {
      width: 100%;
      height: 20px;
      background-color: var(--container-background);
      border: 1px solid var(--border-color);
      position: relative;
      cursor: pointer;
      margin-bottom: 18px;
    }

    #progress-bar {
      height: 100%;
      background-color: var(--green-button-background);
      width: 0%;
      transition: width 0.1s linear;
    }

    body.dark #progress-bar {
      background-color: var(--green-button-hover);
    }

    #marquee-container {
      width: 100%;
      height: 60px;
      position: relative;
      border: 1px solid var(--border-color);
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      background-color: var(--container-background);
      overflow: hidden;
    }

    #marquee-display {
      position: absolute;
      white-space: nowrap;
      line-height: 60px;
      text-align: right;
      overflow: hidden;
    }

    #settings-profile-select, #text-select {
      width: 27%;
      text-align: center;
    }
  
    #load-wiki-language-select, #rot-n-language-select {
      width: 16%;
      text-align: center;
    }

    #gemini-query-input {
      width: 50%;
    }

    #gemini-query-label {
      display: block;
      margin: 0 auto;
    }

    #voice-select {
      width: 50%;
      text-align: center;
    }

    /* Marquee themes */

    .marquee-letter-span[onclick], .marquee-word-span[onclick] {
      cursor: pointer;
      overflow: hidden;
    }

    .marquee-word-span {
      display: inline-block;
      vertical-align: top;
    }

    .marquee-letter-span {
      box-sizing: border-box;
      display: inline-block;
    }

    body.marquee-theme-2 .marquee-letter-span,
    body.marquee-theme-3 .marquee-letter-span,
    body.marquee-theme-4 .marquee-letter-span,
    body.marquee-theme-5 .marquee-letter-span {
      border-left: 1px solid var(--border-color-inv);
      border-right: 1px solid var(--border-color-inv);
    }

    body.marquee-theme-3 .marquee-word-span {
      border-left: 1px solid var(--border-color);
      border-right: 1px solid var(--border-color);
    }

    body.marquee-theme-4 .marquee-word-span,
    body.marquee-theme-5 .marquee-word-span {
      border-left: 2px solid var(--border-color);
      border-right: 2px solid var(--border-color);
    }

    body.marquee-theme-4 .marquee-word-span {
      padding: 0 5px;
    }

    body.marquee-theme-5 .marquee-word-span {
      padding: 0 10px;
    }

    body.marquee-theme-1 .marquee-word-span {
      margin: 0px 1px;
    }

    body.marquee-theme-2 .marquee-word-span {
      margin: 0px 4px;
    }

    body.marquee-theme-3 .marquee-word-span {
      margin: 0px 10px;
    }

    body.marquee-theme-4 .marquee-word-span {
      margin: 0px 26px;
    }

    body.marquee-theme-5 .marquee-word-span,
    body.marquee-theme-6 .marquee-word-span {
      margin: 0px 42px;
    }

    body.marquee-theme-1 .marquee-letter-span {
      padding: 0px 1px;
    }

    body.marquee-theme-2 .marquee-letter-span {
      padding: 0px 2px;
    }

    body.marquee-theme-3 .marquee-letter-span {
      padding: 0px 5px;
    }

    body.marquee-theme-4 .marquee-letter-span {
      padding: 0px 14px;
    }

    /* Speak function */

    .speak-mark {
      position: absolute;
      width: 3px;
      height: 100%;
      background-color: var(--border-color);
      z-index: 10;
    }

    /* Search function */

    .search-mark {
      position: absolute;
      width: 2px;
      height: 100%;
      background-color: rgb(245,245,245);
      cursor: pointer;
      z-index: 10;
    }

    .search-mark.active {
      background-color: rgb(112,128,144);
      width: 3px;
    }

    /* Bookmarks function */

    .bookmark-mark {
      position: absolute;
      width: 2px;
      height: 100%;
      background-color: rgb(255, 127, 36);
      cursor: pointer;
      z-index: 10;
    }

    #bookmarks-list {
      max-width: 400px;
      margin: 0 auto;
    }

    .bookmark-item {
      align-items: center;
      display: block;
      margin: 10px 0px;
    }

    .bookmark-name {
      min-width: 70%;
      max-width: 100%;
      display: inline-block;
      word-wrap: break-word;
      vertical-align: middle;
      cursor: pointer;
    }
    
    .bookmark-remove-button {
      min-width: 25%;
      max-width: 100%;
      display: inline-block;
      vertical-align: middle;
    }

    /* Info tab */
    #help-section {
      text-align: justify;
      max-width: 600px;
      margin: 0 auto;
    }

    #help-section h3 {
      text-align: center;
    }

    #help-section ul {
      list-style-type: disc;
      padding-left: 15px;
    }

    #help-section ol {
      padding-left: 15px;
    }

    #help-section p {
      text-indent: 15px;
    }
    
    /* Text parameters, Report, History, Help sections */
    #text-parameters, #report-section, #history-section {
      display: block;
      margin: 0 auto;
      max-width: 50%;
    }

    #history-list {
      max-height: calc(min(80vh, 700px));
      overflow-y: auto;
    }

    #text-parameters > div, .report-row {
      display: flex;
    }

    #text-parameters > div > span, .report-row > span {
      flex: 1;
      word-break: break-word;
      overflow: hidden;
    }

    .history-row {
      display: flex;
      flex-wrap: wrap;
    }

    .history-row > div {
      flex: 0 0 100%;
      display: grid;
      grid-template-columns: 50% 1fr;
    }

    .history-row > div > span {
      display: block;
    }

    .history-row > div > span:first-child {
      font-weight: bold;
    }

    /* Chart */
    #chart-container {
      height: calc(max(70vh, 300px));
      width: 50%;
      margin: 0 auto;
      overflow: hidden;
    }

    @media (max-width: 786px) {
      button {
        width: 100%;
        margin: 10px 0;
      }
      #stop-button {
        width: 30%;
      }
      #load-wiki-button {
        width: 40%;
      }
      kbd {
        display: none;
      }
      label > select, label > #font-input, label > input[type="text"] {
        width: 100%;
        vertical-align: middle;
      }
      label > input[type="number"] {
        width: 100%;
        vertical-align: middle;
      }
      label > span, label > button {
        display: inline-block;
        width: 100%;
        vertical-align: middle;
      }
      label input[type="checkbox"] + span, label input[type="radio"] + span {
        width: 100%;
      }
      input[type="range"] ~ input[type="number"] {
        width: 30%;
        margin-left: 10%;
      }
      .tab-content * {
        margin: 5px 1px;
      }
      .w50 {
        width: 100%;
      }
      #tab-navigation {
        flex-direction: column;
        border: 5px solid var(--border-color-inv);
        border-radius: 10px;
        padding: 2px;
        margin-bottom: 10px;
      }
      #settings-profile-select,
      #text-select,
      #load-wiki-language-select,
      #gemini-query-input,
      #voice-select,
      #rot-n-language-select,
      #skewing-select {
        width: 100%;
      }
      #rot-n-language-info {
        width: 100%;
      }
      #color-input {
        min-height: 250px;
      }
      #text-parameters, #report-section, #history-section {
        max-width: 100%;
      }
      #text-parameters > div, .report-row {
        flex-direction: column;
      }
      #text-parameters > div > span, .report-row > span {
        flex: none;
        width: 100%;
      }
      #text-parameters > div > span:nth-child(1), .report-row > span:nth-child(1) {
        font-weight: bold;
      }
      .history-row > div {
        grid-template-columns: 1fr;
      }
      .mob-ta-center {
        text-align: center;
      }
      .mob-w30 {
        width: 30%;
      }
      #chart-container {
        width: 100%;
      }
    }
  </style>
</head>
<body class="dark">
  <div id="main-container" class="normal-size">
    <div id="progress-bar-container">
      <div id="progress-bar"></div>
    </div>

    <div id="marquee-container">
      <span id="marquee-display"></span>
    </div>

    <div id="controls-container" class="container-items-in-center">
      <div>
        <button id="rewind-button" class="gray-button" disabled>&lt;&lt; <kbd>←</kbd></button>
        <button id="play-pause-button">Start <kbd>Space</kbd></button>
        <button id="stop-button">Stop <kbd>S</kbd></button>
        <button id="fast-forward-button" class="gray-button" disabled>&gt;&gt; <kbd>→</kbd></button>
      </div>
      <div id="text-to-speech-container">
        <button id="speak-button" class="purple-button">Speak</button>
      </div>
      <div id="search-container">
        <button id="search-button" class="dark-blue-button">Search</button>
        <div id="search-controls" class="with-rounded-border" style="display: none;">
            <input type="text" id="search-input" placeholder="Enter search query...">
            <button id="search-prev-button" class="gray-button">Previous</button>
            <button id="search-next-button" class="gray-button">Next</button>
        </div>
      </div>
      <div id="bookmarks-container">
        <button id="bookmarks-button" class="chocolate-button">Bookmarks</button>
        <div id="bookmarks-controls" style="display: none;">
          <div>
            <button id="save-bookmarks-button" class="green-button">Save bookmarks</button>
            <button id="cancel-bookmarks-button" class="red-button">Cancel</button>
          </div>
          <div>
            <input type="text" id="bookmark-name-input" placeholder="Bookmark name">
            <button id="add-bookmark-button">Add Bookmark</button>
          </div>
          <div id="bookmarks-list"></div>
        </div>
      </div>
      <div id="text-view-container">
        <button id="text-view-button" class="grey-button">Text view</button>
      </div>
      <div id="controls-container-footer">
        <button id="loop-toggle" class="gray-button">Loop <kbd>L</kbd></button>
        <div id="progress-display" style="display: none;"></div>
        <div id="color-details" style="display: none;"></div>
      </div>
    </div>

    <div id="tab-navigation" role="tablist" class="container-items-in-center">
      <button class="tab-button active" data-tab="manipulations-tab" role="tab" aria-selected="true">Manipulations</button>
      <button class="tab-button" data-tab="texts-tab" role="tab" aria-selected="false">Texts</button>
      <button class="tab-button" data-tab="settings-tab" role="tab" aria-selected="false">Settings</button>
      <button class="tab-button" data-tab="info-tab" role="tab" aria-selected="false">Information</button>
    </div>

    <div id="tab-content">
      <div id="manipulations-tab" class="tab-content active container-items-in-center with-rounded-border">
        <div>
          <select id="settings-profile-select"></select>
          <button id="new-settings-profile-button" class="green-button">New</button>
          <button id="duplicate-settings-profile-button" class="dark-cyan-button">Duplicate</button>
          <button id="save-settings-profile-button" class="blue-button">Save</button>
          <button id="reset-settings-profile-button" class="dark-button">Reset</button>
          <button id="delete-settings-profile-button" class="dark-button">Delete</button>
        </div>
        <hr>
        <div>
          <div>
            <div id="text-parameters">
              <h3>Text after manipulations</h3>
              <div>
                <span>Shannon entropy</span>
                <span><span id="text-parameter-shannon-entropy-number">0</span></span>
              </div>
              <div>
                <span>Words</span>
                <span><span id="text-parameter-words-number">0</span></span>
              </div>
              <div>
                <span>Unique words</span>
                <span><span id="text-parameter-unique-words-number">0</span> (<span id="text-parameter-unique-words-percent">0%</span>)</span>
              </div>
              <div>
                <span>Average word length</span>
                <span><span id="text-parameter-average-word-length">0</span></span>
              </div>
              <div>
                <span>Average word frequency</span>
                <span><span id="text-parameter-average-word-frequency">0</span></span>
              </div>
              <div>
                <span>Complexity</span>
                <span><span id="text-parameter-text-after-manipulations-complexity">0</span></span>
              </div>
              <div>
                <span>All symbols</span>
                <span><span id="text-parameter-all-symbols-number">0</span></span>
              </div>
              <div>
                <span>Unique letters</span>
                <span><span id="text-parameter-alphabet-letters-number">0</span> (<span id="text-parameter-alphabet-letters-percent">0%</span>)</span>
              </div>
              <div>
                <span>Colored unique symbols</span>
                <span><span id="text-parameter-letters-colored-number">0</span> (<span id="text-parameter-letters-colored-percent">0%</span>)</span>
              </div>
            </div>
          </div>
        </div>
        <hr>
        <div>
          <button id="refresh-words" class="gray-button" disabled>↻ Words ↻ <kbd>W</kbd></button>
          <button id="refresh-view" class="gray-button" disabled>↻ View ↻ <kbd>V</kbd></button>
          <br>
          <button id="refresh-sentences" class="gray-button" disabled>↻ Word order ↻</button>
          <button id="refresh-colors" class="gray-button" disabled>↻ Colors ↻</button>
          <br>
          <button id="copy-marquee-text" class="gray-button" disabled>Copy text</button>
        </div>
        <hr>
        <div>
          <div>
            <h3>Reading</h3>
          </div>
          <div>
            <label for="speed-number"><span>Speed <kbd>+</kbd><kbd>-</kbd></span></label>
            <input type="range" id="speed-slider" min="1" max="1000" value="500">
            <input type="number" id="speed-number" min="1" max="1000" value="500">
            <label><input type="checkbox" id="speed-smooth-toggle"> Smooth (platform-dependent)</label>
            <label><input type="checkbox" id="rsvp-toggle"> Rapid Serial Visual Presentation (RSVP)</label>
            <div>
              <label for="rsvp-punctuation-delay-number"><span>RSVP Punctuation delay (%)</span></label>
              <input type="range" id="rsvp-punctuation-delay-slider" min="0" max="200" value="150">
              <input type="number" id="rsvp-punctuation-delay-number" min="0" max="200" value="150">
            </div>
          </div>
          <hr>
          <div>
            <label for="font-size-number"><span>Font size</span></label>
            <input type="range" id="font-size-slider" min="8" max="50" value="50">
            <input type="number" id="font-size-number" min="8" max="50" value="50">
          </div>
          <div>
            <label>
              <span>Font family:</span>
              <input type="text" id="font-input"/>
              <div id="font-load-div">
                <div style="font-family: 'Open Sans', sans-serif;">1</div>
                <div style="font-family: 'Roboto', sans-serif;">1</div>
                <div style="font-family: 'Roboto Mono', sans-serif;">1</div>
                <div style="font-family: 'Roboto Serif', sans-serif;">1</div>
                <div style="font-family: 'Ubuntu', sans-serif;">1</div>
                <div style="font-family: 'Bad Script', cursive;">1</div>
                <div style="font-family: 'Caveat', cursive;">1</div>
                <div style="font-family: 'Comforter', cursive;">1</div>
                <div style="font-family: 'Marck Script', cursive;">1</div>
                <div style="font-family: 'Shantell Sans', cursive; ">1</div>

                <div style="font-family: 'Open Sans', sans-serif; font-style: italic;">1</div>
                <div style="font-family: 'Roboto', sans-serif; font-style: italic;">1</div>
                <div style="font-family: 'Roboto Mono', sans-serif; font-style: italic;">1</div>
                <div style="font-family: 'Roboto Serif', sans-serif; font-style: italic;">1</div>
                <div style="font-family: 'Ubuntu', sans-serif; font-style: italic;">1</div>
                <div style="font-family: 'Bad Script', cursive; font-style: italic;">1</div>
                <div style="font-family: 'Caveat', cursive; font-style: italic;">1</div>
                <div style="font-family: 'Comforter', cursive; font-style: italic;">1</div>
                <div style="font-family: 'Marck Script', cursive; font-style: italic;">1</div>
                <div style="font-family: 'Shantell Sans', cursive; font-style: italic;">1</div>

                <div style="font-family: 'Open Sans', sans-serif; font-weight: bold;">1</div>
                <div style="font-family: 'Roboto', sans-serif; font-weight: bold;">1</div>
                <div style="font-family: 'Roboto Mono', sans-serif; font-weight: bold;">1</div>
                <div style="font-family: 'Roboto Serif', sans-serif; font-weight: bold;">1</div>
                <div style="font-family: 'Ubuntu', sans-serif; font-weight: bold;">1</div>
                <div style="font-family: 'Bad Script', cursive; font-weight: bold;">1</div>
                <div style="font-family: 'Caveat', cursive; font-weight: bold;">1</div>
                <div style="font-family: 'Comforter', cursive; font-weight: bold;">1</div>
                <div style="font-family: 'Marck Script', cursive; font-weight: bold;">1</div>
                <div style="font-family: 'Shantell Sans', cursive; font-weight: bold;">1</div>

                <div style="font-family: 'Open Sans', sans-serif; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Roboto', sans-serif; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Roboto Mono', sans-serif; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Roboto Serif', sans-serif; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Ubuntu', sans-serif; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Bad Script', cursive; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Caveat', cursive; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Comforter', cursive; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Marck Script', cursive; font-style: italic; font-weight: bold;">1</div>
                <div style="font-family: 'Shantell Sans', cursive; font-style: italic; font-weight: bold;">1</div>
              </div>
              <select id="font-list-select">
                <option value="-">-</option>
                <option value="'Open Sans', sans-serif">Open Sans [Default]</option>
                <option value="'Roboto', sans-serif">Roboto</option>
                <option value="'Roboto Mono', monospace">Roboto Mono</option>
                <option value="'Roboto Serif', monospace">Roboto Serif</option>
                <option value="'Ubuntu', sans-serif">Ubuntu</option>
                <option value="'Bad Script', cursive">[Handwriting] Bad Script</option>
                <option value="'Caveat', cursive">[Handwriting] Caveat</option>
                <option value="'Comforter', cursive">[Handwriting] Comforter</option>
                <option value="'Marck Script', cursive">[Handwriting] Marck Script</option>
                <option value="'Shantell Sans', cursive">[Handwriting] Shantell Sans</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Font style:</span>
              <select id="font-style-select">
                <option value="-">-</option>
                <option value="bold">Bold</option>
                <option value="italic">Italic</option>
                <option value="bold_italic">Bold & Italic</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Text direction:</span>
              <select id="text-direction-select">
                <option value="ltr">Left to Right</option>
                <option value="rtl">Right to Left</option>
              </select>
            </label>
          </div>
        </div>
        <hr>
        <div>
          <h3>Letters</h3>
          <div>
            <label>
              <span>Skip letters:</span>
              <select id="letter-skip-select">
                <option value="no">-</option>
                <option value="10%_letters">10%</option>
                <option value="20%_letters">20%</option>
                <option value="30%_letters">30%</option>
                <option value="40%_letters">40%</option>
                <option value="50%_letters">50%</option>
                <option value="60%_letters">60%</option>
                <option value="70%_letters">70%</option>
                <option value="80%_letters">80%</option>
                <option value="90%_letters">90%</option>
                <option value="100%_letters">Almost all letters</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Reverse letters:</span>
              <select id="letter-reverse-select">
                <option value="no">-</option>
                <option value="except_first_last">Except first and last letters</option>
                <option value="except_first">Except first letter</option>
                <option value="except_capitalized">Except capitalized words</option>
                <option value="all_letters">All letters</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Shuffle letters:</span>
              <select id="letter-shuffle-select">
                <option value="no">-</option>
                <option value="middle">Middle of word</option>
                <option value="except_first_last">Except first and last letters</option>
                <option value="except_first">Except first letter</option>
                <option value="except_capitalized">Except capitalized words</option>
                <option value="all_letters">All letters</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>False letters:</span>
              <select id="letter-false-select">
                <option value="no">-</option>
                <option value="10%_letters">10%</option>
                <option value="20%_letters">20%</option>
                <option value="30%_letters">30%</option>
                <option value="40%_letters">40%</option>
                <option value="50%_letters">50%</option>
                <option value="60%_letters">60%</option>
                <option value="70%_letters">70%</option>
                <option value="80%_letters">80%</option>
                <option value="90%_letters">90%</option>
                <option value="100%_letters">100%</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Eliminate letters:</span>
              <select id="letter-elimination-select">
                <option value="no">-</option>
                <option value="20%_vowels">20% vowels</option>
                <option value="40%_vowels">40% vowels</option>
                <option value="60%_vowels">60% vowels</option>
                <option value="80%_vowels">80% vowels</option>
                <option value="100%_vowels">Almost all vowels</option>
                <option value="10%_random">10% smart-random</option>
                <option value="20%_random">20% smart-random</option>
                <option value="30%_random">30% smart-random</option>
                <option value="40%_random">40% smart-random</option>
                <option value="50%_random">50% smart-random</option>
              </select>
            </label>
          </div>
          <div id="rot-n-div" class="with-rounded-border">
            <label><input type="checkbox" id="rot-n-toggle"> ROT-N</label>
            <div id="rot-n-options">
              <div>
                <label>
                  <span>Min N:</span>
                  <input type="number" id="rot-n-number-min" min="-1000" max="1000" value="1">
                </label>
              </div>
              <div>
                <label>
                  <span>Max N:</span>
                  <input type="number" id="rot-n-number-max" min="-1000" max="1000" value="1">
                </label>
              </div>
              <div>
                <label><input type="checkbox" id="rot-n-exclude-zero"> Exclude N=0</label>
              </div>
              <div>
                <label><input type="checkbox" id="rot-n-each-mapping"> Random N for each mapping</label>
              </div>
              <div>
                <label><input type="checkbox" id="rot-n-upper-case-lower-case"> Upper case = Lower case</label>
              </div>
              <div>
                <label>
                  <span>Additional mappings:</span>
                  <input type="number" id="rot-n-complexity" min="0" max="1000" value="0">
                </label>
              </div>
              <div>
                <label>
                  <span class="select-label">Language:</span>
                  <select id="rot-n-language-select">
                    <option value="no">-</option>
                  </select>
                </label>
              </div>
              <div>
                <button id="rot-n-generate-button" class="gray-button">Regenerate</button>
              </div>
              <div>
                <div id="rot-n-language-info"></div>
              </div>
            </div>
          </div>
        </div>
        <hr>
        <div>
          <h3>Words</h3>
          <div>
            <label>
              <span>Skip words:</span>
              <select id="word-skip-select">
                <option value="no">-</option>
                <option value="5%_words">5%</option>
                <option value="10%_words">10%</option>
                <option value="15%_words">15%</option>
                <option value="20%_words">20%</option>
                <option value="25%_words">25%</option>
                <option value="30%_words">30%</option>
                <option value="35%_words">35%</option>
                <option value="40%_words">40%</option>
                <option value="45%_words">45%</option>
                <option value="50%_words">50%</option>
                <option value="55%_words">55%</option>
                <option value="60%_words">60%</option>
                <option value="65%_words">65%</option>
                <option value="70%_words">70%</option>
                <option value="75%_words">75%</option>
                <option value="80%_words">80%</option>
                <option value="85%_words">85%</option>
                <option value="90%_words">90%</option>
                <option value="95%_words">95%</option>
                <option value="100%_words">100%</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>False words:</span>
              <select id="word-false-select">
                <option value="no">-</option>
                <option value="5%_words">5%</option>
                <option value="10%_words">10%</option>
                <option value="15%_words">15%</option>
                <option value="20%_words">20%</option>
                <option value="25%_words">25%</option>
                <option value="30%_words">30%</option>
                <option value="35%_words">35%</option>
                <option value="40%_words">40%</option>
                <option value="45%_words">45%</option>
                <option value="50%_words">50%</option>
                <option value="55%_words">55%</option>
                <option value="60%_words">60%</option>
                <option value="65%_words">65%</option>
                <option value="70%_words">70%</option>
                <option value="75%_words">75%</option>
                <option value="80%_words">80%</option>
                <option value="85%_words">85%</option>
                <option value="90%_words">90%</option>
                <option value="95%_words">95%</option>
                <option value="100%_words">100%</option>
              </select>
            </label>
          </div>
        </div>
        <hr>
        <div>
          <h3>Word order</h3>
          <div>
            <label>
              <span>Concatenate words:</span>
              <select id="word-concat-select">
                <option value="no">-</option>
                <option value="5%_words">5%</option>
                <option value="10%_words">10%</option>
                <option value="15%_words">15%</option>
                <option value="20%_words">20%</option>
                <option value="25%_words">25%</option>
                <option value="30%_words">30%</option>
                <option value="35%_words">35%</option>
                <option value="40%_words">40%</option>
                <option value="45%_words">45%</option>
                <option value="50%_words">50%</option>
                <option value="55%_words">55%</option>
                <option value="60%_words">60%</option>
                <option value="65%_words">65%</option>
                <option value="70%_words">70%</option>
                <option value="75%_words">75%</option>
                <option value="80%_words">80%</option>
                <option value="85%_words">85%</option>
                <option value="90%_words">90%</option>
                <option value="95%_words">95%</option>
                <option value="100%_words">100%</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Shuffle words:</span>
              <select id="word-shuffle-select">
                <option value="no">-</option>
                <option value="2_words">2 consecutive</option>
                <option value="3_words">3 consecutive</option>
                <option value="4_words">4 consecutive</option>
                <option value="5_words">5 consecutive</option>
                <option value="6_words">6 consecutive</option>
                <option value="7_words">7 consecutive</option>
                <option value="8_words">8 consecutive</option>
                <option value="9_words">9 consecutive</option>
                <option value="10_words">10 consecutive</option>
                <option value="-1_words">Sentence (easy)</option>
                <option value="-2_words">Sentence (medium)</option>
                <option value="-3_words">Sentence (hard/1)</option>
                <option value="-4_words">Sentence (hard/2)</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Shuffle sentences:</span>
              <select id="sentence-shuffle-select">
                <option value="no">-</option>
                <option value="2_sentences">2 consecutive</option>
                <option value="3_sentences">3 consecutive</option>
                <option value="4_sentences">4 consecutive</option>
                <option value="5_sentences">5 consecutive</option>
                <option value="6_sentences">6 consecutive</option>
                <option value="7_sentences">7 consecutive</option>
                <option value="8_sentences">8 consecutive</option>
                <option value="9_sentences">9 consecutive</option>
                <option value="10_sentences">10 consecutive</option>
                <option value="all_sentences">All</option>
              </select>
            </label>
          </div>
        </div>
        <hr>
        <div>
          <h3>View</h3>
          <div>
            <label>
              <span>Marquee theme:</span>
              <select id="marquee-theme-select">
                <option value="marquee-theme-1">Theme 1</option>
                <option value="marquee-theme-2">Theme 2</option>
                <option value="marquee-theme-3">Theme 3</option>
                <option value="marquee-theme-4">Theme 4</option>
                <option value="marquee-theme-5">Theme 5</option>
                <option value="marquee-theme-6">Theme 6</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Rotate words:</span>
              <select id="rotating-words-select">
                <option value="no">-</option>
                <option value="words_180">Words 180&deg;</option>
                <option value="words_1_-1">Words 1&deg;, -1&deg;</option>
                <option value="words_181_-181">Words 181&deg;, -181&deg;</option>
                <option value="words_1_-1_181_-181">Words 1&deg;, -1&deg;, 181&deg;, -181&deg;</option>
                <option value="random_words_180">Random words 180&deg;</option>
                <option value="random_words_1_-1">Random words 1&deg;, -1&deg;</option>
                <option value="random_words_181_-181">Random words 181&deg;, -181&deg;</option>
                <option value="random_words_1_-1_181_-181">Random words 1&deg;, -1&deg;, 181&deg;, -181&deg;</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Rotate letters:</span>
              <select id="rotating-letters-select">
                <option value="no">-</option>
                <option value="letters_180">Letters 180&deg;</option>
                <option value="letters_90">Letters 90&deg;</option>
                <option value="letters_270">Letters 270&deg;</option>
                <option value="letters_90_270">Letters 90&deg;, 270&deg;</option>
                <option value="letters_180_90_270">Letters 180&deg;, 90&deg;, 270&deg;</option>
                <option value="letters_random">Letters random&deg;</option>
                <option value="random_letters_180">Random letters 180&deg;</option>
                <option value="random_letters_90">Random letters 90&deg;</option>
                <option value="random_letters_270">Random letters 270&deg;</option>
                <option value="random_letters_90_270">Random letters 90&deg;, 270&deg;</option>
                <option value="random_letters_180_90_270">Random letters 180&deg;, 90&deg;, 270&deg;</option>
                <option value="random_letters_random">Random letters random&deg;</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Mirror words:</span>
              <select id="mirroring-words-select">
                <option value="no">-</option>
                <option value="words_x">Words X (horizontally)</option>
                <option value="words_y">Words Y (vertically)</option>
                <option value="words_xy">Words XY</option>
                <option value="words_x_xor_y">Words X or Y</option>
                <option value="words_x_or_y_or_xy">Words X or Y or XY</option>
                <option value="random_words_x">Random words X</option>
                <option value="random_words_y">Random words Y</option>
                <option value="random_words_xy">Random words XY</option>
                <option value="random_words_x_xor_y">Random words X or Y</option>
                <option value="random_words_x_or_y_or_xy">Random words X or Y or XY</option>
              </select>
            </label>
          </div>
          <div>
            <label>
              <span>Mirror letters:</span>
              <select id="mirroring-letters-select">
                <option value="no">-</option>
                <option value="letters_x">Letters X</option>
                <option value="letters_y">Letters Y</option>
                <option value="letters_xy">Letters XY</option>
                <option value="letters_x_xor_y">Letters X or Y</option>
                <option value="letters_x_or_y_or_xy">Letters X or Y or XY</option>
                <option value="random_letters_x">Random letters X</option>
                <option value="random_letters_y">Random letters Y</option>
                <option value="random_letters_xy">Random letters XY</option>
                <option value="random_letters_x_xor_y">Random letters X or Y</option>
                <option value="random_letters_x_or_y_or_xy">Random letters X or Y or XY</option>
              </select>
            </label>
          </div>
          <div id="skewing-div" class="with-rounded-border">
            <label><input type="checkbox" id="skewing-toggle"> Skew</label>
            <div id="skewing-options">
              <div>
                <label>
                  <span>Target:</span>
                  <select id="skewing-select">
                    <option value="text">Text</option>
                    <option value="word">Word</option>
                    <option value="letter">Letter</option>
                  </select>
                </label>
              </div>
              <div>
                <label>
                  <span>Min angle&deg;:</span>
                  <input type="number" id="skewing-number-min" min="-90" max="90" value="1">
                </label>
              </div>
              <div>
                <label>
                  <span>Max angle&deg;:</span>
                  <input type="number" id="skewing-number-max" min="-90" max="90" value="10">
                </label>
              </div>
            </div>
          </div>
          <div id="color-encoder-div">
            <div>
              <label>
                <input type="checkbox" id="color-encoder-toggle">
                Color <kbd>E</kbd>
              </label>
            </div>
            <div id="color-encoder-options">
              <div>
                <label><input type="checkbox" id="text-background-coloring-toggle"> Background coloring</label>
              </div>
              <div>
                <label>
                  <span>Number of mappings:</span>
                  <input type="number" id="color-letter-count" min="0" max="100" value="1">
                </label>
              </div>
              <button id="dump-colors" class="gray-button">Dump colors</button>
              <textarea id="color-input" placeholder="(&lt;letters&gt; OR &quot;&lt;consecutive words&gt;&quot; OR &quot;***&quot;)&#13;&#10;(&lt;color&gt; OR default OR transparent OR font &lt;color&gt; OR bg &lt;color&gt; OR font-bg &lt;color-1&gt; &lt;color-2&gt;)&#13;&#10;&#13;&#10;abcde green&#13;&#10;&quot;these four consecutive words&quot; rgb(120, 120, 120)&#13;&#10;&quot;***&quot; font-bg red blue"></textarea>
            </div>
          </div>
        </div>
      </div>
      <div id="texts-tab" class="tab-content container-items-in-center with-rounded-border">
        <div>
          <select id="text-select">
          </select>
          <button id="new-text-button" class="green-button">New</button>
          <button id="duplicate-text-button" class="dark-cyan-button">Duplicate</button>
          <button id="save-text-button" class="blue-button">Save</button>
          <button id="clear-text-button" class="dark-button">Clear</button>
          <button id="delete-text-button" class="dark-button">Delete</button>
        </div>
        <br>
        <div>
          <label>
            <input type="checkbox" id="show-hide-text-toggle">
            <span>Show text</span>
          </label>
        </div>
        <div>
          <label>
            <h3>Text</h3>
            <textarea id="text-input" placeholder="Enter text here"></textarea>
          </label>
        </div>
        <div>
          <div>
            <button id="load-file">Load text file</button>
            <button id="copy-current-text">Copy text</button>
          </div>
          <div>
            <label>
              <input type="checkbox" id="append-text-toggle">
              <span>Append text after loading/fetching</span>
            </label>
          </div>
          <div>
            <label>
              <input type="checkbox" id="remove-marks-toggle">
              <span>Remove accents after loading/fetching</span>
            </label>
          </div>
          <div>
            <button id="split-into-paragraphs" class="dark-button">Split into paragraphs</button>
            <button id="shuffle-paragraphs" class="dark-button">Shuffle paragraphs</button>
            <button id="shuffle-sentences" class="dark-button">Shuffle sentences</button>
          </div>
          <div class="with-rounded-border">
            <h3 id="random-paragraphs-caption">Random paragraphs</h3>
            <div>
              <label>
                <span>Number of paragraphs:</span>
                <input type="number" id="sentence-count-input" min="1" max="1000" value="1">
              </label>
            </div>
            <div>
              <label>
                <div>Random Wiki summaries by language:</div>
                <select id="load-wiki-language-select">
                  <option value="af">Afrikaans / Afrikaans</option>
                  <option value="sq">Albanian / shqip</option>
                  <option value="als">Alemannic / Alemannisch</option>
                  <option value="ami">Amis / Pangcah</option>
                  <option value="frp">Arpitan / arpetan</option>
                  <option value="ast">Asturian / asturianu</option>
                  <option value="tay">Atayal / Tayal</option>
                  <option value="atj">Atikamekw / Atikamekw</option>
                  <option value="ay">Aymara / Aymar aru</option>
                  <option value="ban">Balinese / Basa Bali</option>
                  <option value="bm">Bambara / bamanankan</option>
                  <option value="bjn">Banjar / Banjar</option>
                  <option value="map-bms">Banyumasan / Basa Banyumasan</option>
                  <option value="eu">Basque / euskara</option>
                  <option value="btm">Batak Mandailing / Batak Mandailing</option>
                  <option value="bbc">Batak Toba / Batak Toba</option>
                  <option value="bar">Bavarian / Boarisch</option>
                  <option value="bew">Betawi / Betawi</option>
                  <option value="bi">Bislama / Bislama</option>
                  <option value="bs">Bosnian / bosanski</option>
                  <option value="br">Breton / brezhoneg</option>
                  <option value="bug">Buginese / Basa Ugi</option>
                  <option value="ceb">Cebuano / Cebuano</option>
                  <option value="bcl">Central Bikol / Bikol Central</option>
                  <option value="dtp">Central Dusun / Kadazandusun</option>
                  <option value="knc">Central Kanuri / Yerwa Kanuri</option>
                  <option value="ch">Chamorro / Chamoru</option>
                  <option value="cbk-zam">Chavacano / Chavacano de Zamboanga</option>
                  <option value="ksh">Colognian / Ripoarisch</option>
                  <option value="kw">Cornish / kernowek</option>
                  <option value="co">Corsican / corsu</option>
                  <option value="hr">Croatian / hrvatski</option>
                  <option value="dag">Dagbani / dagbanli</option>
                  <option value="da">Danish / dansk</option>
                  <option value="diq">Dimli / Zazaki</option>
                  <option value="nl">Dutch / Nederlands</option>
                  <option value="en">English / English</option>
                  <option value="simple">English / Simple English</option>
                  <option value="ang">Old English / &#198;nglisc</option>
                  <option value="eo">Esperanto / Esperanto</option>
                  <option value="et">Estonian / eesti</option>
                  <option value="fat">Fanti / mfantse</option>
                  <option value="hif">Fiji Hindi / Fiji Hindi</option>
                  <option value="fj">Fijian / Na Vosa Vakaviti</option>
                  <option value="fi">Finnish / suomi</option>
                  <option value="gur">Frafra / farefare</option>
                  <option value="fur">Friulian / furlan</option>
                  <option value="ff">Fula / Fulfulde</option>
                  <option value="gag">Gagauz / Gagauz</option>
                  <option value="gl">Galician / galego</option>
                  <option value="lg">Ganda / Luganda</option>
                  <option value="de">German / Deutsch</option>
                  <option value="gpe">Ghanaian Pidgin / Ghanaian Pidgin</option>
                  <option value="gor">Gorontalo / Bahasa Hulontalo</option>
                  <option value="guw">Gun / gungbe</option>
                  <option value="ha">Hausa / Hausa</option>
                  <option value="hu">Hungarian / magyar</option>
                  <option value="iba">Iban / Jaku Iban</option>
                  <option value="io">Ido / Ido</option>
                  <option value="igl">Igala / Igala</option>
                  <option value="ig">Igbo / Igbo</option>
                  <option value="ilo">Iloko / Ilokano</option>
                  <option value="id">Indonesian / Bahasa Indonesia</option>
                  <option value="ia">Interlingua / interlingua</option>
                  <option value="ie">Interlingue / Interlingue</option>
                  <option value="ga">Irish / Gaeilge</option>
                  <option value="it">Italian / italiano</option>
                  <option value="jam">Jamaican Creole English / Patois</option>
                  <option value="jv">Javanese / Jawa</option>
                  <option value="kab">Kabyle / Taqbaylit</option>
                  <option value="kl">Kalaallisut / kalaallisut</option>
                  <option value="kaa">Kara-Kalpak / Qaraqalpaqsha</option>
                  <option value="rw">Kinyarwanda / Ikinyarwanda</option>
                  <option value="kge">Komering / Kumoring</option>
                  <option value="kg">Kongo / Kongo</option>
                  <option value="avk">Kotava / Kotava</option>
                  <option value="lld">Ladin / Ladin</option>
                  <option value="lad">Ladino / Ladino</option>
                  <option value="la">Latin / Latina</option>
                  <option value="lij">Ligurian / Ligure</option>
                  <option value="li">Limburgish / Limburgs</option>
                  <option value="lfn">Lingua Franca Nova / Lingua Franca Nova</option>
                  <option value="olo">Livvi-Karelian / livvinkarjala</option>
                  <option value="jbo">Lojban / la .lojban.</option>
                  <option value="lmo">Lombard / lombard</option>
                  <option value="nds-nl">Low Saxon / Nedersaksies</option>
                  <option value="dsb">Lower Sorbian / dolnoserbski</option>
                  <option value="mg">Malagasy / Malagasy</option>
                  <option value="ms">Malay / Bahasa Melayu</option>
                  <option value="mt">Maltese / Malti</option>
                  <option value="gv">Manx / Gaelg</option>
                  <option value="min">Minangkabau / Minangkabau</option>
                  <option value="mos">Mossi / moore</option>
                  <option value="nap">Neapolitan / Napulitano</option>
                  <option value="nia">Nias / Li Niha</option>
                  <option value="nrm">Norman / Nouormand</option>
                  <option value="frr">Northern Frisian / Nordfriisk</option>
                  <option value="nso">Northern Sotho / Sesotho sa Leboa</option>
                  <option value="no">Norwegian / norsk</option>
                  <option value="nn">Norwegian Nynorsk / norsk nynorsk</option>
                  <option value="nov">Novial / Novial</option>
                  <option value="ny">Nyanja / Chi-Chewa</option>
                  <option value="ann">Obolo / Obolo</option>
                  <option value="oc">Occitan / occitan</option>
                  <option value="om">Oromo / Oromoo</option>
                  <option value="pwn">Paiwan / pinayuanan</option>
                  <option value="pam">Pampanga / Kapampangan</option>
                  <option value="pag">Pangasinan / Pangasinan</option>
                  <option value="pap">Papiamento / Papiamentu</option>
                  <option value="pdc">Pennsylvania German / Deitsch</option>
                  <option value="pcd">Picard / Picard</option>
                  <option value="pl">Polish / polski</option>
                  <option value="qu">Quechua / Runa Simi</option>
                  <option value="rm">Romansh / rumantsch</option>
                  <option value="rn">Rundi / ikirundi</option>
                  <option value="szy">Sakizaya / Sakizaya</option>
                  <option value="sm">Samoan / Gagana Samoa</option>
                  <option value="sc">Sardinian / sardu</option>
                  <option value="stq">Saterland Frisian / Seeltersk</option>
                  <option value="sco">Scots / Scots</option>
                  <option value="sn">Shona / chiShona</option>
                  <option value="scn">Sicilian / sicilianu</option>
                  <option value="so">Somali / Soomaaliga</option>
                  <option value="nr">South Ndebele / isiNdebele seSewula</option>
                  <option value="dga">Southern Dagaare / Dagaare</option>
                  <option value="st">Southern Sotho / Sesotho</option>
                  <option value="srn">Sranan Tongo / Sranantongo</option>
                  <option value="su">Sundanese / Sunda</option>
                  <option value="sw">Swahili / Kiswahili</option>
                  <option value="ss">Swati / SiSwati</option>
                  <option value="sv">Swedish / svenska</option>
                  <option value="tl">Tagalog / Tagalog</option>
                  <option value="ty">Tahitian / reo tahiti</option>
                  <option value="trv">Taroko / Seediq</option>
                  <option value="tet">Tetum / tetun</option>
                  <option value="tpi">Tok Pisin / Tok Pisin</option>
                  <option value="to">Tongan / lea faka-Tonga</option>
                  <option value="ts">Tsonga / Xitsonga</option>
                  <option value="tn">Tswana / Setswana</option>
                  <option value="tum">Tumbuka / chiTumbuka</option>
                  <option value="tw">Twi / Twi</option>
                  <option value="kcg">Tyap / Tyap</option>
                  <option value="hsb">Upper Sorbian / hornjoserbsce</option>
                  <option value="ve">Venda / Tshivenda</option>
                  <option value="wa">Walloon / walon</option>
                  <option value="war">Waray / Winaray</option>
                  <option value="guc">Wayuu / wayuunaiki</option>
                  <option value="cy">Welsh / Cymraeg</option>
                  <option value="bdr">West Coast Bajau / Bajau Sama</option>
                  <option value="vls">West Flemish / West-Vlams</option>
                  <option value="fy">Western Frisian / Frysk</option>
                  <option value="wo">Wolof / Wolof</option>
                  <option value="xh">Xhosa / isiXhosa</option>
                  <option value="za">Zhuang / Vahcuengh</option>
                  <option value="zu">Zulu / isiZulu</option>
                  <option value="ace">Acehnese / Ac&#232;h</option>
                  <option value="an">Aragonese / aragon&#233;s</option>
                  <option value="roa-rup">Aromanian / arm&#227;neashti</option>
                  <option value="ca">Catalan / catal&#224;</option>
                  <option value="chy">Cheyenne / Tsets&#234;hest&#226;hese</option>
                  <option value="eml">Emiliano-Romagnolo / emili&#224;n e rumagn&#242;l</option>
                  <option value="ext">Extremaduran / estreme&#241;u</option>
                  <option value="fr">French / fran&#231;ais</option>
                  <option value="gcr">Guianan Creole / kriy&#242;l gwiyannen</option>
                  <option value="ht">Haitian Creole / Krey&#242;l ayisyen</option>
                  <option value="is">Icelandic / &#237;slenska</option>
                  <option value="ik">Inupiaq / I&#241;upiatun</option>
                  <option value="csb">Kashubian / kasz&#235;bsczi</option>
                  <option value="ku">Kurdish / kurd&#238;</option>
                  <option value="ln">Lingala / ling&#225;la</option>
                  <option value="lb">Luxembourgish / L&#235;tzebuergesch</option>
                  <option value="mad">Madurese / Madhur&#226;</option>
                  <option value="mwl">Mirandese / Mirand&#233;s</option>
                  <option value="nv">Navajo / Din&#233; bizaad</option>
                  <option value="pcm">Nigerian Pidgin / Naij&#225;</option>
                  <option value="se">Northern Sami / davvis&#225;megiella</option>
                  <option value="pfl">Palatine German / P&#228;lzisch</option>
                  <option value="pms">Piedmontese / Piemont&#232;is</option>
                  <option value="pt">Portuguese / portugu&#234;s</option>
                  <option value="sg">Sango / S&#228;ng&#246;</option>
                  <option value="gd">Scottish Gaelic / G&#224;idhlig</option>
                  <option value="es">Spanish / espa&#241;ol</option>
                  <option value="roa-tara">Tarantino / tarand&#237;ne</option>
                  <option value="vec">Venetian / v&#232;neto</option>
                  <option value="fiu-vro">Võro / v&#245;ro</option>
                  <option value="zea">Zeelandic / Ze&#234;uws</option>
                  <option value="az">Azerbaijani / az&#601;rbaycanca</option>
                  <option value="crh">Crimean Tatar / q&#305;r&#305;mtatarca</option>
                  <option value="cs">Czech / &#269;e&#353;tina</option>
                  <option value="din">Dinka / Thu&#596;&#331;j&#228;&#331;</option>
                  <option value="ee">Ewe / e&#651;egbe</option>
                  <option value="fo">Faroese / f&#248;royskt</option>
                  <option value="haw">Hawaiian / Hawai&#699;i</option>
                  <option value="smn">Inari Sami / anar&#226;&#353;kiel&#226;</option>
                  <option value="kbp">Kabiye / Kab&#617;y&#603;</option>
                  <option value="ki">Kikuyu / G&#297;k&#361;y&#361;</option>
                  <option value="kus">Kusaal / K&#651;saal</option>
                  <option value="ltg">Latgalian / latga&#316;u</option>
                  <option value="lv">Latvian / latvie&#353;u</option>
                  <option value="lt">Lithuanian / lietuvi&#371;</option>
                  <option value="nds">Low German / Plattd&#252;&#252;tsch</option>
                  <option value="mi">Māori / M&#257;ori</option>
                  <option value="nah">Nahuatl / N&#257;huatl</option>
                  <option value="ro">Romanian / rom&#226;n&#259;</option>
                  <option value="bat-smg">Samogitian / &#382;emait&#279;&#353;ka</option>
                  <option value="szl">Silesian / &#347;l&#367;nski</option>
                  <option value="sk">Slovak / sloven&#269;ina</option>
                  <option value="sl">Slovenian / sloven&#353;&#269;ina</option>
                  <option value="tly">Talysh / tol&#305;&#351;i</option>
                  <option value="tr">Turkish / T&#252;rk&#231;e</option>
                  <option value="tk">Turkmen / T&#252;rkmen&#231;e</option>
                  <option value="rmy">Vlax Romani / romani &#269;hib</option>
                  <option value="vo">Volapük / Volap&#252;k</option>
                  <option value="yo">Yoruba / Yor&#249;b&#225;</option>
                  <option value="fon">Fon / f&#596;&#768;ngb&#232;</option>
                  <option value="el">Greek / &#917;&#955;&#955;&#951;&#957;&#953;&#954;&#940;</option>
                  <option value="pnt">Pontic / &#928;&#959;&#957;&#964;&#953;&#945;&#954;&#940;</option>
                  <option value="ady">Adyghe / &#1072;&#1076;&#1099;&#1075;&#1072;&#1073;&#1079;&#1101;</option>
                  <option value="av">Avaric / &#1072;&#1074;&#1072;&#1088;</option>
                  <option value="be">Belarusian / &#1073;&#1077;&#1083;&#1072;&#1088;&#1091;&#1089;&#1082;&#1072;&#1103;</option>
                  <option value="be-tarask">Belarusian (Taraškievica orthography) / &#1073;&#1077;&#1083;&#1072;&#1088;&#1091;&#1089;&#1082;&#1072;&#1103; (&#1090;&#1072;&#1088;&#1072;&#1096;&#1082;&#1077;&#1074;&#1110;&#1094;&#1072;)</option>
                  <option value="bg">Bulgarian / &#1073;&#1098;&#1083;&#1075;&#1072;&#1088;&#1089;&#1082;&#1080;</option>
                  <option value="ce">Chechen / &#1085;&#1086;&#1093;&#1095;&#1080;&#1081;&#1085;</option>
                  <option value="mhr">Eastern Mari / &#1086;&#1083;&#1099;&#1082; &#1084;&#1072;&#1088;&#1080;&#1081;</option>
                  <option value="myv">Erzya / &#1101;&#1088;&#1079;&#1103;&#1085;&#1100;</option>
                  <option value="kbd">Kabardian / &#1072;&#1076;&#1099;&#1075;&#1101;&#1073;&#1079;&#1101;</option>
                  <option value="xal">Kalmyk / &#1093;&#1072;&#1083;&#1100;&#1084;&#1075;</option>
                  <option value="krc">Karachay-Balkar / &#1082;&#1098;&#1072;&#1088;&#1072;&#1095;&#1072;&#1081;-&#1084;&#1072;&#1083;&#1082;&#1098;&#1072;&#1088;</option>
                  <option value="kv">Komi / &#1082;&#1086;&#1084;&#1080;</option>
                  <option value="koi">Komi-Permyak / &#1087;&#1077;&#1088;&#1077;&#1084; &#1082;&#1086;&#1084;&#1080;</option>
                  <option value="ky">Kyrgyz / &#1082;&#1099;&#1088;&#1075;&#1099;&#1079;&#1095;&#1072;</option>
                  <option value="lbe">Lak / &#1083;&#1072;&#1082;&#1082;&#1091;</option>
                  <option value="lez">Lezghian / &#1083;&#1077;&#1079;&#1075;&#1080;</option>
                  <option value="mk">Macedonian / &#1084;&#1072;&#1082;&#1077;&#1076;&#1086;&#1085;&#1089;&#1082;&#1080;</option>
                  <option value="mdf">Moksha / &#1084;&#1086;&#1082;&#1096;&#1077;&#1085;&#1100;</option>
                  <option value="mn">Mongolian / &#1084;&#1086;&#1085;&#1075;&#1086;&#1083;</option>
                  <option value="os">Ossetic / &#1080;&#1088;&#1086;&#1085;</option>
                  <option value="rsk">Pannonian Rusyn / &#1088;&#1091;&#1089;&#1082;&#1080;</option>
                  <option value="bxr">Russia Buriat / &#1073;&#1091;&#1088;&#1103;&#1072;&#1076;</option>
                  <option value="ru">Russian / &#1088;&#1091;&#1089;&#1089;&#1082;&#1080;&#1081;</option>
                  <option value="rue">Rusyn / &#1088;&#1091;&#1089;&#1080;&#1085;&#1100;&#1089;&#1082;&#1099;&#1081;</option>
                  <option value="sr">Serbian / &#1089;&#1088;&#1087;&#1089;&#1082;&#1080; / srpski</option>
                  <option value="sh">Serbo-Croatian / srpskohrvatski / &#1089;&#1088;&#1087;&#1089;&#1082;&#1086;&#1093;&#1088;&#1074;&#1072;&#1090;&#1089;&#1082;&#1080;</option>
                  <option value="alt">Southern Altai / &#1072;&#1083;&#1090;&#1072;&#1081; &#1090;&#1080;&#1083;</option>
                  <option value="tt">Tatar / &#1090;&#1072;&#1090;&#1072;&#1088;&#1095;&#1072; / tatar&#231;a</option>
                  <option value="tyv">Tuvinian / &#1090;&#1099;&#1074;&#1072; &#1076;&#1099;&#1083;</option>
                  <option value="udm">Udmurt / &#1091;&#1076;&#1084;&#1091;&#1088;&#1090;</option>
                  <option value="uk">Ukrainian / &#1091;&#1082;&#1088;&#1072;&#1111;&#1085;&#1089;&#1100;&#1082;&#1072;</option>
                  <option value="uz">Uzbek / o&#699;zbekcha / &#1118;&#1079;&#1073;&#1077;&#1082;&#1095;&#1072;</option>
                  <option value="mrj">Western Mari / &#1082;&#1099;&#1088;&#1099;&#1082; &#1084;&#1072;&#1088;&#1099;</option>
                  <option value="sah">Yakut / &#1089;&#1072;&#1093;&#1072; &#1090;&#1099;&#1083;&#1072;</option>
                  <option value="ab">Abkhazian / &#1072;&#1317;&#1089;&#1096;&#1241;&#1072;</option>
                  <option value="ba">Bashkir / &#1073;&#1072;&#1096;&#1185;&#1086;&#1088;&#1090;&#1089;&#1072;</option>
                  <option value="cv">Chuvash / &#1095;&#1233;&#1074;&#1072;&#1096;&#1083;&#1072;</option>
                  <option value="inh">Ingush / &#1075;&#1216;&#1072;&#1083;&#1075;&#1216;&#1072;&#1081;</option>
                  <option value="kk">Kazakh / &#1179;&#1072;&#1079;&#1072;&#1179;&#1096;&#1072;</option>
                  <option value="tg">Tajik / &#1090;&#1086;&#1207;&#1080;&#1082;&#1251;</option>
                  <option value="hy">Armenian / &#1392;&#1377;&#1397;&#1381;&#1408;&#1381;&#1398;</option>
                  <option value="hyw">Western Armenian / &#1329;&#1408;&#1381;&#1410;&#1396;&#1407;&#1377;&#1392;&#1377;&#1397;&#1381;&#1408;&#1383;&#1398;</option>
                  <option value="he">Hebrew / &#1506;&#1489;&#1512;&#1497;&#1514;</option>
                  <option value="yi">Yiddish / &#1497;&#1497;&#1460;&#1491;&#1497;&#1513;</option>
                  <option value="ar">Arabic / &#1575;&#1604;&#1593;&#1585;&#1576;&#1610;&#1577;</option>
                  <option value="arz">Egyptian Arabic / &#1605;&#1589;&#1585;&#1609;</option>
                  <option value="ary">Moroccan Arabic / &#1575;&#1604;&#1583;&#1575;&#1585;&#1580;&#1577;</option>
                  <option value="ur">Urdu / &#1575;&#1585;&#1583;&#1608;</option>
                  <option value="ckb">Central Kurdish / &#1705;&#1608;&#1585;&#1583;&#1740;</option>
                  <option value="glk">Gilaki / &#1711;&#1740;&#1604;&#1705;&#1740;</option>
                  <option value="mzn">Mazanderani / &#1605;&#1575;&#1586;&#1616;&#1585;&#1608;&#1606;&#1740;</option>
                  <option value="ps">Pashto / &#1662;&#1690;&#1578;&#1608;</option>
                  <option value="fa">Persian / &#1601;&#1575;&#1585;&#1587;&#1740;</option>
                  <option value="skr">Saraiki / &#1587;&#1585;&#1575;&#1574;&#1740;&#1705;&#1740;</option>
                  <option value="sd">Sindhi / &#1587;&#1606;&#1676;&#1610;</option>
                  <option value="azb">South Azerbaijani / &#1578;&#1734;&#1585;&#1705;&#1580;&#1607;</option>
                  <option value="pnb">Western Punjabi / &#1662;&#1606;&#1580;&#1575;&#1576;&#1740;</option>
                  <option value="ug">Uyghur / &#1574;&#1735;&#1610;&#1594;&#1735;&#1585;&#1670;&#1749; / Uyghurche</option>
                  <option value="arc">Aramaic / &#1808;&#1834;&#1825;&#1821;&#1808;</option>
                  <option value="dv">Divehi / &#1931;&#1960;&#1928;&#1964;&#1920;&#1960;&#1924;&#1958;&#1936;&#1968;</option>
                  <option value="nqo">N’Ko / &#2002;&#2014;&#1999;</option>
                  <option value="anp">Angika / &#2309;&#2306;&#2327;&#2367;&#2325;&#2366;</option>
                  <option value="pi">Pali / &#2346;&#2366;&#2354;&#2367;</option>
                  <option value="awa">Awadhi / &#2309;&#2357;&#2343;&#2368;</option>
                  <option value="mr">Marathi / &#2350;&#2352;&#2366;&#2336;&#2368;</option>
                  <option value="ne">Nepali / &#2344;&#2375;&#2346;&#2366;&#2354;&#2368;</option>
                  <option value="new">Newari / &#2344;&#2375;&#2346;&#2366;&#2354; &#2349;&#2366;&#2359;&#2366;</option>
                  <option value="mai">Maithili / &#2350;&#2376;&#2341;&#2367;&#2354;&#2368;</option>
                  <option value="ks">Kashmiri / &#2325;&#2377;&#2358;&#2369;&#2352; / &#1705;&#1650;&#1588;&#1615;&#1585;</option>
                  <option value="bh">Bhojpuri / &#2349;&#2379;&#2332;&#2346;&#2369;&#2352;&#2368;</option>
                  <option value="dty">Doteli / &#2337;&#2379;&#2335;&#2375;&#2354;&#2368;</option>
                  <option value="gom">Goan Konkani / &#2327;&#2379;&#2306;&#2351;&#2330;&#2368; &#2325;&#2379;&#2306;&#2325;&#2339;&#2368; / G&#245;ychi Konknni</option>
                  <option value="hi">Hindi / &#2361;&#2367;&#2344;&#2381;&#2342;&#2368;</option>
                  <option value="sa">Sanskrit / &#2360;&#2306;&#2360;&#2381;&#2325;&#2371;&#2340;&#2350;&#2381;</option>
                  <option value="bn">Bangla / &#2476;&#2494;&#2434;&#2482;&#2494;</option>
                  <option value="as">Assamese / &#2437;&#2488;&#2478;&#2496;&#2479;&#2492;&#2494;</option>
                  <option value="bpy">Bishnupriya / &#2476;&#2495;&#2487;&#2509;&#2467;&#2497;&#2474;&#2509;&#2480;&#2495;&#2479;&#2492;&#2494; &#2478;&#2467;&#2495;&#2474;&#2497;&#2480;&#2496;</option>
                  <option value="pa">Punjabi / &#2602;&#2672;&#2588;&#2622;&#2604;&#2624;</option>
                  <option value="gu">Gujarati / &#2711;&#2753;&#2716;&#2736;&#2750;&#2724;&#2752;</option>
                  <option value="or">Odia / &#2835;&#2849;&#2876;&#2879;&#2822;</option>
                  <option value="ta">Tamil / &#2980;&#2990;&#3007;&#2996;&#3021;</option>
                  <option value="te">Telugu / &#3108;&#3142;&#3122;&#3137;&#3095;&#3137;</option>
                  <option value="tcy">Tulu / &#3236;&#3265;&#3251;&#3265;</option>
                  <option value="kn">Kannada / &#3221;&#3240;&#3277;&#3240;&#3233;</option>
                  <option value="ml">Malayalam / &#3374;&#3378;&#3375;&#3390;&#3379;&#3330;</option>
                  <option value="si">Sinhala / &#3523;&#3538;&#3458;&#3524;&#3517;</option>
                  <option value="th">Thai / &#3652;&#3607;&#3618;</option>
                  <option value="lo">Lao / &#3749;&#3762;&#3751;</option>
                  <option value="dz">Dzongkha / &#3911;&#3964;&#3908;&#3851;&#3905;</option>
                  <option value="bo">Tibetan / &#3926;&#3964;&#3921;&#3851;&#3937;&#3954;&#3906;</option>
                  <option value="mnw">Mon / &#4120;&#4140;&#4126;&#4140;&#4121;&#4116;&#4154;</option>
                  <option value="my">Burmese / &#4121;&#4156;&#4116;&#4154;&#4121;&#4140;&#4120;&#4140;&#4126;&#4140;</option>
                  <option value="shn">Shan / &#4112;&#4230;&#4152;</option>
                  <option value="blk">Pa'O / &#4117;&#4129;&#4141;&#4143;&#4125;&#4154;&#4239;&#4120;&#4140;&#4239;&#4126;&#4140;&#4239;</option>
                  <option value="ka">Georgian / &#4325;&#4304;&#4320;&#4311;&#4323;&#4314;&#4312;</option>
                  <option value="xmf">Mingrelian / &#4315;&#4304;&#4320;&#4306;&#4304;&#4314;&#4323;&#4320;&#4312;</option>
                  <option value="am">Amharic / &#4768;&#4635;&#4653;&#4763;</option>
                  <option value="tig">Tigre / &#4725;&#4877;&#4652;</option>
                  <option value="ti">Tigrinya / &#4725;&#4877;&#4653;&#4763;</option>
                  <option value="chr">Cherokee / &#5091;&#5043;&#5033;</option>
                  <option value="cr">Cree / N&#275;hiyaw&#275;win / &#5312;&#5158;&#5123;&#5421;&#5133;&#5135;&#5155;</option>
                  <option value="iu">Inuktitut / &#5123;&#5316;&#5251;&#5198;&#5200;&#5222; / inuktitut</option>
                  <option value="km">Khmer / &#6039;&#6070;&#6047;&#6070;&#6017;&#6098;&#6040;&#6082;&#6042;</option>
                  <option value="tdd">Tai Nuea / &#6486;&#6509;&#6512; &#6486;&#6508;&#6514; &#6481;&#6504;&#6482;&#6512;</option>
                  <option value="sat">Santali / &#7269;&#7263;&#7281;&#7259;&#7263;&#7282;&#7268;</option>
                  <option value="gn">Guarani / Ava&#241;e&#x27;&#7869;</option>
                  <option value="shi">Tachelhit / Tacl&#7717;it</option>
                  <option value="vi">Vietnamese / Ti&#7871;ng Vi&#7879;t</option>
                  <option value="vep">Veps / veps&#228;n kel&#8217;</option>
                  <option value="cu">Church Slavic / &#1089;&#1083;&#1086;&#1074;&#1123;&#1085;&#1100;&#1089;&#1082;&#1098; / &#11284;&#11278;&#11281;&#11266;&#11297;&#11280;&#11296;&#11284;&#11277;&#11295;</option>
                  <option value="zgh">Standard Moroccan Tamazight / &#11612;&#11568;&#11598;&#11568;&#11619;&#11593;&#11606;&#11612; &#11612;&#11568;&#11599;&#11568;&#11617;&#11568;&#11618;&#11612;</option>
                  <option value="zh-yue">Cantonese / &#31925;&#35486;</option>
                  <option value="zh">Chinese / &#20013;&#25991;</option>
                  <option value="zh-classical">Literary Chinese / &#25991;&#35328;</option>
                  <option value="gan">Gan / &#36123;&#35486;</option>
                  <option value="hak">Hakka Chinese / &#23458;&#23478;&#35486; / Hak-k&#226;-ng&#238;</option>
                  <option value="ja">Japanese / &#26085;&#26412;&#35486;</option>
                  <option value="cdo">Mindong / &#38313;&#26481;&#35486; / M&#236;ng-d&#277;&#804;ng-ng&#7795;&#772;</option>
                  <option value="zh-min-nan">Minnan / &#38313;&#21335;&#35486; / B&#226;n-l&#226;m-g&#250;</option>
                  <option value="wuu">Wu / &#21556;&#35821;</option>
                  <option value="syl">Sylheti / &#43021;&#43044;&#43039;&#43024;&#43044;</option>
                  <option value="mni">Manipuri / &#43971;&#44004;&#43975;&#44009; &#43970;&#44003;&#43999;</option>
                  <option value="ko">Korean / &#54620;&#44397;&#50612;</option>
                  <option value="got">Gothic / &#66354;&#66367;&#66372;&#66361;&#66371;&#66362;</option>
                </select>
                <button id="load-wiki-button">Download</button>
              </label>
            </div>
            <div>
              <span>Random English sentences from dictionaries:</span>
            </div>
            <div>
              <button id="load-sentence-wordsmyth-beginner">[En] Wordsmyth Beginner's [6153]</button>
            </div>
            <div>
              <button id="load-sentence-wordsmyth-intermediate">[En] Wordsmyth Intermediate [13438]</button>
            </div>
            <div>
              <button id="load-sentence-wordsmyth-advanced">[En] Wordsmyth Advanced [21394]</button>
            </div>
            <div>
              <button id="load-sentence-merriam-webster">[En] Merriam-Webster [10668]</button>
            </div>
            <div id="hidden-content-1" style="display: none;">
              <div>
                <button id="load-underthekey">[En] Underthekey random sentence [E]</button>
              </div>
              <div>
                <button id="load-metaphorpsum">[En] Metaphorpsum random sentence [E]</button>
              </div>
            </div>
          </div>
          <div class="with-rounded-border">
            <h3>Gemini API</h3>
            <div>
              <label>
                <span>API Key:</span>
                <input type="text" id="gemini-key-input" placeholder="API Key">
              </label>
            </div>
            <div>
              <label>
                <span>Model:</span>
                <select id="gemini-model-select">
                  <option value="gemini-2.0-flash">Gemini 2.0 Flash</option>
                  <option value="gemini-2.0-flash-lite">Gemini 2.0 Flash Lite</option>
                  <option value="gemini-1.5-flash">Gemini 1.5 Flash</option>
                  <option value="gemini-1.5-flash-8b">Gemini 1.5 Flash-8B</option>
                  <option value="gemini-1.5-pro">Gemini 1.5 Pro</option>
                </select>
              </label>
            </div>
            <div>
              <label>
                <span id="gemini-query-label">Query:</span>
                <input type="text" id="gemini-query-input">
              </label>
            </div>
            <button id="load-gemini">Load</button>
          </div>
        </div>
      </div>
      <div id="settings-tab" class="tab-content container-items-in-center with-rounded-border">
        <div class="with-rounded-border">
          <h3>Appearance</h3>
          <label>
            <input type="checkbox" id="show-color-info-toggle">
            <span>Show Letters-Colors info <kbd>ESC</kbd></span>
          </label>
          <label>
            <input type="checkbox" id="show-speak-button-toggle">
            <span>Show Speak button</span>
          </label>
          <label>
            <input type="checkbox" id="show-search-button-toggle">
            <span>Show Search button</span>
          </label>
          <label>
            <input type="checkbox" id="show-bookmarks-button-toggle">
            <span>Show Bookmarks button</span>
          </label>
          <label>
            <input type="checkbox" id="show-text-view-button-toggle">
            <span>Show Text view button</span>
          </label>
          <div>
            <button id="theme-toggle" class="cyan-button">Toggle Theme</button>
            <button id="full-size-toggle" class="cyan-button">Toggle Full Size</button>
          </div>
        </div>
        <div class="with-rounded-border">
          <h3>History</h3>
          <div>
            <label>
              <input type="checkbox" id="history-enable-toggle">
              <span>Enable history</span>
            </label>
          </div>
          <div>
            <label>
              <span>Delete attempts from history in time less than or equal to (seconds):</span>
              <input type="number" id="attempt-min-time-number" min="1" max="1000" step="1" value="10">
            </label>
          </div>
        </div>
        <div class="with-rounded-border">
          <h3>Text-to-Speech</h3>
          <div>
            <select id="voice-select"></select>
          </div>
          <div>
            <label for="speech-rate-number"><span>Rate</span></label>
            <input type="range" id="speech-rate-slider" min="1" max="1000" step="1" value="100">
            <input type="number" id="speech-rate-number" min="1" max="1000" step="1" value="100">
          </div>
          <div>
            <label for="speech-pitch-number"><span>Pitch</span></label>
            <input type="range" id="speech-pitch-slider" min="0" max="200" step="1" value="100">
            <input type="number" id="speech-pitch-number" min="0" max="200" step="1" value="100">
          </div>
          <div>
            <label for="speech-volume-number"><span>Volume</span></label>
            <input type="range" id="speech-volume-slider" min="0" max="100" step="1" value="100">
            <input type="number" id="speech-volume-number" min="0" max="100" step="1" value="100">
          </div>
          <div>
            <label>
              <input type="checkbox" id="faster-transitions-toggle">
              <span>Reduced pause between sentences</span>
            </label>
          </div>
          <div>
            <label>
              <input type="checkbox" id="speak-sentence-by-sentence-toggle">
              <span>One sentence at a time</span>
            </label>
          </div>
          <div>
            <label>
              <input type="checkbox" id="speak-word-by-word-toggle">
              <span>One word at a time</span>
            </label>
          </div>
          <div>
            <h4 class="w50">
              Choose one of the last two options if you experience problems with text position updates during speech synthesis.
            </h4>
          </div>
        </div>
        <div class="with-rounded-border">
          <h3>Import</h3>
          <div>
            <div>
              <label>
                <input type="radio" name="import-data-replacement" value="add-as-new">
                <span>Add as new always (no replacement)</span>
              </label>
            </div>
            <div>
              <label>
                <input type="radio" name="import-data-replacement" value="append-only">
                <span>Add only if missing (no replacement)</span>
              </label>
            </div>
            <div>
              <label>
                <input type="radio" name="import-data-replacement" value="replace-if-provided">
                <span>Add and replace existing</span>
              </label>
            </div>
          </div>
          <div>
            <button id="import-all-settings-profiles" class="dark-button">Import all settings profiles</button>
            <button id="import-all-texts" class="dark-button">Import all texts</button>
            <button id="import-history" class="dark-button">Import history</button>
          </div>
          <div>
            <button id="import-all-settings-profiles-and-texts" class="dark-button">Import all settings profiles and texts</button>
            <button id="import-all" class="dark-button">Import all</button>
          </div>
        </div>
        <div class="with-rounded-border">
          <h3>Export</h3>
          <div>
            <label>
              <input type="checkbox" id="export-all-texts-with-bookmarks-toggle">
              <span>Export texts with bookmarks</span>
            </label>
          </div>
          <div>
            <label>
              <input type="checkbox" id="export-history-toggle">
              <span>Export all with history</span>
            </label>
          </div>
          <div>
            <button id="export-all-settings-profiles" class="dark-button">Export all settings profiles</button>
            <button id="export-all-texts" class="dark-button">Export all texts</button>
            <button id="export-history" class="dark-button">Export history</button>
          </div>
          <div>
            <button id="export-all-settings-profiles-and-texts" class="dark-button">Export all settings profiles and texts</button>
            <button id="export-all" class="dark-button">Export all</button>
          </div>
        </div>
        <div class="with-rounded-border">
          <h3>Delete</h3>
          <div>
            <button id="delete-all-settings-profiles" class="dark-button">Delete all settings profiles</button>
            <button id="delete-all-texts" class="dark-button">Delete all texts</button>
            <button id="delete-history" class="dark-button">Delete history</button>
            <button id="delete-all-data" class="dark-button">Delete all</button>
          </div>
        </div>
      </div>
      <div id="info-tab" class="tab-content container-items-in-center with-rounded-border">
        <div class="with-rounded-border">
          <div id="report-section">
            <h3>Report</h3>
            <div class="report-table">
              <div class="report-row">
                <span>Today</span>
                <span><span id="report-today-attempts">0</span> attempts</span>
                <span><span id="report-today-time">00:00:00</span></span>
              </div>
              <div class="report-row">
                <span>Last 3 Days</span>
                <span><span id="report-3days-attempts">0</span> attempts</span>
                <span><span id="report-3days-time">00:00:00</span></span>
              </div>
              <div class="report-row">
                <span>This Week</span>
                <span><span id="report-week-attempts">0</span> attempts</span>
                <span><span id="report-week-time">00:00:00</span></span>
              </div>
              <div class="report-row">
                <span>Previous Week</span>
                <span><span id="report-prev-week-attempts">0</span> attempts</span>
                <span><span id="report-prev-week-time">00:00:00</span></span>
              </div>
              <div class="report-row">
                <span>This Month</span>
                <span><span id="report-month-attempts">0</span> attempts</span>
                <span><span id="report-month-time">00:00:00</span></span>
              </div>
              <div class="report-row">
                <span>Previous Month</span>
                <span><span id="report-prev-month-attempts">0</span> attempts</span>
                <span><span id="report-prev-month-time">00:00:00</span></span>
              </div>
            </div>
          </div>
        </div>
        <div class="with-rounded-border">
          <div id="history-section">
            <h3>History</h3>
            <button id="prev-history-item-button" class="dark-button">&lt;</button>
            <input type="number" id="history-index" min="1" value="1">
            <button id="next-history-item-button" class="dark-button">&gt;</button>
            <div class="history-table" id="history-list">
            </div>
          </div>
        </div>
        <div class="with-rounded-border">
          <h3>Chart</h3>
          <div>
            <label>
              Range:
              <select id="chart-time-range">
                <option value="minute">Minute</option>
                <option value="hour" selected>Hour</option>
                <option value="day">Day</option>
                <option value="month">Month</option>
              </select>
            </label>
            <button id="generate-chart-button">Generate chart</button>
          </div>
          <div id="chart-container" style="display: none;">
            <canvas id="chart-object" width="400" height="200"></canvas>
          </div>
        </div>
        <div class="with-rounded-border">
          <div id="help-section">
            <h3>Trial and Error Reading</h3>
            <p>
              Trial and Error Reading is a web-based platform designed to enhance cognitive abilities
              through the iterative decoding of encoded text. By manipulating text and applying transformations to it,
              the platform transforms reading into a challenging puzzle-solving exercise.
              This approach fosters skills such as pattern recognition, problem-solving, intuition, working memory,
              and language proficiency.
            </p>
            <h3>How to use it?</h3>
            <ol>
              <li><strong>Select Text</strong>: go to the Texts tab, click the Download button to fetch a random Wikipedia summary, or paste your text in the text area. Click Save.</li>
              <li><strong>Customize Manipulations</strong>: In the Manipulations tab, adjust settings like skipping letters, shuffling words, or adding colors to make the text a puzzle. Start with simple options (e.g., 10% letter skip).</li>
              <li><strong>Start Reading</strong>: Return to the main screen, click Start (or press Space) to display the manipulated text. Decode it by recognizing patterns and guessing words.</li>
              <li><strong>Control Playback</strong>: Use Play/Pause (Space), Stop (S), or Rewind/Forward (←/→) to navigate. Adjust speed or font size if needed.</li>
              <li><strong>Use Tools</strong>: Click Speak for text-to-speech, Search to find words, or Bookmarks to save progress.</li>
              <li><strong>Track Progress</strong>: Check the Information tab for reports on your attempts and time spent.</li>
              <li><strong>Experiment and Increase Difficulty</strong>: Try harder manipulations (e.g., ROT-N, false letters) and follow recommendations to improve skills.</li>
            </ol>
            <h3>Recommendations</h3>
            <ul>
              <li><strong>Resist checking answers too soon:</strong> Avoid looking up the solution until you're certain you don't know a word or have spent enough time trying to figure it out.</li>
              <li><strong>Take breaks:</strong> Regular breaks can improve your problem-solving efficiency and keep your mind fresh.</li>
              <li><strong>Be patient with progress:</strong> Improvements may take months and depends on how often you train, as well as your diet and sleep quality.</li>
              <li><strong>Short sessions are key:</strong> Training twice a day in short bursts is more effective than one long session daily.</li>
              <li><strong>Quality over quantity:</strong> Fully solving a few sentences per day is better than partially solving many.</li>
              <li><strong>Challenge yourself:</strong> Solving without changing the text combination on the go (via "↻ Words ↻" button) is harder and more beneficial than adjusting it mid-session.</li>
              <li><strong>Increase difficulty:</strong> Continuously ramp up the exercise difficulty to maintain progress, rather than staying at an easy level for too long.</li>
            </ul>
            <div class="ta-center">
              <h3>
                <a href="https://github.com/Quwarm/Trial-and-Error-Reading" target="_blank">GitHub</a>
              </h3>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="text-helper" style="display: none;"></div>

  <script>
    Chart.register(ChartZoom);

    const MarqueeReader = {
      version: '2.00',
      constructed: false,

      fromContinue: false,
      animationTimer: null,
      currentPosition: null,
      targetWordIndex: null,
      animationStartTime: null,
      lastUpdateTime: null,
      colorMap: new Map(),
      colorList: [],
      rotNLetterMap: new Map(),
      letterMapItemMaxLength: 0,

      realText: '', /* for comparing */
      realText1List: [], /* for words after 1st manipulations step [sentences & words] */
      realText1RefList: [], /* for ref words after 1 manipulations step */
      realText2List: [],  /* for words after 2nd manipulations step [letters] */
      realTextDiffBase: 0, /* difference: realText1List - realText2List */
      realTextDiff: 0, /* difference: realText1List - realText2List */
      textParameters: null,

      textNeedsUpdate: true,
      previousSettings: {},
      previousPosition: null,

      wasStarted: false,
      startProgress: 0,
      endProgress: 0,
      wasColorTaskEnabled: null,
      wasColorTaskChecked: false,
      isLoopEnabled: false,
      wordCount: 0,

      animationInfoUpdateDelay: 200,
      infoSecondsRemaining: '',
      infoWPM: '',
      infoProgress: '',
      stepSize: 0,
      stepDelay: 0,
      newStepSize: null,
      newStepDelay: null,
      newSpeed: null,

      elements: {},
      controllerForUnload: null,

      databaseName: 'TrialAndErrorReadingDB',
      databaseVersion: 3,
      database: null,
      defaultTextUpperLimit: 2000000,
      defaultTextName: 'Default',
      currentTextName: 'Default',
      currentTextBookmarks: [],
      textIsModified: false,
      textsLastPositions: {},
      defaultSettingsProfileName: 'Default',
      currentSettingsProfileName: 'Default',
      settingsProfileIsModified: false,
      deleteAllDataViewCounter: 0,
      deleteAllDataViewMax: 2,

      forceNewHistoryItem: true,
      history: [],
      historyTypes: {
        speak: 'Speak',
        play: 'Play',
      },
      report: {
        today: { attempts: 0, time: 0 },
        last3Days: { attempts: 0, time: 0 },
        thisWeek: { attempts: 0, time: 0 },
        prevWeek: { attempts: 0, time: 0 },
        thisMonth: { attempts: 0, time: 0 },
        prevMonth: { attempts: 0, time: 0 }
      },

      vowelPattern: null,
      letterPattern: null,
      wordPattern: null,
      notLetterPattern: null,
      notWordPattern: null,
      upperCaseWordStartPattern: null,
      spacePattern: null,
      vowelPatternG: null,
      letterPatternG: null,
      wordPatternG: null,

      cachedContainerWidth: null,
      cachedTextWidth: null,

      isSpeaking: false,
      speechSynthesis: null,
      currentVoice: null,
      voices: [],
      speechRate: 100,
      speechPitch: 100,
      speechVolume: 100,

      isTextViewActive: false,

      isSearchActive: false,
      searchQuery: '',
      searchMatches: [],
      currentMatchIndex: -1,

      isBookmarksActive: false,
      tmpBookmarks: [],

      sentenceInitCount: 0,
      sentenceCounter: 0,
      sentenceHash: 0,
      sentenceDownloadDelay: 1050,

      newWordMark: 'wmrk',

      importDataReplacementVariants: {
        addAsNew: 'add-as-new',
        appendOnly: 'append-only',
        replaceIfProvided: 'replace-if-provided',
      },

      themes: [
        'dark',
        'light'
      ],

      marqueeThemes: [
        'marquee-theme-1',
        'marquee-theme-2',
        'marquee-theme-3',
        'marquee-theme-4',
        'marquee-theme-5',
        'marquee-theme-6'
      ],

      sentenceWordsmyth1Generator: null,
      sentenceWordsmyth2Generator: null,
      sentenceWordsmyth3Generator: null,
      sentenceMerriamWebsterGenerator: null,
      alphabets: [],

      marksReplacementTrans: {
        '\u00C0': 'A', '\u00C1': 'A',
        '\u00C8': 'E', '\u00C9': 'E',
        '\u00CC': 'I', '\u00CD': 'I',
        '\u00D2': 'O', '\u00D3': 'O',
        '\u00D9': 'U', '\u00DA': 'U',
        '\u00DD': 'Y',
        '\u00E0': 'a', '\u00E1': 'a',
        '\u00E8': 'e', '\u00E9': 'e',
        '\u00EC': 'i', '\u00ED': 'i',
        '\u00F2': 'o', '\u00F3': 'o',
        '\u00F9': 'u', '\u00FA': 'u',
        '\u00FD': 'y',
      },

      settingsNames: {
        version: 'sle_version',

        /* texts */
        currentTextName: 'sle_current_text_name',
        text: 'sle_text',
        textBookmarks: 'sle_text_bookmarks',
        texts: 'sle_texts',
        textsLastPositions: 'sle_texts_last_positions',

        /* settings profiles */
        currentSettingsProfile: 'sle_current_settings_profile',
        settingsProfile: 'sle_settings_profile',
        settingsProfiles: 'sle_settings_profiles',

        /* history */
        history: 'sle_history',

        /* profile settings */
        colorMap: 'sle_color_task_map',
        colorTaskToggle: 'sle_color_task_toggle',
        colorTaskLetters: 'sle_color_task_letters',
        colorTaskColors: 'sle_color_task_colors',
        colorTaskBackgroundColoring: 'sle_color_task_background_coloring',
        speed: 'sle_speed',
        speedSmooth: 'sle_speed_smooth',
        skippingLetters: 'sle_skipping_letters',
        reversingLetters: 'sle_reversing_letters',
        shufflingLetters: 'sle_shuffling_letters',
        falseLetters: 'sle_false_letters',
        eliminatingLetters: 'sle_eliminating_letters',
        skippingWords: 'sle_skipping_words',
        shufflingWords: 'sle_shuffling_words',
        falseWords: 'sle_false_words',
        concatWords: 'sle_concat_words',
        shufflingSentences: 'sle_shuffling_sentences',
        rotatingWords: 'sle_rotating_words',
        rotatingLetters: 'sle_rotating_letters',
        mirroringWords: 'sle_mirroring_words',
        mirroringLetters: 'sle_mirroring_letters',
        rotNToggle: 'sle_rot_n_toggle',
        rotNNumberMin: 'sle_rot_n_number_min',
        rotNNumberMax: 'sle_rot_n_number_max',
        rotNExcludeZero: 'sle_rot_n_exclude_zero',
        rotNEachMapping: 'sle_rot_n_each_mapping',
        rotNUpperCaseLowerCase: 'sle_rot_n_upper_case_lower_case',
        rotNComplexity: 'sle_rot_n_complexity',
        rotNMap: 'sle_rot_n_map',
        rotNLanguage: 'sle_rot_n_language',
        skewingToggle: 'sle_skewing_toggle',
        skewingType: 'sle_skewing_type',
        skewingNumberMin: 'sle_skewing_number_min',
        skewingNumberMax: 'sle_skewing_number_max',
        textSize: 'sle_text_size',
        marqueeTheme: 'sle_marquee_theme',
        textDirection: 'sle_text_direction',
        fontFamily: 'sle_font_family',
        fontStyle: 'sle_font_style',
        rsvpMode: 'sle_rsvp_mode',
        rsvpPunctuationDelay: 'sle_rsvp_punctuation_delay',

        /* non-profile settings */
        showColorInfoToggle: 'sle_show_color_info_toggle',
        appendTextToggle: 'sle_append_text_toggle',
        importDataReplacement: 'sle_import_data_replacement',
        fasterTransitionsToggle: 'sle_faster_transitions_toggle',
        speakWordByWordToggle: 'sle_speak_word_by_word',
        speakSentenceBySentenceToggle: 'sle_speak_sentence_by_sentence',
        exportTextsWithBookmarksToggle: 'sle_export_texts_with_bookmarks_toggle',
        sentenceCountToGenerate: 'sle_sentence_count_to_generate',
        wikiLang: 'sle_wiki_lang',
        loop: 'sle_loop',
        theme: 'sle_theme',
        appSizeToggle: 'sle_app_size_toggle',
        activeTab: 'sle_active_tab',
        lastPosition: 'sle_last_position',
        attemptMinTime: 'sle_attempt_min_time',
        showHideTextToggle: 'sle_show_hide_text_toggle',
        removeMarksToggle: 'sle_remove_marks_toggle',
        geminiKey: 'sle_gemini_key',
        geminiQuery: 'sle_gemini_query',
        geminiModel: 'sle_gemini_model',

        /* text-to-speech */
        voiceButton: 'sle_voice_button',
        voice: 'sle_voice',
        voiceSpeechRate: 'sle_voice_speech_rate',
        voiceSpeechPitch: 'sle_voice_speech_pitch',
        voiceSpeechVolume: 'sle_voice_speech_volume',

        /* search */
        searchButton: 'sle_search_button',

        /* bookmarks */
        bookmarksButton: 'sle_bookmarks_button',

        /* text view */
        textViewButton: 'sle_text_view_button',

        /* history */
        historyStatus: 'sle_history_status',
        exportHistoryToggle: 'sle_export_history_toggle',
      },

      getDefaultSettingsProfile() {
        const settings = {};
        settings[this.settingsNames.colorMap] = '{}';
        settings[this.settingsNames.colorTaskToggle] = false;
        settings[this.settingsNames.colorTaskLetters] = '1';
        settings[this.settingsNames.colorTaskColors] = '';
        settings[this.settingsNames.colorTaskBackgroundColoring] = true;
        settings[this.settingsNames.speed] = '500';
        settings[this.settingsNames.speedSmooth] = false;
        settings[this.settingsNames.skippingLetters] = 'no';
        settings[this.settingsNames.shufflingLetters] = 'no';
        settings[this.settingsNames.falseLetters] = 'no';
        settings[this.settingsNames.eliminatingLetters] = 'no';
        settings[this.settingsNames.skippingWords] = 'no';
        settings[this.settingsNames.shufflingWords] = 'no';
        settings[this.settingsNames.reversingLetters] = 'no';
        settings[this.settingsNames.falseWords] = 'no';
        settings[this.settingsNames.concatWords] = 'no';
        settings[this.settingsNames.shufflingSentences] = 'no';
        settings[this.settingsNames.rotatingWords] = 'no';
        settings[this.settingsNames.rotatingLetters] = 'no';
        settings[this.settingsNames.mirroringWords] = 'no';
        settings[this.settingsNames.mirroringLetters] = 'no';
        settings[this.settingsNames.rotNToggle] = false;
        settings[this.settingsNames.rotNNumberMin] = '1';
        settings[this.settingsNames.rotNNumberMax] = '1';
        settings[this.settingsNames.rotNExcludeZero] = false;
        settings[this.settingsNames.rotNEachMapping] = false;
        settings[this.settingsNames.rotNUpperCaseLowerCase] = true;
        settings[this.settingsNames.rotNComplexity] = '0';
        settings[this.settingsNames.rotNMap] = '{}';
        settings[this.settingsNames.rotNLanguage] = 'English';
        settings[this.settingsNames.skewingToggle] = false;
        settings[this.settingsNames.skewingType] = 'text';
        settings[this.settingsNames.skewingNumberMin] = '-30';
        settings[this.settingsNames.skewingNumberMax] = '30';
        settings[this.settingsNames.textSize] = '42';
        settings[this.settingsNames.marqueeTheme] = 'marquee-theme-1';
        settings[this.settingsNames.textDirection] = 'ltr';
        settings[this.settingsNames.fontFamily] = '-';
        settings[this.settingsNames.fontStyle] = '-';
        settings[this.settingsNames.rsvpPunctuationDelay] = '150';
        return settings;
      },

      getCurrentSettingsProfile() {
        const settings = {};
        settings[this.settingsNames.colorMap] = JSON.stringify(Object.fromEntries(this.colorMap));
        settings[this.settingsNames.colorTaskToggle] = this.elements.colorEncoderToggle.checked;
        settings[this.settingsNames.colorTaskLetters] = this.elements.colorLetterCount.value;
        settings[this.settingsNames.colorTaskColors] = this.elements.colorInput.value;
        settings[this.settingsNames.colorTaskBackgroundColoring] = this.elements.textBackgroundColoringToggle.checked;
        settings[this.settingsNames.speed] = this.elements.speedNumber.value;
        settings[this.settingsNames.speedSmooth] = this.elements.speedSmoothToggle.checked;
        settings[this.settingsNames.rsvpMode] = this.elements.rsvpToggle.checked;
        settings[this.settingsNames.skippingLetters] = this.elements.letterSkipSelect.value;
        settings[this.settingsNames.reversingLetters] = this.elements.letterReverseSelect.value;
        settings[this.settingsNames.shufflingLetters] = this.elements.letterShuffleSelect.value;
        settings[this.settingsNames.falseLetters] = this.elements.letterFalseSelect.value;
        settings[this.settingsNames.eliminatingLetters] = this.elements.letterEliminationSelect.value;
        settings[this.settingsNames.skippingWords] = this.elements.wordSkipSelect.value;
        settings[this.settingsNames.shufflingWords] = this.elements.wordShuffleSelect.value;
        settings[this.settingsNames.falseWords] = this.elements.wordFalseSelect.value;
        settings[this.settingsNames.concatWords] = this.elements.wordConcatSelect.value;
        settings[this.settingsNames.shufflingSentences] = this.elements.sentenceShuffleSelect.value;
        settings[this.settingsNames.rotatingWords] = this.elements.rotatingWordsSelect.value;
        settings[this.settingsNames.rotatingLetters] = this.elements.rotatingLettersSelect.value;
        settings[this.settingsNames.mirroringWords] = this.elements.mirroringWordsSelect.value;
        settings[this.settingsNames.mirroringLetters] = this.elements.mirroringLettersSelect.value;
        settings[this.settingsNames.rotNToggle] = this.elements.rotNToggle.checked;
        settings[this.settingsNames.rotNNumberMin] = this.elements.rotNNumberMin.value;
        settings[this.settingsNames.rotNNumberMax] = this.elements.rotNNumberMax.value;
        settings[this.settingsNames.rotNExcludeZero] = this.elements.rotNExcludeZero.checked;
        settings[this.settingsNames.rotNEachMapping] = this.elements.rotNEachMapping.checked;
        settings[this.settingsNames.rotNUpperCaseLowerCase] = this.elements.rotNUpperCaseLowerCase.checked;
        settings[this.settingsNames.rotNComplexity] = this.elements.rotNComplexity.value;
        settings[this.settingsNames.rotNMap] = JSON.stringify(Object.fromEntries(this.rotNLetterMap));
        settings[this.settingsNames.rotNLanguage] = this.elements.rotNLanguageSelect.value;
        settings[this.settingsNames.skewingToggle] = this.elements.skewingToggle.checked;
        settings[this.settingsNames.skewingType] = this.elements.skewingSelect.value;
        settings[this.settingsNames.skewingNumberMin] = this.elements.skewingNumberMin.value;
        settings[this.settingsNames.skewingNumberMax] = this.elements.skewingNumberMax.value;
        settings[this.settingsNames.textSize] = this.elements.fontSizeNumber.value;
        settings[this.settingsNames.marqueeTheme] = this.elements.marqueeThemeSelect.value;
        settings[this.settingsNames.textDirection] = this.elements.textDirectionSelect.value;
        settings[this.settingsNames.fontFamily] = this.elements.fontFamilyInput.value;
        settings[this.settingsNames.fontStyle] = this.elements.fontStyleSelect.value;
        settings[this.settingsNames.rsvpPunctuationDelay] = this.elements.rsvpPunctuationDelayNumber.value;
        return settings;
      },

      setSettingsProfile(settingsProfileData) {
        const defaultSettings = this.getDefaultSettingsProfile();
        const keys = Object.keys(settingsProfileData);

        let currentKey = this.settingsNames.colorTaskToggle;
        this.elements.colorEncoderToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.colorTaskLetters;
        this.elements.colorLetterCount.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.colorTaskColors;
        this.elements.colorInput.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.colorTaskBackgroundColoring;
        this.elements.textBackgroundColoringToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.speed;
        this.elements.speedNumber.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.speedSmooth;
        this.elements.speedSmoothToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rsvpMode;
        this.elements.rsvpToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skippingLetters;
        this.elements.letterSkipSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.reversingLetters;
        this.elements.letterReverseSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.shufflingLetters;
        this.elements.letterShuffleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.falseLetters;
        this.elements.letterFalseSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.eliminatingLetters;
        this.elements.letterEliminationSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skippingWords;
        this.elements.wordSkipSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.shufflingWords;
        this.elements.wordShuffleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.falseWords;
        this.elements.wordFalseSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.concatWords;
        this.elements.wordConcatSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.shufflingSentences;
        this.elements.sentenceShuffleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotatingWords;
        this.elements.rotatingWordsSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotatingLetters;
        this.elements.rotatingLettersSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.mirroringWords;
        this.elements.mirroringWordsSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.mirroringLetters;
        this.elements.mirroringLettersSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNToggle;
        this.elements.rotNToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNNumberMin;
        this.elements.rotNNumberMin.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNNumberMax;
        this.elements.rotNNumberMax.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNExcludeZero;
        this.elements.rotNExcludeZero.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNEachMapping;
        this.elements.rotNEachMapping.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNUpperCaseLowerCase;
        this.elements.rotNUpperCaseLowerCase.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNComplexity;
        this.elements.rotNComplexity.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rotNMap;
        this.rotNLetterMap = new Map(Object.entries(JSON.parse(keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey])));

        currentKey = this.settingsNames.colorMap;
        this.colorMap = new Map(Object.entries(JSON.parse(keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey])));
        this.colorList = [...this.colorMap.keys()];

        currentKey = this.settingsNames.rotNLanguage;
        this.elements.rotNLanguageSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skewingToggle;
        this.elements.skewingToggle.checked = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skewingType;
        this.elements.skewingSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skewingNumberMin;
        this.elements.skewingNumberMin.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.skewingNumberMax;
        this.elements.skewingNumberMax.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.textSize;
        this.elements.fontSizeNumber.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.marqueeTheme;
        this.elements.marqueeThemeSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.textDirection;
        this.elements.textDirectionSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.fontFamily;
        this.elements.fontFamilyInput.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.fontStyle;
        this.elements.fontStyleSelect.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        currentKey = this.settingsNames.rsvpPunctuationDelay;
        this.elements.rsvpPunctuationDelayNumber.value = keys.includes(currentKey) ? settingsProfileData[currentKey] : defaultSettings[currentKey];

        this.adjustSpeed(this.elements.speedNumber.value);
        this.adjustFontSize(this.elements.fontSizeNumber.value);
        this.adjustRsvpPunctuationDelay(this.elements.rsvpPunctuationDelayNumber.value);
        this.toggleRotN();
        this.toggleRotNGenerate(true);
        this.toggleSkewing();
        this.toggleMarqueeTheme();
        this.toggleColorEncoder(this.currentPosition != null);
        this.toggleColorDetails();
        this.toggleTextDirection();
        this.toggleFontFamily();
        this.updateTextStats();
        this.updateTextViewStats();
      },

      initialize() {
        const currentReader = this;
        console.info(currentReader);
        currentReader.loadLastVersion();
        currentReader.loadBackground();
        currentReader.cacheElements();
        try {
          currentReader.speechSynthesis = window.speechSynthesis;
          currentReader.loadVoices();
          currentReader.loadDb(function () {
            try {
              currentReader.setupPatterns();
              currentReader.bindEvents();
              currentReader.loadPreferences();
              currentReader.loadHistory();
            }
            catch (err) {
              console.error(err);
              currentReader.elements.mainContainer.innerHTML = `Not supported:<br>${err}`;
            }
          });
        }
        catch (err) {
          console.error(err);
          currentReader.elements.mainContainer.innerHTML = `Not supported:<br>${err}`;
        }
      },

      loadLastVersion() {
        let changed = false;
        const lastVersion = localStorage.getItem(this.settingsNames.version);
        if (lastVersion == null) {
          for (let key of Object.values(this.settingsNames)) {
            if (key !== this.settingsNames.text && key !== this.settingsNames.colorTaskColors) {
              const value = localStorage.getItem(key);
              if (value != null) {
                localStorage.removeItem(key);
                changed = true;
              }
            }
          }
        }
        localStorage.setItem(this.settingsNames.version, this.version);
        if (changed) {
          this.locationReload();
          throw null;
        }
      },

      loadBackground() {
        this.elements.body = document.body;
        this.elements.body.classList.remove('light');
        this.elements.body.classList.remove('dark');
        this.elements.body.classList.add(localStorage.getItem(this.settingsNames.theme) || this.themes[0]);
      },

      cacheElements() {
        this.elements.addBookmarkButton = document.getElementById("add-bookmark-button");
        this.elements.appendTextToggle = document.getElementById('append-text-toggle');
        this.elements.attemptMinTimeInput = document.getElementById('attempt-min-time-number');
        this.elements.bookmarkNameInput = document.getElementById("bookmark-name-input");
        this.elements.bookmarksButton = document.getElementById("bookmarks-button");
        this.elements.bookmarksContainer = document.getElementById("bookmarks-container");
        this.elements.bookmarksControls = document.getElementById("bookmarks-controls");
        this.elements.bookmarksList = document.getElementById("bookmarks-list");
        this.elements.cancelBookmarksButton = document.getElementById("cancel-bookmarks-button");
        this.elements.chartContainer = document.getElementById('chart-container');
        this.elements.chartMetricSelect = document.getElementById('chart-metric');
        this.elements.chartObject = document.getElementById('chart-object');
        this.elements.chartTimeRangeSelect = document.getElementById('chart-time-range');
        this.elements.clearTextButton = document.getElementById('clear-text-button');
        this.elements.colorDetails = document.getElementById('color-details');
        this.elements.colorEncoderDiv = document.getElementById('color-encoder-div');
        this.elements.colorEncoderOptions = document.getElementById('color-encoder-options');
        this.elements.colorEncoderToggle = document.getElementById('color-encoder-toggle');
        this.elements.colorInput = document.getElementById('color-input');
        this.elements.colorLetterCount = document.getElementById('color-letter-count');
        this.elements.controlsContainer = document.getElementById('controls-container');
        this.elements.controlsContainerFooter = document.getElementById('controls-container-footer');
        this.elements.copyCurrentText = document.getElementById('copy-current-text');
        this.elements.copyMarqueeText = document.getElementById('copy-marquee-text');
        this.elements.deleteAllData = document.getElementById('delete-all-data');
        this.elements.deleteAllSettingsProfiles = document.getElementById('delete-all-settings-profiles');
        this.elements.deleteAllTexts = document.getElementById('delete-all-texts');
        this.elements.deleteHistory = document.getElementById('delete-history');
        this.elements.deleteSettingsProfileButton = document.getElementById('delete-settings-profile-button');
        this.elements.deleteTextButton = document.getElementById('delete-text-button');
        this.elements.dumpColors = document.getElementById('dump-colors');
        this.elements.duplicateSettingsProfileButton = document.getElementById('duplicate-settings-profile-button');
        this.elements.duplicateTextButton = document.getElementById('duplicate-text-button');
        this.elements.exportAll = document.getElementById('export-all');
        this.elements.exportAllSettingsProfiles = document.getElementById('export-all-settings-profiles');
        this.elements.exportAllSettingsProfilesAndTexts = document.getElementById('export-all-settings-profiles-and-texts');
        this.elements.exportAllTexts = document.getElementById('export-all-texts');
        this.elements.exportAllTextsWithBookmarksToggle = document.getElementById('export-all-texts-with-bookmarks-toggle');
        this.elements.exportHistory = document.getElementById('export-history');
        this.elements.exportHistoryToggle = document.getElementById('export-history-toggle');
        this.elements.fasterTransitionsToggle = document.getElementById("faster-transitions-toggle");
        this.elements.fastForwardButton = document.getElementById('fast-forward-button');
        this.elements.fontFamilyInput = document.getElementById('font-input');
        this.elements.fontListSelect = document.getElementById('font-list-select');
        this.elements.fontLoadDiv = document.getElementById('font-load-div');
        this.elements.fontStyleSelect = document.getElementById('font-style-select');
        this.elements.fontSizeNumber = document.getElementById('font-size-number');
        this.elements.fontSizeSlider = document.getElementById('font-size-slider');
        this.elements.fullSizeToggle = document.getElementById('full-size-toggle');
        this.elements.generateChartButton = document.getElementById('generate-chart-button');
        this.elements.geminiKeyInput = document.getElementById('gemini-key-input');
        this.elements.geminiModelSelect = document.getElementById('gemini-model-select');
        this.elements.geminiQueryInput = document.getElementById('gemini-query-input');
        this.elements.hiddenContent1 = document.getElementById('hidden-content-1');
        this.elements.historyEnableToggle = document.getElementById('history-enable-toggle');
        this.elements.historyIndex = document.getElementById('history-index');
        this.elements.historyList = document.getElementById('history-list');
        this.elements.importAll = document.getElementById('import-all');
        this.elements.importAllSettingsProfiles = document.getElementById('import-all-settings-profiles');
        this.elements.importAllSettingsProfilesAndTexts = document.getElementById('import-all-settings-profiles-and-texts');
        this.elements.importAllTexts = document.getElementById('import-all-texts');
        this.elements.importDataReplacement = Array.from(document.getElementsByName("import-data-replacement"));
        this.elements.importHistory = document.getElementById('import-history');
        this.elements.letterEliminationSelect = document.getElementById('letter-elimination-select');
        this.elements.letterFalseSelect = document.getElementById('letter-false-select');
        this.elements.letterReverseSelect = document.getElementById('letter-reverse-select');
        this.elements.letterShuffleSelect = document.getElementById('letter-shuffle-select');
        this.elements.letterSkipSelect = document.getElementById('letter-skip-select');
        this.elements.loadFile = document.getElementById('load-file');
        this.elements.loadGemini = document.getElementById('load-gemini');
        this.elements.loadMetaphorpsum = document.getElementById('load-metaphorpsum');
        this.elements.loadSentenceMerriamWebster = document.getElementById('load-sentence-merriam-webster');
        this.elements.loadSentenceWordsmythAdvanced = document.getElementById('load-sentence-wordsmyth-advanced');
        this.elements.loadSentenceWordsmythBeginner = document.getElementById('load-sentence-wordsmyth-beginner');
        this.elements.loadSentenceWordsmythIntermediate = document.getElementById('load-sentence-wordsmyth-intermediate');
        this.elements.loadUnderthekey = document.getElementById('load-underthekey');
        this.elements.loadWikiButton = document.getElementById('load-wiki-button');
        this.elements.loadWikiLanguageSelect = document.getElementById('load-wiki-language-select');
        this.elements.loopToggle = document.getElementById('loop-toggle');
        this.elements.mainContainer = document.getElementById('main-container');
        this.elements.marqueeContainer = document.getElementById('marquee-container');
        this.elements.marqueeDisplay = document.getElementById('marquee-display');
        this.elements.marqueeThemeSelect = document.getElementById('marquee-theme-select');
        this.elements.mirroringLettersSelect = document.getElementById('mirroring-letters-select');
        this.elements.mirroringWordsSelect = document.getElementById('mirroring-words-select');
        this.elements.newSettingsProfileButton = document.getElementById('new-settings-profile-button');
        this.elements.newTextButton = document.getElementById('new-text-button');
        this.elements.nextHistoryItemButton = document.getElementById('next-history-item-button');
        this.elements.playPauseButton = document.getElementById('play-pause-button');
        this.elements.prevHistoryItemButton = document.getElementById('prev-history-item-button');
        this.elements.progressBar = document.getElementById('progress-bar');
        this.elements.progressBarContainer = document.getElementById('progress-bar-container');
        this.elements.progressDisplay = document.getElementById('progress-display');
        this.elements.randomParagraphsCaption = document.getElementById('random-paragraphs-caption');
        this.elements.refreshColors = document.getElementById('refresh-colors');
        this.elements.refreshSentences = document.getElementById('refresh-sentences');
        this.elements.refreshView = document.getElementById('refresh-view');
        this.elements.refreshWords = document.getElementById('refresh-words');
        this.elements.removeMarksToggle = document.getElementById('remove-marks-toggle');
        this.elements.report3DaysAttempts = document.getElementById('report-3days-attempts');
        this.elements.report3DaysTime = document.getElementById('report-3days-time');
        this.elements.reportMonthAttempts = document.getElementById('report-month-attempts');
        this.elements.reportMonthTime = document.getElementById('report-month-time');
        this.elements.reportPrevMonthAttempts = document.getElementById('report-prev-month-attempts');
        this.elements.reportPrevMonthTime = document.getElementById('report-prev-month-time');
        this.elements.reportPrevWeekAttempts = document.getElementById('report-prev-week-attempts');
        this.elements.reportPrevWeekTime = document.getElementById('report-prev-week-time');
        this.elements.reportTodayAttempts = document.getElementById('report-today-attempts');
        this.elements.reportTodayTime = document.getElementById('report-today-time');
        this.elements.reportWeekAttempts = document.getElementById('report-week-attempts');
        this.elements.reportWeekTime = document.getElementById('report-week-time');
        this.elements.resetSettingsProfileButton = document.getElementById('reset-settings-profile-button');
        this.elements.rewindButton = document.getElementById('rewind-button');
        this.elements.rotatingLettersSelect = document.getElementById('rotating-letters-select');
        this.elements.rotatingWordsSelect = document.getElementById('rotating-words-select');
        this.elements.rotNComplexity = document.getElementById('rot-n-complexity');
        this.elements.rotNDiv = document.getElementById('rot-n-div');
        this.elements.rotNEachMapping = document.getElementById('rot-n-each-mapping');
        this.elements.rotNExcludeZero = document.getElementById('rot-n-exclude-zero');
        this.elements.rotNGenerateButton = document.getElementById('rot-n-generate-button');
        this.elements.rotNLanguageInfo = document.getElementById('rot-n-language-info');
        this.elements.rotNLanguageSelect = document.getElementById('rot-n-language-select');
        this.elements.rotNNumberMax = document.getElementById('rot-n-number-max');
        this.elements.rotNNumberMin = document.getElementById('rot-n-number-min');
        this.elements.rotNOptions = document.getElementById('rot-n-options');
        this.elements.rotNToggle = document.getElementById('rot-n-toggle');
        this.elements.rotNUpperCaseLowerCase = document.getElementById('rot-n-upper-case-lower-case');
        this.elements.rsvpPunctuationDelaySlider = document.getElementById('rsvp-punctuation-delay-slider');
        this.elements.rsvpPunctuationDelayNumber = document.getElementById('rsvp-punctuation-delay-number');
        this.elements.rsvpToggle = document.getElementById('rsvp-toggle');
        this.elements.saveBookmarksButton = document.getElementById("save-bookmarks-button");
        this.elements.saveSettingsProfileButton = document.getElementById('save-settings-profile-button');
        this.elements.saveTextButton = document.getElementById('save-text-button');
        this.elements.searchButton = document.getElementById('search-button');
        this.elements.searchContainer = document.getElementById('search-container');
        this.elements.searchControls = document.getElementById('search-controls');
        this.elements.searchInput = document.getElementById('search-input');
        this.elements.searchNextButton = document.getElementById('search-next-button');
        this.elements.searchPrevButton = document.getElementById('search-prev-button');
        this.elements.sentenceCountInput = document.getElementById('sentence-count-input');
        this.elements.sentenceShuffleSelect = document.getElementById('sentence-shuffle-select');
        this.elements.settingsProfileSelect = document.getElementById('settings-profile-select');
        this.elements.showBookmarksButtonToggle = document.getElementById('show-bookmarks-button-toggle');
        this.elements.showColorInfoToggle = document.getElementById('show-color-info-toggle');
        this.elements.showHideTextToggle = document.getElementById('show-hide-text-toggle');
        this.elements.showSearchButtonToggle = document.getElementById('show-search-button-toggle');
        this.elements.showSpeakButtonToggle = document.getElementById('show-speak-button-toggle');
        this.elements.showTextViewButtonToggle = document.getElementById('show-text-view-button-toggle');
        this.elements.shuffleParagraphs = document.getElementById('shuffle-paragraphs');
        this.elements.shuffleSentences = document.getElementById('shuffle-sentences');
        this.elements.skewingDiv = document.getElementById('skewing-div');
        this.elements.skewingNumberMax = document.getElementById('skewing-number-max');
        this.elements.skewingNumberMin = document.getElementById('skewing-number-min');
        this.elements.skewingOptions = document.getElementById('skewing-options');
        this.elements.skewingSelect = document.getElementById('skewing-select');
        this.elements.skewingToggle = document.getElementById('skewing-toggle');
        this.elements.speakButton = document.getElementById('speak-button');
        this.elements.speakSentenceBySentenceToggle = document.getElementById("speak-sentence-by-sentence-toggle");
        this.elements.speakWordByWordToggle = document.getElementById("speak-word-by-word-toggle");
        this.elements.speechPitchNumber = document.getElementById('speech-pitch-number');
        this.elements.speechPitchSlider = document.getElementById('speech-pitch-slider');
        this.elements.speechRateNumber = document.getElementById('speech-rate-number');
        this.elements.speechRateSlider = document.getElementById('speech-rate-slider');
        this.elements.speechVolumeNumber = document.getElementById('speech-volume-number');
        this.elements.speechVolumeSlider = document.getElementById('speech-volume-slider');
        this.elements.speedNumber = document.getElementById('speed-number');
        this.elements.speedSlider = document.getElementById('speed-slider');
        this.elements.speedSmoothToggle = document.getElementById('speed-smooth-toggle');
        this.elements.splitIntoParagraphs = document.getElementById('split-into-paragraphs');
        this.elements.stopButton = document.getElementById('stop-button');
        this.elements.tabButtons = document.querySelectorAll('.tab-button');
        this.elements.tabContent = document.getElementById('tab-content');
        this.elements.tabContents = document.querySelectorAll('.tab-content');
        this.elements.tabNavigation = document.getElementById('tab-navigation');
        this.elements.textBackgroundColoringToggle = document.getElementById('text-background-coloring-toggle');
        this.elements.textDirectionSelect = document.getElementById('text-direction-select');
        this.elements.textHelper = document.getElementById('text-helper');
        this.elements.textInput = document.getElementById('text-input');
        this.elements.textParameterAfterManipulationsComplexity = document.getElementById('text-parameter-text-after-manipulations-complexity');
        this.elements.textParameterAllSymbolsNumber = document.getElementById('text-parameter-all-symbols-number');
        this.elements.textParameterAlphabetLettersNumber = document.getElementById('text-parameter-alphabet-letters-number');
        this.elements.textParameterAlphabetLettersPercent = document.getElementById('text-parameter-alphabet-letters-percent');
        this.elements.textParameterAverageWordFrequency = document.getElementById('text-parameter-average-word-frequency');
        this.elements.textParameterAverageWordLength = document.getElementById('text-parameter-average-word-length');
        this.elements.textParameterLettersColoredNumber = document.getElementById('text-parameter-letters-colored-number');
        this.elements.textParameterLettersColoredPercent = document.getElementById('text-parameter-letters-colored-percent');
        this.elements.textParameterShannonEntropyNumber = document.getElementById('text-parameter-shannon-entropy-number');
        this.elements.textParameterUniqueWordsNumber = document.getElementById('text-parameter-unique-words-number');
        this.elements.textParameterUniqueWordsPercent = document.getElementById('text-parameter-unique-words-percent');
        this.elements.textParameterWordsNumber = document.getElementById('text-parameter-words-number');
        this.elements.textSelect = document.getElementById('text-select');
        this.elements.textToSpeechContainer = document.getElementById('text-to-speech-container');
        this.elements.textViewButton = document.getElementById('text-view-button');
        this.elements.textViewContainer = document.getElementById("text-view-container");
        this.elements.themeToggle = document.getElementById('theme-toggle');
        this.elements.voiceSelect = document.getElementById('voice-select');
        this.elements.wordConcatSelect = document.getElementById('word-concat-select');
        this.elements.wordFalseSelect = document.getElementById('word-false-select');
        this.elements.wordShuffleSelect = document.getElementById('word-shuffle-select');
        this.elements.wordSkipSelect = document.getElementById('word-skip-select');

        this.cachedContainerWidth = null;
        this.cachedTextWidth = null;
        /* this.elements.deleteAllData.style.display = 'none'; */
      },

      loadDb(callback) {
        const currentReader = this;
        const hideTextSelectElements = function () {
          currentReader.elements.textSelect.style.display = 'none';
          currentReader.elements.newTextButton.style.display = 'none';
          currentReader.elements.duplicateTextButton.style.display = 'none';
          currentReader.elements.deleteTextButton.style.display = 'none';
          currentReader.elements.settingsProfileSelect.style.display = 'none';
          currentReader.elements.newSettingsProfileButton.style.display = 'none';
          currentReader.elements.duplicateSettingsProfileButton.style.display = 'none';
          currentReader.elements.deleteSettingsProfileButton.style.display = 'none';
          currentReader.elements.showBookmarksButtonToggle.checked = false;
          currentReader.elements.showBookmarksButtonToggle.style.display = 'none';
          currentReader.elements.bookmarksButton.style.display = 'none';
        }
        currentReader.database = null;
        try {
          const request = indexedDB.open(currentReader.databaseName, currentReader.databaseVersion);
          request.onupgradeneeded = function (event) {
            currentReader.database = event.target.result;
            if (currentReader.databaseVersion === 3) {
              currentReader.database.createObjectStore(currentReader.settingsNames.texts, { keyPath: "title" });
              currentReader.database.createObjectStore(currentReader.settingsNames.settingsProfiles, { keyPath: "name" });
              currentReader.database.createObjectStore(currentReader.settingsNames.history, { keyPath: 'timestamp' });
            }
          };
          request.onsuccess = function (event) {
            currentReader.database = event.target.result;
            return callback();
          };
          request.onerror = function (event) {
            currentReader.database = null;
            const message = `IndexedDB error: ${event.target.error}`;
            console.error(event.target.error);
            hideTextSelectElements();
            alert(message);
            return callback();
          };
          request.onblocked = function (event) {
            currentReader.database = null;
            const message = `IndexedDB blocked`;
            console.error(message);
            hideTextSelectElements();
            alert(message);
            return callback();
          };
        } catch (err) {
          currentReader.database = null;
          console.error(err);
          hideTextSelectElements();
          alert(message);
          return callback();
        }
      },

      updateCachedSizes() {
        this.cachedContainerWidth = Math.ceil(this.elements.marqueeContainer.getBoundingClientRect().width);
        this.cachedTextWidth = Math.ceil(this.elements.marqueeDisplay.getBoundingClientRect().width);
      },

      setupPatterns() {
        this.vowelPattern = new RegExp(/[AEIOUYaeiouy\xc0\xc1\xc2\xc3\xc4\xc5\xc6\xc8\xc9\xca\xcb\xcc\xcd\xce\xcf\xd2\xd3\xd4\xd5\xd6\xd8\xd9\xda\xdb\xdc\xdd\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe8\xe9\xea\xeb\xec\xed\xee\xef\xf2\xf3\xf4\xf5\xf6\xf8\xf9\xfa\xfb\xfc\xfd\xff\u0100\u0101\u0102\u0103\u0104\u0105\u0112\u0113\u0114\u0115\u0116\u0117\u0118\u0119\u011a\u011b\u0128\u0129\u012a\u012b\u012c\u012d\u012e\u012f\u0130\u0131\u014c\u014d\u014e\u014f\u0150\u0151\u0152\u0153\u0168\u0169\u016a\u016b\u016c\u016d\u016e\u016f\u0170\u0171\u0172\u0173\u0176\u0177\u0178\u0186\u018f\u0190\u0196\u0197\u019c\u019f\u01a0\u01a1\u01af\u01b0\u01b1\u01b2\u01e2\u01e3\u01ea\u01eb\u0226\u0227\u022e\u022f\u0232\u0233\u0244\u0245\u0250\u0251\u0252\u0254\u0258\u0259\u025b\u025c\u025d\u025e\u0268\u0269\u026a\u026f\u0275\u0276\u0277\u0289\u028a\u028b\u028c\u028e\u029a\u0391\u0395\u0399\u039f\u03a9\u03b1\u03b5\u03b9\u03bf\u03c9\u0401\u0410\u0415\u0418\u041e\u0423\u042b\u042d\u042e\u042f\u0430\u0435\u0438\u043e\u0443\u044b\u044d\u044e\u044f\u0451\u04d8\u04d9\u0510\u0511\u0591\u0592\u0593\u0594\u0595\u0596\u0597\u0598\u0599\u059a\u059b\u059c\u059d\u059e\u059f\u05a0\u05a1\u05a2\u05a3\u05a4\u05a5\u05a6\u05a7\u05a8\u05a9\u05aa\u05ab\u05ac\u05ad\u05ae\u05af\u05b0\u05b1\u05b2\u05b3\u05b4\u05b5\u05b6\u05b7\u05b8\u05b9\u05ba\u05bb\u05bc\u05bd\u05bf\u05c0\u05c1\u05c2\u05c4\u05c5\u05c6\u05c7\u1d6b\u1e8e\u1e8f\u1ea0\u1ea1\u1eb8\u1eb9\u1eca\u1ecb\u1ecc\u1ecd\u1ee4\u1ee5\u1ef4\u1ef5\u2c6d\u2c6f\u2c70\ua7ab\ua7ae]/, 'u');
        this.letterPattern = new RegExp(/\p{L}/, 'u');
        this.wordPattern = new RegExp(/\p{L}+/, 'u');
        this.notLetterPattern = new RegExp(/[^\p{L}\p{M}\p{Pc}\p{Pd}\p{Sk}\u0027\u055a\u05f3\u2018\u2019\u201b\u2032\u2033\u2034\u2035\u2057\u25cc\uff07]/, 'u');
        this.notWordPattern = new RegExp(/[^\p{L}\p{M}\p{Pc}\p{Pd}\p{Sk}\u0027\u055a\u05f3\u2018\u2019\u201b\u2032\u2033\u2034\u2035\u2057\u25cc\uff07]+/, 'u');
        this.upperCaseWordStartPattern = new RegExp(/^[^\p{L}]*?[\p{Lu}\p{Lt}]/, 'u');
        this.spacePattern = new RegExp(/\p{Z}/, 'u');
        this.vowelPatternG = new RegExp(this.vowelPattern, 'ug');
        this.letterPatternG = new RegExp(this.letterPattern, 'ug');
        this.wordPatternG = new RegExp(this.wordPattern, 'ug');
      },

      bindEvents() {
        const currentReader = this;
        this.elements.playPauseButton.addEventListener('click', () => this.togglePlayback());
        this.elements.stopButton.addEventListener('click', () => this.stopPlayback());
        this.elements.themeToggle.addEventListener('click', () => this.switchTheme());
        this.elements.fullSizeToggle.addEventListener('click', () => this.toggleFullSize());
        this.elements.deleteAllSettingsProfiles.addEventListener('click', () => this.deleteAllSettingsProfiles());
        this.elements.deleteAllTexts.addEventListener('click', () => this.deleteAllTexts());
        this.elements.deleteAllData.addEventListener('click', () => this.deleteAllData());
        this.elements.deleteHistory.addEventListener('click', () => this.deleteHistory());
        this.elements.clearTextButton.addEventListener('click', () => {
          if (!confirm('Are you sure you want to clear the current text?')) {
            return;
          }
          currentReader.clearInput();
        });
        this.elements.loadSentenceWordsmythBeginner.addEventListener('click', () => this.fetchSentenceWordsmythBeginner());
        this.elements.loadSentenceWordsmythIntermediate.addEventListener('click', () => this.fetchSentenceWordsmythIntermediate());
        this.elements.loadSentenceWordsmythAdvanced.addEventListener('click', () => this.fetchSentenceWordsmythAdvanced());
        this.elements.loadSentenceMerriamWebster.addEventListener('click', () => this.fetchSentenceMerriamWebster());
        this.elements.loadWikiButton.addEventListener('click', () => this.fetchWikipedia());
        this.elements.loadUnderthekey.addEventListener('click', () => this.fetchUnderthekey());
        this.elements.loadMetaphorpsum.addEventListener('click', () => this.fetchMetaphorpsum());
        this.elements.loadFile.addEventListener('click', () => this.loadFromFile());
        this.elements.shuffleParagraphs.addEventListener('click', () => {
          if (!confirm('Are you sure you want to shuffle the paragraphs?')) {
            return;
          }
          this.shuffleParagraphsInText();
        });
        this.elements.shuffleSentences.addEventListener('click', () => {
          if (!confirm('Are you sure you want to shuffle the sentences in the paragraphs?')) {
            return;
          }
          this.shuffleSentencesInText();
        });
        this.elements.splitIntoParagraphs.addEventListener('click', () => {
          if (!confirm('Are you sure you want to split the text into paragraphs?')) {
            return;
          }
          this.splitIntoParagraphsInText();
        });
        this.elements.colorEncoderToggle.addEventListener('click', () => this.toggleColorEncoder(false));
        this.elements.dumpColors.addEventListener('click', () => this.dumpColorMap());
        this.elements.showColorInfoToggle.addEventListener('click', () => this.toggleColorDetails());
        this.elements.appendTextToggle.addEventListener('click', () => this.toggleAppendText());
        this.elements.refreshSentences.addEventListener('click', () => {
          if (!confirm('Are you sure you want to refresh the word order?')) {
            return;
          }
          currentReader.refreshMarqueeSentences();
        });
        this.elements.refreshWords.addEventListener('click', () => this.refreshMarqueeWords());
        this.elements.refreshView.addEventListener('click', () => this.refreshMarqueeView());
        this.elements.refreshColors.addEventListener('click', () => {
          if (currentReader.elements.textBackgroundColoringToggle.checked && !confirm('Are you sure you want to refresh the colors?')) {
            return;
          }
          currentReader.refreshMarqueeColors();
        });
        this.elements.copyMarqueeText.addEventListener('click', () => this.copyMarqueeText());
        this.elements.copyCurrentText.addEventListener('click', () => this.copyCurrentText());
        this.elements.loopToggle.addEventListener('click', () => this.toggleLoop());
        this.elements.rewindButton.addEventListener('click', () => this.rewind());
        this.elements.fastForwardButton.addEventListener('click', () => this.fastForward());
        this.elements.fontSizeSlider.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeSlider.value));
        this.elements.fontSizeNumber.addEventListener('input', () => this.adjustFontSize(this.elements.fontSizeNumber.value));
        this.elements.rsvpPunctuationDelaySlider.addEventListener('input', () => this.adjustRsvpPunctuationDelay(this.elements.rsvpPunctuationDelaySlider.value));
        this.elements.rsvpPunctuationDelayNumber.addEventListener('input', () => this.adjustRsvpPunctuationDelay(this.elements.rsvpPunctuationDelayNumber.value));
        this.elements.speedSlider.addEventListener('input', () => this.adjustSpeed(this.elements.speedSlider.value));
        this.elements.speedNumber.addEventListener('input', () => this.adjustSpeed(this.elements.speedNumber.value));
        this.elements.tabButtons.forEach(button => button.addEventListener('click', () => this.switchTab(button)));
        this.elements.progressBarContainer.addEventListener('click', (e) => this.handleProgressBarClick(e));
        this.elements.textSelect.addEventListener('input', () => this.switchText());
        this.elements.newTextButton.addEventListener('click', () => this.createNewText());
        this.elements.duplicateTextButton.addEventListener('click', () => this.duplicateText());
        this.elements.deleteTextButton.addEventListener('click', () => this.deleteCurrentText());
        this.elements.saveTextButton.addEventListener('click', () => this.saveCurrentText());
        this.elements.settingsProfileSelect.addEventListener('input', () => this.switchSettingsProfile());
        this.elements.newSettingsProfileButton.addEventListener('click', () => this.createNewSettingsProfile());
        this.elements.duplicateSettingsProfileButton.addEventListener('click', () => this.duplicateSettingsProfile());
        this.elements.deleteSettingsProfileButton.addEventListener('click', () => this.deleteCurrentSettingsProfile());
        this.elements.saveSettingsProfileButton.addEventListener('click', () => this.saveCurrentSettingsProfile());
        this.elements.resetSettingsProfileButton.addEventListener('click', () => {
          if (!confirm('Are you sure you want to reset the current settings profile?')) {
            return;
          }
          currentReader.resetCurrentSettingsProfile();
        });
        this.elements.showSpeakButtonToggle.addEventListener('click', () => this.toggleSpeechButton());
        this.elements.showBookmarksButtonToggle.addEventListener('click', () => this.toggleBookmarksButton());
        this.elements.showTextViewButtonToggle.addEventListener('click', () => this.toggleTextViewButton());
        this.elements.historyEnableToggle.addEventListener('click', () => this.toggleHistoryEnable());
        this.elements.showSearchButtonToggle.addEventListener('click', () => this.toggleSearchButton());
        this.elements.speakButton.addEventListener('click', () => this.toggleSpeech());
        this.elements.voiceSelect.addEventListener('input', () => this.updateVoice());
        this.elements.speechRateSlider.addEventListener('input', () => this.adjustSpeechRate(this.elements.speechRateSlider.value));
        this.elements.speechRateNumber.addEventListener('input', () => this.adjustSpeechRate(this.elements.speechRateNumber.value));
        this.elements.speechPitchSlider.addEventListener('input', () => this.adjustSpeechPitch(this.elements.speechPitchSlider.value));
        this.elements.speechPitchNumber.addEventListener('input', () => this.adjustSpeechPitch(this.elements.speechPitchNumber.value));
        this.elements.speechVolumeSlider.addEventListener('input', () => this.adjustSpeechVolume(this.elements.speechVolumeSlider.value));
        this.elements.speechVolumeNumber.addEventListener('input', () => this.adjustSpeechVolume(this.elements.speechVolumeNumber.value));
        this.elements.importAllSettingsProfiles.addEventListener('click', () => this.importAllSettingsProfiles());
        this.elements.importAllTexts.addEventListener('click', () => this.importAllTexts());
        this.elements.importHistory.addEventListener('click', () => this.importHistory());
        this.elements.importAllSettingsProfilesAndTexts.addEventListener('click', () => this.importAllSettingsProfilesAndTexts());
        this.elements.importAll.addEventListener('click', () => this.importAll());
        this.elements.exportAllSettingsProfiles.addEventListener('click', () => this.exportAllSettingsProfiles());
        this.elements.exportAllTexts.addEventListener('click', () => this.exportAllTexts());
        this.elements.exportAllSettingsProfilesAndTexts.addEventListener('click', () => this.exportAllSettingsProfilesAndTexts());
        this.elements.exportAll.addEventListener('click', () => this.exportAll());
        this.elements.searchButton.addEventListener('click', () => this.toggleSearch());
        this.elements.searchInput.addEventListener('input', (e) => this.handleSearchInput(e.target.value));
        this.elements.searchNextButton.addEventListener('click', () => this.goToNextMatch());
        this.elements.searchPrevButton.addEventListener('click', () => this.goToPreviousMatch());
        this.elements.bookmarksButton.addEventListener("click", () => this.toggleBookmarks());
        this.elements.addBookmarkButton.addEventListener("click", () => this.addBookmark());
        this.elements.saveBookmarksButton.addEventListener("click", () => this.saveBookmarksToDB());
        this.elements.cancelBookmarksButton.addEventListener("click", () => {
          if (JSON.stringify(currentReader.currentTextBookmarks) !== JSON.stringify(currentReader.tmpBookmarks) &&
              !confirm('Are you sure you want to close the bookmarks block without saving changes?')) {
            return;
          }
          currentReader.toggleBookmarks();
        });
        this.elements.importDataReplacement.forEach((elem) => elem.addEventListener('click', () => this.toggleImportReplacement()));
        this.elements.sentenceCountInput.addEventListener('input', () => this.saveSentenceCountToGenerate());
        this.elements.loadWikiLanguageSelect.addEventListener('input', () => this.saveWikiLang());
        this.elements.fasterTransitionsToggle.addEventListener('click', () => this.toggleFasterTransitions());
        this.elements.speakWordByWordToggle.addEventListener('click', () => this.toggleSpeakWordByWord());
        this.elements.speakSentenceBySentenceToggle.addEventListener('click', () => this.toggleSpeakSentenceBySentence());
        this.elements.exportAllTextsWithBookmarksToggle.addEventListener('click', () => this.toggleExportTextsWithBookmarks());
        this.elements.exportHistoryToggle.addEventListener('click', () => this.toggleExportHistory());
        this.elements.exportHistory.addEventListener('click', () => this.exportHistory());
        this.elements.rotNToggle.addEventListener('click', () => this.toggleRotN());
        this.elements.rotNLanguageSelect.addEventListener('input', () => this.toggleRotNLanguageInfo());
        this.elements.rotNGenerateButton.addEventListener('click', () => this.toggleRotNGenerate());
        this.elements.rotNNumberMin.addEventListener('input', () => {
          if (this.elements.rotNNumberMax.value && this.elements.rotNNumberMin.value) {
            this.elements.rotNNumberMax.value = Math.max(this.elements.rotNNumberMax.value, this.elements.rotNNumberMin.value);
          }
          this.toggleRotNLanguageInfo();
        });
        this.elements.rotNNumberMax.addEventListener('input', () => {
          if (this.elements.rotNNumberMax.value && this.elements.rotNNumberMin.value) {
            this.elements.rotNNumberMin.value = Math.min(this.elements.rotNNumberMax.value, this.elements.rotNNumberMin.value);
          }
          this.toggleRotNLanguageInfo();
        });
        this.elements.rotNComplexity.addEventListener('input', () => this.toggleRotNLanguageInfo());
        this.elements.skewingToggle.addEventListener('click', () => this.toggleSkewing());
        this.elements.randomParagraphsCaption.addEventListener('click', () => this.showHiddenContent1());
        this.elements.marqueeThemeSelect.addEventListener('input', () => this.toggleMarqueeTheme());
        this.elements.textViewButton.addEventListener('click', () => this.toggleTextView());
        this.elements.attemptMinTimeInput.addEventListener('input', () => this.toggleAttemptMinTime());
        this.elements.prevHistoryItemButton.addEventListener('click', () => this.prevHistoryItem());
        this.elements.nextHistoryItemButton.addEventListener('click', () => this.nextHistoryItem());
        this.elements.historyIndex.addEventListener('input', () => this.renderHistory(true));
        this.elements.generateChartButton.addEventListener('click', () => this.generateChart());
        this.elements.showHideTextToggle.addEventListener('click', () => this.toggleShowHideText());
        this.elements.textDirectionSelect.addEventListener('input', () => this.toggleTextDirection());
        this.elements.removeMarksToggle.addEventListener('input', () => this.toggleRemoveMarks());
        this.elements.geminiKeyInput.addEventListener('input', () => this.toggleGeminiKey());
        this.elements.geminiModelSelect.addEventListener('input', () => this.toggleGeminiModel());
        this.elements.geminiQueryInput.addEventListener('input', () => this.toggleGeminiQuery());
        this.elements.loadGemini.addEventListener('click', () => this.loadGemini());
        this.elements.fontFamilyInput.addEventListener('click', () => this.fontInputChanged());
        this.elements.fontListSelect.addEventListener('input', () => this.fontListOptionSelected());

        this.controlBeforeUnload();

        const textModified = () => {
          currentReader.textIsModified = true;
        };
        this.elements.textInput.addEventListener('input', textModified);

        const settingsProfileModified = function () {
          currentReader.settingsProfileIsModified = true;
        };
        this.elements.colorEncoderToggle.addEventListener('click', settingsProfileModified);
        this.elements.colorInput.addEventListener('input', settingsProfileModified);
        this.elements.colorLetterCount.addEventListener('input', settingsProfileModified);
        this.elements.dumpColors.addEventListener('click', settingsProfileModified);
        this.elements.fontSizeNumber.addEventListener('input', settingsProfileModified);
        this.elements.fontSizeSlider.addEventListener('input', settingsProfileModified);
        this.elements.letterEliminationSelect.addEventListener('input', settingsProfileModified);
        this.elements.letterFalseSelect.addEventListener('input', settingsProfileModified);
        this.elements.letterReverseSelect.addEventListener('input', settingsProfileModified);
        this.elements.letterShuffleSelect.addEventListener('input', settingsProfileModified);
        this.elements.letterSkipSelect.addEventListener('input', settingsProfileModified);
        this.elements.marqueeThemeSelect.addEventListener('input', settingsProfileModified);
        this.elements.mirroringLettersSelect.addEventListener('input', settingsProfileModified);
        this.elements.mirroringWordsSelect.addEventListener('input', settingsProfileModified);
        this.elements.rotatingLettersSelect.addEventListener('input', settingsProfileModified);
        this.elements.rotatingWordsSelect.addEventListener('input', settingsProfileModified);
        this.elements.rotNComplexity.addEventListener('input', settingsProfileModified);
        this.elements.rotNEachMapping.addEventListener('click', settingsProfileModified);
        this.elements.rotNExcludeZero.addEventListener('click', settingsProfileModified);
        this.elements.rotNLanguageSelect.addEventListener('input', settingsProfileModified);
        this.elements.rotNNumberMax.addEventListener('input', settingsProfileModified);
        this.elements.rotNNumberMin.addEventListener('input', settingsProfileModified);
        this.elements.rotNToggle.addEventListener('click', settingsProfileModified);
        this.elements.rotNUpperCaseLowerCase.addEventListener('click', settingsProfileModified);
        this.elements.rsvpToggle.addEventListener('click', settingsProfileModified);
        this.elements.sentenceShuffleSelect.addEventListener('input', settingsProfileModified);
        this.elements.skewingNumberMax.addEventListener('input', settingsProfileModified);
        this.elements.skewingNumberMin.addEventListener('input', settingsProfileModified);
        this.elements.skewingSelect.addEventListener('input', settingsProfileModified);
        this.elements.skewingToggle.addEventListener('click', settingsProfileModified);
        this.elements.speedNumber.addEventListener('input', settingsProfileModified);
        this.elements.speedSlider.addEventListener('input', settingsProfileModified);
        this.elements.speedSmoothToggle.addEventListener('click', settingsProfileModified);
        this.elements.textBackgroundColoringToggle.addEventListener('click', settingsProfileModified);
        this.elements.wordConcatSelect.addEventListener('input', settingsProfileModified);
        this.elements.wordFalseSelect.addEventListener('input', settingsProfileModified);
        this.elements.wordShuffleSelect.addEventListener('input', settingsProfileModified);
        this.elements.wordSkipSelect.addEventListener('input', settingsProfileModified);
        this.elements.textDirectionSelect.addEventListener('click', settingsProfileModified);
        this.elements.fontFamilyInput.addEventListener('click', settingsProfileModified);
        this.elements.fontListSelect.addEventListener('input', settingsProfileModified);
        this.elements.fontStyleSelect.addEventListener('input', settingsProfileModified);
        this.elements.rsvpPunctuationDelaySlider.addEventListener('input', settingsProfileModified);
        this.elements.rsvpPunctuationDelayNumber.addEventListener('input', settingsProfileModified);

        document.addEventListener('keydown', e => this.handleKeyPress(e));
        window.addEventListener('resize', () => {
          if (currentReader.currentPosition !== null) {
            currentReader.updateCachedSizes();
            currentReader.updateProgressBar();
          }
        });
        currentReader.restoreActiveTab();

        /* sentences generators */
        currentReader.sentenceWordsmyth1Generator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesWordsmyth1();
          } catch (e) {
            alert('[wordsmyth1.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();

        currentReader.sentenceWordsmyth2Generator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesWordsmyth2();
          } catch (e) {
            alert('[wordsmyth2.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();

        currentReader.sentenceWordsmyth3Generator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesWordsmyth3();
          } catch (e) {
            alert('[wordsmyth3.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();

        currentReader.sentenceMerriamWebsterGenerator = function* () {
          let sentences = [];
          try {
            sentences = getSentencesMerriamWebster();
          } catch (e) {
            alert('[merriam_webster.js] Sentences not found');
            return;
          }
          while (true) {
            currentReader.shuffleArray(sentences);
            for (const sentence of sentences) {
              yield sentence;
            }
          }
        }();

        try {
          this.alphabets = getAlphabets();
          this.elements.rotNLanguageSelect.innerHTML = this.alphabets.map(x => `<option value="${x[0]}">${x[0]} / ${x[1]}</option>`).join('');
          if (this.alphabets['English']) this.elements.rotNLanguageSelect.value = "English";
        }
        catch (err) {
          alert('[alphabets.js] Alphabets not found');
          this.elements.rotNLanguageSelect.innerHTML = '';
          this.elements.rotNDiv.style.display = 'none';
        }
      },

      loadPreferences() {
        this.elements.rewindButton.disabled = true;
        this.elements.fastForwardButton.disabled = true;
        this.elements.refreshSentences.disabled = true;
        this.elements.refreshWords.disabled = true;
        this.elements.refreshView.disabled = true;
        this.elements.refreshColors.disabled = true;
        this.elements.copyMarqueeText.disabled = true;
        this.elements.appendTextToggle.checked = localStorage.getItem(this.settingsNames.appendTextToggle) !== 'false';
        this.toggleAppendText();
        this.elements.showColorInfoToggle.checked = localStorage.getItem(this.settingsNames.showColorInfoToggle) !== 'false';
        this.isLoopEnabled = localStorage.getItem(this.settingsNames.loop) === 'true';
        if (this.isLoopEnabled) this.elements.loopToggle.classList.add('active');
        this.elements.mainContainer.classList.add(localStorage.getItem(this.settingsNames.appSizeToggle) || 'normal-size');
        this.elements.attemptMinTimeInput.value = localStorage.getItem(this.settingsNames.attemptMinTime) || '10';
        this.toggleAttemptMinTime();
        this.elements.showSpeakButtonToggle.checked = localStorage.getItem(this.settingsNames.voiceButton) === 'true';
        this.toggleSpeechButton();
        this.elements.showBookmarksButtonToggle.checked = localStorage.getItem(this.settingsNames.bookmarksButton) === 'true';
        this.toggleBookmarksButton();
        this.elements.showTextViewButtonToggle.checked = localStorage.getItem(this.settingsNames.textViewButton) === 'true';
        this.toggleTextViewButton();
        this.elements.historyEnableToggle.checked = localStorage.getItem(this.settingsNames.historyStatus) !== 'false';
        this.toggleHistoryEnable();
        this.elements.showSearchButtonToggle.checked = localStorage.getItem(this.settingsNames.searchButton) === 'true';
        this.toggleSearchButton();
        this.elements.showHideTextToggle.checked = localStorage.getItem(this.settingsNames.showHideTextToggle) !== 'false';
        this.toggleShowHideText();
        this.elements.geminiKeyInput.value = localStorage.getItem(this.settingsNames.geminiKey) || '';
        this.elements.geminiQueryInput.value = localStorage.getItem(this.settingsNames.geminiQuery) || '';
        this.elements.geminiModelSelect.value = localStorage.getItem(this.settingsNames.geminiModel) || 'gemini-2.0-flash';
        const importDataReplacementValue = localStorage.getItem(this.settingsNames.importDataReplacement) || this.importDataReplacementVariants.replaceIfProvided;
        this.elements.importDataReplacement.forEach((elem) => {
          if (elem.value === importDataReplacementValue) {
            elem.checked = true;
          }
        })
        this.toggleImportReplacement();
        this.elements.sentenceCountInput.value = localStorage.getItem(this.settingsNames.sentenceCountToGenerate) || '1';
        this.saveSentenceCountToGenerate();
        this.elements.loadWikiLanguageSelect.value = localStorage.getItem(this.settingsNames.wikiLang) || 'simple';
        this.saveWikiLang();
        this.elements.fasterTransitionsToggle.checked = localStorage.getItem(this.settingsNames.fasterTransitionsToggle) === 'true';
        this.toggleFasterTransitions();
        this.elements.speakWordByWordToggle.checked = localStorage.getItem(this.settingsNames.speakWordByWordToggle) === 'true';
        this.toggleSpeakWordByWord();
        this.elements.speakSentenceBySentenceToggle.checked = localStorage.getItem(this.settingsNames.speakSentenceBySentenceToggle) === 'true';
        this.toggleSpeakSentenceBySentence();
        this.elements.exportAllTextsWithBookmarksToggle.checked = localStorage.getItem(this.settingsNames.exportTextsWithBookmarksToggle) !== 'false';
        this.toggleExportTextsWithBookmarks();
        this.elements.exportHistoryToggle.checked = localStorage.getItem(this.settingsNames.exportHistoryToggle) !== 'false';
        this.toggleExportHistory();
        this.elements.removeMarksToggle.checked = localStorage.getItem(this.settingsNames.removeMarksToggle) !== 'false';
        this.toggleRemoveMarks();

        const voiceIndex = localStorage.getItem(this.settingsNames.voice) || null;
        if (voiceIndex != null) {
          this.elements.voiceSelect.value = voiceIndex;
        }
        const voiceSpeechRate = localStorage.getItem(this.settingsNames.voiceSpeechRate) || null;
        if (voiceSpeechRate != null) {
          this.adjustSpeechRate(voiceSpeechRate);
        }
        const voiceSpeechPitch = localStorage.getItem(this.settingsNames.voiceSpeechPitch) || null;
        if (voiceSpeechPitch != null) {
          this.adjustSpeechPitch(voiceSpeechPitch);
        }

        this.textsLastPositions = JSON.parse(localStorage.getItem(this.settingsNames.textsLastPositions) || '{}');

        const currentTextName = localStorage.getItem(this.settingsNames.currentTextName) || this.defaultTextName;
        const texts = JSON.parse(localStorage.getItem(this.settingsNames.texts) || '[]');
        this.elements.textSelect.innerHTML = `<option value="${this.defaultTextName}">${this.defaultTextName}</option>` + texts.map(text => `<option value="${text}">${text}</option>`).join('');
        this.currentTextName = this.defaultTextName;
        if (texts.includes(currentTextName)) {
          this.currentTextName = currentTextName;
        }
        this.elements.textSelect.value = this.currentTextName;
        this.textIsModified = false;

        const currentSettingsProfileName = localStorage.getItem(this.settingsNames.currentSettingsProfile) || this.defaultSettingsProfileName;
        const settingsProfiles = JSON.parse(localStorage.getItem(this.settingsNames.settingsProfiles) || '[]');
        this.elements.settingsProfileSelect.innerHTML = `<option value="${this.defaultSettingsProfileName}">${this.defaultSettingsProfileName}</option>` + settingsProfiles.map(settingsProfile => `<option value="${settingsProfile}">${settingsProfile}</option>`).join('');
        this.currentSettingsProfileName = this.defaultSettingsProfileName;
        if (settingsProfiles.includes(currentSettingsProfileName)) {
          this.currentSettingsProfileName = currentSettingsProfileName;
        }
        this.elements.settingsProfileSelect.value = this.currentSettingsProfileName;
        this.settingsProfileIsModified = false;

        const currentReader = this;
        currentReader.switchSettingsProfile(function () {
          currentReader.switchText(function () {
            const lastPosition = localStorage.getItem(currentReader.settingsNames.lastPosition);
            if (lastPosition != null && currentReader.elements.textInput.value) {
              currentReader.currentPosition = parseInt(lastPosition || 0);
            }
            currentReader.constructed = true;
            currentReader.savePosition();
            currentReader.elements.fontLoadDiv.style.display = 'none';
            setTimeout(() => currentReader.updateAnimationInfoCycle(), currentReader.animationInfoUpdateDelay);
          });
        });
      },

      randomInt(minIncluded, maxIncluded) {
        if (minIncluded === minIncluded && maxIncluded === maxIncluded) {
          return Math.floor(Math.random() * (maxIncluded - minIncluded + 1)) + minIncluded;
        }
        else {
          return 0;
        }
      },

      randomBool() {
        return Math.random() < 0.5;
      },

      controlBeforeUnload() {
        try {
          const currentReader = this;
          if (currentReader.controllerForUnload) {
            return;
          }
          currentReader.controllerForUnload = (event) => {
            if (currentReader.settingsProfileIsModified ||
                currentReader.textIsModified ||
                currentReader.animationTimer != null ||
                currentReader.isSpeaking ||
                currentReader.isSearchActive ||
                currentReader.isBookmarksActive) {
              event.preventDefault();
              event.returnValue = `You have unsaved changes! Are you sure you want to reload this page?`;
            }
            currentReader.saveHistory();
          };
          window.addEventListener('beforeunload', currentReader.controllerForUnload);
        }
        catch (err) {
          console.error(err);
        }
      },

      togglePlayback() {
        this.animationTimer != null ? this.pauseAnimation() : this.startAnimation();
      },

      stopPlayback(fully = false) {
        if (this.animationTimer != null) {
          cancelAnimationFrame(this.animationTimer);
          this.animationTimer = null;
        }
        this.fromContinue = false;
        this.currentPosition = this.cachedContainerWidth;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.elements.speakButton.style.display = '';
        this.elements.textViewButton.style.display = '';
        this.elements.searchButton.style.display = '';
        this.elements.bookmarksButton.style.display = '';
        this.elements.controlsContainerFooter.style.display = '';
        this.elements.loopToggle.style.display = '';
        this.elements.progressDisplay.style.display = 'none';
        this.elements.tabNavigation.style.display = '';
        this.elements.tabContent.style.display = '';
        if (fully) {
          this.animationStartTime = null;
          this.currentPosition = null;
          this.realText = '';
          this.realText1List = [];
          this.realText1RefList = [];
          this.realText2List = [];
          this.wordCount = 0;
          this.elements.rewindButton.disabled = true;
          this.elements.fastForwardButton.disabled = true;
          this.elements.refreshSentences.disabled = true;
          this.elements.refreshWords.disabled = true;
          this.elements.refreshView.disabled = true;
          this.elements.refreshColors.disabled = true;
          this.elements.copyMarqueeText.disabled = true;
        }
        else {
          this.savePosition();
          if (this.wasStarted) {
            this.endProgress = this.getProgressByPosition();
            this.amendHistoryItem();
            this.wasStarted = false;
            this.loadHistory();
          }
          this.forceNewHistoryItem = true;
        }
      },

      startAnimation(resume = false, movement = true) {
        if (this.fromContinue) {
          movement = false;
          this.fromContinue = false;
        }
        this.elements.textHelper.innerHTML = this.elements.textInput.value.replace(/\s+/g, ' ').replace(/\p{C}+/ug, '').replace(/\p{Z}+/ug, ' ').trim();
        const cleanedText = this.elements.textHelper.textContent || "";
        this.elements.textHelper.innerHTML = '';

        if (!cleanedText) {
          alert(`The text "${this.currentTextName}" is empty`);
          return false;
        }

        let palleteChanged = false;
        const currentSettings = this.getCurrentSettingsProfile();
        const backgroundColoring = currentSettings[this.settingsNames.colorTaskBackgroundColoring];
        const previousRect = this.getScreenRectByWordIndex(this.targetWordIndex);

        let textChanged = false;
        let wordHint1Pre = false, wordHint2Pre = false;
        if (this.elements.rotNToggle.checked && (!this.elements.rotNLanguageInfo.innerHTML || !this.rotNLetterMap.size)) {
          this.toggleRotNGenerate();
          textChanged = true;
        }
        if (
          textChanged ||
          this.realText !== cleanedText ||
          JSON.stringify(this.previousSettings[this.settingsNames.shufflingSentences]) !== JSON.stringify(currentSettings[this.settingsNames.shufflingSentences]) ||
          JSON.stringify(this.previousSettings[this.settingsNames.shufflingWords]) !== JSON.stringify(currentSettings[this.settingsNames.shufflingWords]) ||
          JSON.stringify(this.previousSettings[this.settingsNames.concatWords]) !== JSON.stringify(currentSettings[this.settingsNames.concatWords])
        ) {
          textChanged = true;
          this.realText = cleanedText;
          this.realText1List = [];
          this.realText1RefList = [];
          this.realTextDiffBase = 0;
          this.realTextDiff = 0;
        }
        if (textChanged) {
          const sentencesNPattern = /(\d+)_sentences?/;
          const sentenceShuffleSelectValue = this.elements.sentenceShuffleSelect.value;
          const sentenceShuffleMatch = sentenceShuffleSelectValue !== 'no' ? (sentencesNPattern.exec(sentenceShuffleSelectValue) || sentenceShuffleSelectValue === 'all_sentences' && [null, -1]) : null;
          const sentenceShuffleNumber = sentenceShuffleMatch ? parseInt(sentenceShuffleMatch[1]) : 0;
          let realText1 = this.realText;
          let realText1Ref = this.realText;
          if (sentenceShuffleNumber !== 0) {
            [realText1, realText1Ref] = this.shuffleSentences(realText1, realText1Ref, sentenceShuffleNumber);
          }
          this.realText1List = realText1.split(/\s+/);
          this.realText1RefList = realText1Ref.split(/\s+/);
          const wordsPercentPattern = /(\d+)%_words?/;
          const wordConcatSelectValue = this.elements.wordConcatSelect.value;
          const wordConcatMatch = wordConcatSelectValue !== 'no' ? wordsPercentPattern.exec(wordConcatSelectValue) : null;
          const wordConcatPercent = wordConcatMatch ? parseInt(wordConcatMatch[1]) / 100 : 0;
          if (wordConcatMatch) {
            const originalSize = this.realText1List.length;
            [this.realText1List, this.realText1RefList] = this.concatWords(this.realText1List, this.realText1RefList, wordConcatPercent);
            this.realTextDiffBase += (originalSize - this.realText1List.length);
            wordHint2Pre = true;
          }
          const wordsNPattern = /(\-?\d+)_words?/;
          const wordShuffleSelectValue = this.elements.wordShuffleSelect.value;
          const wordShuffleMatch = wordShuffleSelectValue !== 'no' ? wordsNPattern.exec(wordShuffleSelectValue) : null;
          const wordShuffleNumber = wordShuffleMatch ? parseInt(wordShuffleMatch[1]) : 0;
          if (wordShuffleNumber !== 0) {
            const shuffledIndices = this.shuffleWordGroups(this.realText1List, wordShuffleNumber);
            const newWords = [], newRefWords = [];
            let kDiff = 0;
            for (let i = 0; i < shuffledIndices.length; ++i) {
              const nextWord = this.realText1List[shuffledIndices[i]];
              const nextRefWord = this.realText1RefList[shuffledIndices[i]];
              const origWord = this.realText1RefList[i];
              if (wordShuffleNumber >= -3) {
                newWords.push(i !== shuffledIndices[i] ? nextWord[0].toLowerCase().concat(nextWord.slice(1)) : nextWord);
                newRefWords.push(`${origWord} [${nextRefWord}]`);
                kDiff += Math.abs(i - shuffledIndices[i]);
                continue;
              }
              const prevWord = this.realText1List[i];
              const prevWordList = Array.from(prevWord);
              const prevWordLettersStart = prevWordList.findIndex(v => !this.notLetterPattern.test(v));
              const prevWordLettersEnd = prevWordList.findLastIndex(v => !this.notLetterPattern.test(v));
              const nextWordList = Array.from(nextWord);
              const nextWordLettersStart = nextWordList.findIndex(v => !this.notLetterPattern.test(v));
              const nextWordLettersEnd = nextWordList.findLastIndex(v => !this.notLetterPattern.test(v));
              const rNextWord = [
                prevWord.slice(0, prevWordLettersStart >= 0 ? prevWordLettersStart : 0),
                nextWord.slice(
                  nextWordLettersStart >= 0 ? nextWordLettersStart : 0,
                  nextWordLettersEnd >= 0 ? nextWordLettersEnd + 1 : nextWord.length),
                prevWord.slice(prevWordLettersEnd >= 0 ? prevWordLettersEnd + 1 : prevWord.length)
              ].join('');
              const rrNextWord = (rNextWord && i !== shuffledIndices[i] ? rNextWord[0].toLowerCase().concat(rNextWord.slice(1)) : rNextWord) || nextWord;
              if (!rrNextWord) {
                continue;
              }
              newWords.push(rrNextWord);
              newRefWords.push(`${origWord} [${nextRefWord}]`);
              kDiff += Math.abs(i - shuffledIndices[i]);
            }
            this.realText1List = newWords.length > 0 ? newWords : this.realText1List;
            this.realText1RefList = newRefWords.length > 0 ? newRefWords : this.realText1List;
            this.realTextDiffBase += kDiff;
            wordHint1Pre = true;
          }
        }

        if (!resume && this.elements.colorEncoderToggle.checked) {
          const prevColorList = JSON.stringify(this.colorMap.entries());
          const currentReader = this;
          const targetSize = parseInt(this.elements.colorLetterCount.value || 0);
          const preservedColors = new Map();
          const preservedLetters = [];
          this.elements.colorInput.value.split('\n').forEach(line => {
            const onlyOr = (line.match(/\"/g) || []).length % 2 === 1;
            const words = [], colorParts = [];
            let quote = false, leftPartIsDone = false, tmp = [];
            for (const x of line.trim()) {
              if (leftPartIsDone) {
                colorParts.push(x);
                continue;
              }
              if (onlyOr) {
                if (currentReader.spacePattern.test(x)) {
                  leftPartIsDone = true;
                }
                else {
                  words.push(x);
                }
                continue;
              }
              if (x === '"') {
                if (quote && tmp.length) {
                  words.push(tmp.join(''));
                  tmp = [];
                }
                quote = !quote;
                continue;
              }
              if (!quote && currentReader.spacePattern.test(x)) {
                leftPartIsDone = true;
                continue;
              }
              if (quote) {
                tmp.push(x);
                continue;
              }
              words.push(x);
            }
            if (words.length && colorParts.length) {
              const color = colorParts.join('');
              words.forEach(word => {
                if (word.length > 0) {
                  preservedLetters.push(word);
                  preservedColors.set(word, color);
                }
              });
            }
          });
          if (this.colorMap.size < targetSize || currentSettings[this.settingsNames.colorTaskColors] !== this.previousSettings[this.settingsNames.colorTaskColors]) {
            const newColors = this.generateColors(targetSize);
            const letters = Array.from(this.colorList);
            preservedLetters.forEach(char => {
              if (letters.length < targetSize && (this.realText.includes(char) || char === '***') && !letters.includes(char)) {
                letters.push(char);
              }
            });
            let index = 0;
            for (let i = 0; i < this.realText.length && letters.length < targetSize; i++) {
              const char = this.realText[i];
              if (this.isLetter(char) && !letters.includes(char.toLowerCase()) && !letters.includes(char.toUpperCase())) {
                letters.push(char);
                index++;
              }
            }
            letters.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
            index = 0;
            letters.forEach(char => {
              if (!this.colorMap.has(char)) {
                this.colorMap.set(char, preservedColors.get(char) || newColors[index++]);
                this.colorList.push(char);
              }
            });
          }
          this.colorList.reverse();
          for (const x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              if (preservedColors.get(x) == null) {
                this.colorMap.delete(x);
                this.colorList.splice(this.colorList.indexOf(x), 1);
              }
            }
            else {
              break;
            }
          }
          this.colorList.sort((a, b) => (preservedLetters.indexOf(a) - preservedLetters.indexOf(b)));
          this.colorList.reverse();
          for (const x of this.colorList.slice()) {
            if (this.colorMap.size > targetSize) {
              this.colorMap.delete(x);
              this.colorList.splice(this.colorList.indexOf(x), 1);
            }
            else {
              break;
            }
          }
          this.colorList.sort((a, b) => a.toLowerCase().localeCompare(b.toLowerCase()));
          const curColorList = JSON.stringify(this.colorMap.entries());
          if (prevColorList !== curColorList) {
            palleteChanged = true;
          }
        }

        if (!resume) {
          this.elements.colorDetails.innerHTML = this.colorList
            .map((char, index) => {
              const postElem = (index !== 0 && index % 5 === 0) ? '<br><br>' : '';
              const color = this.colorMap.get(char);
              if (char === '***' || color === 'default' || color === 'transparent' || color.startsWith('font ') || color.startsWith('bg ') || color.startsWith('font-bg ')) {
                return;
              }
              const charV = ((!this.colorMap.get(char.toLowerCase())) ^ (!this.colorMap.get(char.toUpperCase()))) ? char.toUpperCase().concat(char.toLowerCase()) : char;
              return `${postElem}${charV}<span style="background-color:${color};color:${color};" class="marquee-letter-span">${charV[0]}</span>`;
            })
            .join('  ');
        }

        const textNeedsUpdate = [
          this.textNeedsUpdate === true,
          this.currentPosition == null,
          textChanged === true,
          ...[
          this.settingsNames.skippingLetters,
          this.settingsNames.reversingLetters,
          this.settingsNames.shufflingLetters,
          this.settingsNames.falseLetters,
          this.settingsNames.eliminatingLetters,
          this.settingsNames.skippingWords,
          this.settingsNames.falseWords,
          this.settingsNames.rotNToggle,
          this.settingsNames.rotNMap,
          this.settingsNames.concatWords,
          this.settingsNames.shufflingWords,
          this.settingsNames.shufflingSentences,
          ].map(x => JSON.stringify(this.previousSettings[x]) !== JSON.stringify(currentSettings[x]))
        ].some(b => b);

        const colorsNeedsUpdate = !this.wasColorTaskChecked || palleteChanged ||
          this.wasColorTaskEnabled !== this.elements.colorEncoderToggle.checked ||
          (this.elements.colorEncoderToggle.checked && this.previousColorInput !== this.elements.colorInput.value);

        const viewNeedsUpdate = [
          ...[
          this.settingsNames.rotatingWords,
          this.settingsNames.rotatingLetters,
          this.settingsNames.mirroringWords,
          this.settingsNames.mirroringLetters,
          this.settingsNames.skewingToggle,
          this.settingsNames.skewingType,
          this.settingsNames.skewingNumberMin,
          this.settingsNames.skewingNumberMax,
          this.settingsNames.textDirection,
          this.settingsNames.colorMap,
          this.settingsNames.colorTaskToggle,
          this.settingsNames.colorTaskLetters,
          this.settingsNames.colorTaskColors,
          this.settingsNames.colorTaskBackgroundColoring,
          ].map(x => JSON.stringify(this.previousSettings[x]) !== JSON.stringify(currentSettings[x]))
        ].some(b => b);

        if (textNeedsUpdate || colorsNeedsUpdate || viewNeedsUpdate) {
          const currentReader = this;
          const splitByBrackets = (data) => {
            const result = [];
            let tmpList = [], bracket = 0;
            for (const x of data) {
              tmpList.push(x);
              if (x === '(') {
                bracket += 1;
                continue;
              }
              else if (x === ')') {
                bracket = Math.max(0, bracket - 1);
                continue;
              }
              if (bracket === 0 && currentReader.spacePattern.test(x)) {
                result.push(tmpList.join(''));
                tmpList = [];
              }
            }
            if (tmpList.length) {
              result.push(tmpList.join(''));
            }
            return result;
          };
          const colorize = (char, formatted, word) => {
            if (currentReader.elements.colorEncoderToggle.checked) {
              const color = currentReader.colorMap.get(word)
                || currentReader.colorMap.get(word.toLowerCase())
                || currentReader.colorMap.get(word.toUpperCase())
                || currentReader.colorMap.get(char)
                || currentReader.colorMap.get(char.toLowerCase())
                || currentReader.colorMap.get(char.toUpperCase())
                || currentReader.colorMap.get('***');
              if (color) {
                const bgColorStyle = color.startsWith('font-bg ') ? `background-color:${splitByBrackets(color)[2]};` : (color.startsWith('bg ') ? `background-color:${color.slice(2)};` : (!backgroundColoring || color === 'default' || color.startsWith('font ') ? '' : `background-color:${color};`));
                const fgColorStyle = color.startsWith('font-bg ') ? `color:${splitByBrackets(color)[1]};` : (color === 'default' ? '' : (color.startsWith('font ') ? `color:${color.slice(4)};` : (color.startsWith('bg ') ? `color:${color.slice(2)};` : `color:${color};`)));
                return {'style': `${bgColorStyle}${fgColorStyle}`};
              }
            }
            return {};
          };
          this.toggleFontFamily();
          this.elements.marqueeDisplay.innerHTML = this.processText(
            textNeedsUpdate ? this.realText1List : this.realText2List,
            this.realText1RefList,
            Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')),
            textNeedsUpdate,
            colorize,
            wordHint1Pre,
            wordHint2Pre
          );
          this.realText2List = this.elements.marqueeDisplay.textContent.split(/\s+/);
          this.wordCount = this.realText2List.length;
          if (textNeedsUpdate) {
            this.updateTextStats();
          }
          if (colorsNeedsUpdate || viewNeedsUpdate) {
            this.updateTextViewStats();
          }
        }

        if (!resume) {
          this.updateCachedSizes();
        }

        const currentRect = this.getScreenRectByWordIndex(this.targetWordIndex);
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = containerWidth;
        const endPos = -textWidth;
        const speedSmooth = this.elements.speedSmoothToggle.checked;

        this.adjustSpeed(null);

        if (this.targetWordIndex != null && JSON.stringify(previousRect) !== JSON.stringify(currentRect)) {
          this.currentPosition = this.getPositionByWordIndex(this.targetWordIndex);
        }
        if (this.currentPosition == null || this.currentPosition <= endPos) this.currentPosition = startPos;
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;

        this.textNeedsUpdate = false;
        this.previousSettings = currentSettings;
        this.previousPosition = this.currentPosition;
        this.previousColorInput = this.elements.colorInput.value;
        this.wasColorTaskEnabled = this.elements.colorEncoderToggle.checked;
        this.wasColorTaskChecked = true;

        const animate = () => {
          const newLastUpdateTime = Date.now();
          const step = speedSmooth ? this.stepSize : Math.max(this.stepSize, (newLastUpdateTime - this.lastUpdateTime) / (this.stepDelay / this.stepSize));
          const newPosition = this.currentPosition - step;
          const actualPixelDelay = Math.floor((this.lastUpdateTime - this.animationStartTime) / Math.max(1e-9, this.previousPosition - newPosition) * 10) / 10;
          const totalSeconds = actualPixelDelay * textWidth / 1000;
          this.infoSecondsRemaining = Math.floor(actualPixelDelay * (newPosition - endPos) / 1000);
          this.infoWPM = totalSeconds > 0 ? Math.max(1, Math.floor(this.wordCount / (totalSeconds / 60))) : this.wordCount;
          this.infoProgress = this.getProgressByPosition();
          this.lastUpdateTime = newLastUpdateTime;

          if (this.newStepSize != null) {
            this.stepSize = this.newStepSize;
            this.newStepSize = null;
          }
          if (this.newStepDelay != null) {
            this.stepDelay = this.newStepDelay;
            this.newStepDelay = null;
          }

          if (newPosition <= endPos) {
            if (this.isLoopEnabled) {
              this.savePosition();
              this.endProgress = this.getProgressByPosition();
              this.amendHistoryItem();
              this.currentPosition = startPos;
              this.previousPosition = this.currentPosition;
              this.elements.marqueeDisplay.style.left = `${startPos}px`;
              this.startProgress = this.getProgressByPosition();
              this.endProgress = this.startProgress;
              this.forceNewHistoryItem = true;
              this.animationStartTime = Date.now();
              this.amendHistoryItem();
              if (this.animationTimer != null) this.animationTimer = requestAnimationFrame(animate);
            } else {
              this.currentPosition = endPos;
              this.savePosition();
              this.endProgress = this.getProgressByPosition();
              this.amendHistoryItem();
              this.previousPosition = this.currentPosition;
              this.elements.marqueeDisplay.style.left = `${endPos}px`;
              cancelAnimationFrame(this.animationTimer);
              this.animationTimer = null;
              this.forceNewHistoryItem = true;
              this.animationStartTime = Date.now();
              this.amendHistoryItem();
              this.elements.speakButton.style.display = '';
              this.elements.textViewButton.style.display = '';
              this.elements.searchButton.style.display = '';
              this.elements.bookmarksButton.style.display = '';
              this.elements.controlsContainerFooter.style.display = '';
              this.elements.loopToggle.style.display = '';
              this.elements.progressDisplay.style.display = '';
              this.elements.tabNavigation.style.display = '';
              this.elements.tabContent.style.display = '';
            }
          } else {
            this.currentPosition = newPosition;
            this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
            if (this.animationTimer != null) this.animationTimer = requestAnimationFrame(animate);
          }
        };

        const animateRsvp = () => {
          const containerRect = this.elements.marqueeContainer.getBoundingClientRect();
          const words = this.realText2List;
          const spans = Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span'));

          let startSpanIndex = 0;
          const shift = containerWidth * 0.5;
          if (this.currentPosition !== null) {
            for (let i = 0; i < spans.length; i++) {
              const currentSpanRect = spans[i].getBoundingClientRect();
              if (shift <= currentSpanRect.x + currentSpanRect.width - containerRect.x) {
                startSpanIndex = i;
                break;
              }
            }
          }

          if (startSpanIndex >= spans.length || spans.length !== words.length) {
            cancelAnimationFrame(this.animationTimer);
            this.animationTimer = null;
            return;
          }

          const wordCount = words.length;
          const totalWordLength = words.reduce((sum, w) => sum + w.length, 0);
          const avgWordLength = Math.max(1, wordCount ? (totalWordLength / wordCount) : 0);
          const punctuationDelay = parseFloat(this.elements.rsvpPunctuationDelayNumber.value || 0);

          let currentWordIndex = startSpanIndex;
          let wpm = this.speed;
          let baseWordDelay = (60 / wpm) * 1000;
          let curWordLength = 0;
          let wordDelay = 0;

          let wordStartTime = Date.now();
          let isWordDisplayed = false;

          const getCostForWord = (currentWord, avgWordLength) => {
            const currentWordLengthM = Math.ceil(Math.max(avgWordLength, currentWord.length));
            const exceptLetters = currentWord.replaceAll(this.letterPatternG, '');
            const addCost1 = ['.', '!', '?', ';'].some((v) => currentWord.includes(v)) ? 2.0 : 0;
            const addCost2 = [',', ':', '/', '\\'].some((v) => currentWord.includes(v)) ? 1.0 : 0;
            const cost = currentWordLengthM / avgWordLength + Math.ceil((exceptLetters.length + addCost1 + addCost2) * punctuationDelay / 100);
            return cost;
          };

          const updateWordUI = (wordIndex) => {
            if (wordIndex >= wordCount) {
              completeAnimation();
              return;
            }

            const spanRect = spans[wordIndex].getBoundingClientRect();
            const marqueeRect = this.elements.marqueeDisplay.getBoundingClientRect();
            const spanPos = -(spanRect.left - marqueeRect.left) + Math.max(0, shift - spanRect.width / 2);
            this.currentPosition = Math.max(endPos, Math.min(startPos, spanPos));
            this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;

            const relWordN = wordIndex - startSpanIndex + 1;
            const newLastUpdateTime = Date.now();
            const elapsedTime = (newLastUpdateTime - this.animationStartTime) / 1000;
            const wordsPerSecond = elapsedTime > 1 ? relWordN / elapsedTime : relWordN / 60;
            const remainingWords = wordCount - wordIndex - 1;
            const secondsRemaining = wordsPerSecond > 0 ? (remainingWords / wordsPerSecond) : 0;

            this.infoSecondsRemaining = Math.floor(secondsRemaining);
            this.infoWPM = Math.min(Math.floor(wordsPerSecond * 60), wpm);
            this.infoProgress = this.getProgressByPosition();
            this.lastUpdateTime = newLastUpdateTime;
          };

          const completeAnimation = () => {
            this.currentPosition = endPos;
            this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
            this.infoSecondsRemaining = 0;
            this.infoWPM = Math.floor((wordCount - startSpanIndex) / ((Date.now() - this.animationStartTime) / 1000) * 60);
            this.infoProgress = this.getProgressByPosition();
            this.lastUpdateTime = this.animationStartTime;

            if (this.isLoopEnabled) {
              this.savePosition();
              this.endProgress = this.getProgressByPosition();
              this.amendHistoryItem();
              this.currentPosition = startPos;
              this.previousPosition = this.currentPosition;
              this.elements.marqueeDisplay.style.left = `${startPos}px`;
              this.startProgress = this.getProgressByPosition();
              this.endProgress = this.startProgress;
              this.forceNewHistoryItem = true;
              this.animationStartTime = Date.now();
              this.amendHistoryItem();
              if (this.animationTimer != null) this.animationTimer = requestAnimationFrame(animateRsvp);
            } else {
              this.currentPosition = endPos;
              this.savePosition();
              this.endProgress = this.getProgressByPosition();
              this.amendHistoryItem();
              this.previousPosition = this.currentPosition;
              this.elements.marqueeDisplay.style.left = `${endPos}px`;
              cancelAnimationFrame(this.animationTimer);
              this.animationTimer = null;
              this.forceNewHistoryItem = true;
              this.animationStartTime = Date.now();
              this.amendHistoryItem();
              this.elements.speakButton.style.display = '';
              this.elements.textViewButton.style.display = '';
              this.elements.searchButton.style.display = '';
              this.elements.bookmarksButton.style.display = '';
              this.elements.controlsContainerFooter.style.display = '';
              this.elements.loopToggle.style.display = '';
              this.elements.progressDisplay.style.display = '';
              this.elements.tabNavigation.style.display = '';
              this.elements.tabContent.style.display = '';
            }
          };

          const animateFrame = () => {
            if (currentWordIndex >= wordCount) {
              completeAnimation();
              return;
            }

            const currentTime = Date.now();
            const currentWord = words[currentWordIndex];
            if (this.newSpeed != null) {
              this.speed = this.newSpeed;
              this.newSpeed = null;
              wpm = this.speed;
              baseWordDelay = (60 / wpm) * 1000;
              wordDelay = baseWordDelay * getCostForWord(currentWord, avgWordLength);
            }

            if (!isWordDisplayed) {
              updateWordUI(currentWordIndex);
              isWordDisplayed = true;
              curWordLength = currentWord.length;
              wordDelay = baseWordDelay * getCostForWord(currentWord, avgWordLength);
            }

            if (currentTime - wordStartTime >= wordDelay) {
              currentWordIndex++;
              isWordDisplayed = false;
              wordStartTime = currentTime;
            }

            this.animationTimer = requestAnimationFrame(animateFrame);
          };

          this.animationStartTime = Date.now();
          this.lastUpdateTime = this.animationStartTime;
          this.animationTimer = requestAnimationFrame(animateFrame);
        };

        this.elements.rewindButton.disabled = false;
        this.elements.fastForwardButton.disabled = false;
        this.elements.refreshSentences.disabled = false;
        this.elements.refreshWords.disabled = false;
        this.elements.refreshView.disabled = false;
        this.elements.refreshColors.disabled = false;
        this.elements.copyMarqueeText.disabled = false;
        this.animationStartTime = Date.now(); /* for history */
        this.lastUpdateTime = this.animationStartTime;
        this.startProgress = this.getProgressByPosition();
        this.endProgress = this.startProgress;
        if (movement) {
          this.elements.speakButton.style.display = 'none';
          this.elements.textViewButton.style.display = 'none';
          this.elements.searchButton.style.display = 'none';
          this.elements.bookmarksButton.style.display = 'none';
          this.elements.controlsContainerFooter.style.display = '';
          this.elements.loopToggle.style.display = 'none';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = 'none';
          this.elements.tabContent.style.display = 'none';
          this.amendHistoryItem();
        }
        this.animationStartTime = Date.now(); /* for animation */
        this.lastUpdateTime = this.animationStartTime;
        if (movement) {
          this.wasStarted = true;
          this.animationTimer = requestAnimationFrame(this.elements.rsvpToggle.checked ? animateRsvp : animate);
        }
        this.savePosition();
        return true;
      },

      pauseAnimation() {
        if (this.animationTimer != null) {
          cancelAnimationFrame(this.animationTimer);
          this.animationTimer = null;
          this.elements.speakButton.style.display = '';
          this.elements.textViewButton.style.display = '';
          this.elements.searchButton.style.display = '';
          this.elements.bookmarksButton.style.display = '';
          this.elements.controlsContainerFooter.style.display = '';
          this.elements.loopToggle.style.display = '';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = '';
          this.elements.tabContent.style.display = '';
          this.savePosition();
          this.endProgress = this.getProgressByPosition();
          this.amendHistoryItem();
        }
      },

      processText(textList, referenceWordList, wordsSpans, shouldModify, colorize, wordHint1Pre = false, wordHint2Pre = false) {
        const currentReader = this;
        const vowelsPercentPattern = /(\d+)%_vowels/;
        const randomPercentPattern = /(\d+)%_random/;
        const lettersPercentPattern = /(\d+)%_letters?/;
        const wordsPercentPattern = /(\d+)%_words?/;

        const letterEliminationSelectValue = this.elements.letterEliminationSelect.value;
        const letterEliminationVowelMatch = shouldModify && letterEliminationSelectValue !== 'no' ? vowelsPercentPattern.exec(letterEliminationSelectValue) : null;
        const letterEliminationVowelPercent = letterEliminationVowelMatch ? parseInt(letterEliminationVowelMatch[1]) / 100 : 0;
        const letterEliminationRandomMatch = shouldModify && letterEliminationSelectValue !== 'no' ? randomPercentPattern.exec(letterEliminationSelectValue) : null;
        const letterEliminationRandomPercent = letterEliminationRandomMatch ? parseInt(letterEliminationRandomMatch[1]) / 100 : 0;

        const letterSkipSelectValue = this.elements.letterSkipSelect.value;
        const letterSkipMatch = shouldModify && letterSkipSelectValue !== 'no' ? lettersPercentPattern.exec(letterSkipSelectValue) : null;
        const letterSkipPercent = letterSkipMatch ? parseInt(letterSkipMatch[1]) / 100 : 0;

        const letterFalseSelectValue = this.elements.letterFalseSelect.value;
        const textChars = [];
        if (shouldModify && letterFalseSelectValue !== 'no') {
          textChars.push(...(new Set(Array.from(this.realText).filter(w => this.letterPattern.test(w)))));
        }
        const letterFalseMatch = textChars.length ? lettersPercentPattern.exec(letterFalseSelectValue) : null;
        const letterFalsePercent = letterFalseMatch ? parseInt(letterFalseMatch[1]) / 100 : 0;

        const wordFalseSelectValue = this.elements.wordFalseSelect.value;
        const textWords = [];
        if (shouldModify && wordFalseSelectValue !== 'no') {
          textWords.push(...(new Set(this.realText.split(this.notWordPattern).filter(w => w).slice(0, 1000))));
        }
        const wordFalseMatch = textWords.length ? wordsPercentPattern.exec(wordFalseSelectValue) : null;
        const wordFalsePercent = wordFalseMatch ? parseInt(wordFalseMatch[1]) / 100 : 0;

        const wordSkipSelectValue = this.elements.wordSkipSelect.value;
        const wordSkipMatch = shouldModify && wordSkipSelectValue !== 'no' ? wordsPercentPattern.exec(wordSkipSelectValue) : null;
        const wordSkipMatchPercent = wordSkipMatch ? parseInt(wordSkipMatch[1]) / 100 : 0;

        const letterReverseSelectValue = this.elements.letterReverseSelect.value;
        const letterReverseCheck = shouldModify && letterReverseSelectValue !== 'no';

        const letterShuffleSelectValue = this.elements.letterShuffleSelect.value;
        const letterShuffleCheck = shouldModify && letterShuffleSelectValue !== 'no';

        const skipShuffleReverseRegex = this.upperCaseWordStartPattern;

        const rotNToggleValue = this.elements.rotNToggle.checked;

        const colorEncoderToggleChecked = this.elements.colorEncoderToggle.checked;

        const rotatingWordsSelectValue = this.elements.rotatingWordsSelect.value;
        const settingRotate1 = rotatingWordsSelectValue === 'words_180';
        const settingRotate2 = rotatingWordsSelectValue === 'words_1_-1';
        const settingRotate3 = rotatingWordsSelectValue === 'words_181_-181';
        const settingRotate4 = rotatingWordsSelectValue === 'words_2_-2';
        const settingRotate5 = rotatingWordsSelectValue === 'words_182_-182';
        const settingRotate6 = rotatingWordsSelectValue === 'words_1_-1_181_-181';
        const settingRotate7 = rotatingWordsSelectValue === 'random_words_180';
        const settingRotate8 = rotatingWordsSelectValue === 'random_words_1_-1';
        const settingRotate9 = rotatingWordsSelectValue === 'random_words_181_-181';
        const settingRotate10 = rotatingWordsSelectValue === 'random_words_2_-2';
        const settingRotate11 = rotatingWordsSelectValue === 'random_words_182_-182';
        const settingRotate12 = rotatingWordsSelectValue === 'random_words_1_-1_181_-181';

        const rotatingLettersSelectValue = this.elements.rotatingLettersSelect.value;
        const settingRotate13 = rotatingLettersSelectValue === 'letters_180';
        const settingRotate14 = rotatingLettersSelectValue === 'letters_90';
        const settingRotate15 = rotatingLettersSelectValue === 'letters_270';
        const settingRotate16 = rotatingLettersSelectValue === 'letters_90_270';
        const settingRotate17 = rotatingLettersSelectValue === 'letters_180_90_270';
        const settingRotate18 = rotatingLettersSelectValue === 'letters_random';
        const settingRotate19 = rotatingLettersSelectValue === 'random_letters_180';
        const settingRotate20 = rotatingLettersSelectValue === 'random_letters_90';
        const settingRotate21 = rotatingLettersSelectValue === 'random_letters_270';
        const settingRotate22 = rotatingLettersSelectValue === 'random_letters_90_270';
        const settingRotate23 = rotatingLettersSelectValue === 'random_letters_180_90_270';
        const settingRotate24 = rotatingLettersSelectValue === 'random_letters_random';

        const settingRotate = (
          settingRotate1 ||
          settingRotate2 ||
          settingRotate3 ||
          settingRotate4 ||
          settingRotate5 ||
          settingRotate6 ||
          settingRotate7 ||
          settingRotate8 ||
          settingRotate9 ||
          settingRotate10 ||
          settingRotate11 ||
          settingRotate12 ||
          settingRotate13 ||
          settingRotate14 ||
          settingRotate15 ||
          settingRotate16 ||
          settingRotate17 ||
          settingRotate18 ||
          settingRotate19 ||
          settingRotate20 ||
          settingRotate21 ||
          settingRotate22 ||
          settingRotate23 ||
          settingRotate24
        );
        const isRotateClass = (x) => x.startsWith('rotate-');
        const rotate1Class = 'rotate-1';
        const rotate2Class = 'rotate-2';
        const rotate181Class = 'rotate-181';
        const rotate182Class = 'rotate-182';
        const rotateN1Class = 'rotate--1';
        const rotateN2Class = 'rotate--2';
        const rotateN181Class = 'rotate--181';
        const rotateN182Class = 'rotate--182';
        const rotate180Class = 'rotate-180';
        const rotate90Class = 'rotate-90';
        const rotate270Class = 'rotate-270';
        const rotateRandom = () => {
          return `rotate(${this.randomInt(0, 360)}deg)`;
        };
        const textWordsRotateSetting = settingRotate1
          ? rotate180Class
          : '';
        const textLettersRotateSetting = settingRotate13
          ? rotate180Class
          : (settingRotate14
              ? rotate90Class
              : (settingRotate15
                  ? rotate270Class
                  : ''));

        const mirroringWordsSelectValue = this.elements.mirroringWordsSelect.value;
        const settingMirror1 = mirroringWordsSelectValue === 'words_x';
        const settingMirror2 = mirroringWordsSelectValue === 'words_y';
        const settingMirror3 = mirroringWordsSelectValue === 'words_xy';
        const settingMirror4 = mirroringWordsSelectValue === 'words_x_xor_y';
        const settingMirror5 = mirroringWordsSelectValue === 'words_x_or_y_or_xy';
        const settingMirror6 = mirroringWordsSelectValue === 'random_words_x';
        const settingMirror7 = mirroringWordsSelectValue === 'random_words_y';
        const settingMirror8 = mirroringWordsSelectValue === 'random_words_xy';
        const settingMirror9 = mirroringWordsSelectValue === 'random_words_x_xor_y';
        const settingMirror10 = mirroringWordsSelectValue === 'random_words_x_or_y_or_xy';

        const mirroringLettersSelectValue = this.elements.mirroringLettersSelect.value;
        const settingMirror11 = mirroringLettersSelectValue === 'letters_x';
        const settingMirror12 = mirroringLettersSelectValue === 'letters_y';
        const settingMirror13 = mirroringLettersSelectValue === 'letters_xy';
        const settingMirror14 = mirroringLettersSelectValue === 'letters_x_xor_y';
        const settingMirror15 = mirroringLettersSelectValue === 'letters_x_or_y_or_xy';
        const settingMirror16 = mirroringLettersSelectValue === 'random_letters_x';
        const settingMirror17 = mirroringLettersSelectValue === 'random_letters_y';
        const settingMirror18 = mirroringLettersSelectValue === 'random_letters_xy';
        const settingMirror19 = mirroringLettersSelectValue === 'random_letters_x_xor_y';
        const settingMirror20 = mirroringLettersSelectValue === 'random_letters_x_or_y_or_xy';

        const settingMirror = (
          settingMirror1 ||
          settingMirror2 ||
          settingMirror3 ||
          settingMirror4 ||
          settingMirror5 ||
          settingMirror6 ||
          settingMirror7 ||
          settingMirror8 ||
          settingMirror9 ||
          settingMirror10 ||
          settingMirror11 ||
          settingMirror12 ||
          settingMirror13 ||
          settingMirror14 ||
          settingMirror15 ||
          settingMirror16 ||
          settingMirror17 ||
          settingMirror18 ||
          settingMirror19 ||
          settingMirror20
        );
        const mirrorXClass = 'mirror-x';
        const mirrorYClass = 'mirror-y';
        const mirrorXYClass = 'mirror-xy';
        const textMirrorSetting = settingMirror1
          ? mirrorXClass
          : (settingMirror2
              ? mirrorYClass
              : (settingMirror3
                  ? mirrorXYClass
                  : ''));

        const skewingToggleChecked = this.elements.skewingToggle.checked;
        const skewingTypeValue = this.elements.skewingSelect.value;
        const skewingNumberMinValue = parseInt(this.elements.skewingNumberMin.value || 0);
        const skewingNumberMaxValue = parseInt(this.elements.skewingNumberMax.value || 0);
        const settingSkew1 = skewingToggleChecked && skewingTypeValue == 'text';
        const settingSkew2 = skewingToggleChecked && skewingTypeValue == 'word';
        const settingSkew3 = skewingToggleChecked && skewingTypeValue == 'letter';
        const settingSkew = skewingToggleChecked && (
          settingSkew1 ||
          settingSkew2 ||
          settingSkew3
        );
        const getRandomSkewStyle = () => {
          return `skewX(${currentReader.randomInt(skewingNumberMinValue, skewingNumberMaxValue)}deg)`;
        };
        const textSkewSetting = settingSkew1 ? getRandomSkewStyle() : '';

        const wordHint1 = wordSkipMatch != null ||
                          wordHint1Pre;
        const wordHint2 = letterSkipMatch != null ||
                          letterReverseCheck ||
                          letterShuffleCheck ||
                          letterFalseMatch != null ||
                          letterEliminationVowelMatch != null ||
                          letterEliminationRandomMatch != null ||
                          rotNToggleValue && this.letterMapItemMaxLength > 0 ||
                          wordFalseMatch != null ||
                          wordHint2Pre;

        /* Algorithm */
        const escapeString = str => str.replace(/[\\"]/g, '').replaceAll('\'', '\\\'');
        let textLines = [textList];
        let refLines = [referenceWordList];
        const startDiffValue = 1000 / textList.length;
        this.realTextDiff = startDiffValue * this.realTextDiffBase;
        return textLines.map((lineList, lineIndex) => {
          const words = lineList;
          const refWords = refLines[lineIndex] ? refLines[lineIndex] : words.slice();
          let processedWords = words;
          let processedRefWords = refWords;

          if (wordFalseMatch) {
            const originalSize = processedWords.length;
            [processedWords, processedRefWords] = this.falseWords(textWords, processedWords, processedRefWords, wordFalsePercent);
            this.realTextDiff += startDiffValue * 3.0 * (processedWords.length - originalSize);
          }

          if (wordSkipMatch) {
            processedWords = this.skipWords(processedWords, wordSkipMatchPercent);
            this.realTextDiff += startDiffValue * Math.pow(Math.max(1, processedWords.length * wordSkipMatchPercent), 1.6);
          }

          const processedWordsLength = processedWords.length;
          let realTextDiffW = 0;

          return processedWords.map((word, processedWordIndex) => {
            let realTextDiffLEliminate = 1, realTextDiffLSkip = 1, realTextDiffLRot = 1, realTextDiffLFalse = 1, realTextDiffLReverse = 1, realTextDiffLShuffle = 1;
            let realTextDiffRotate = 0, realTextDiffMirror = 0, realTextDiffSkew = 0;
            let modifiedWord = word;

            if (word.length > 1) {
              const originalSize = modifiedWord.length;
              if (letterEliminationVowelMatch) {
                modifiedWord = this.eliminateLetters(this.vowelPatternG, modifiedWord, letterEliminationVowelPercent);
                realTextDiffLEliminate *= Math.pow(Math.max(1, 8 * (originalSize - modifiedWord.length)), 1.6);
              }
              else if (letterEliminationRandomMatch) {
                modifiedWord = this.eliminateLetters(this.letterPatternG, modifiedWord, letterEliminationRandomPercent);
                realTextDiffLEliminate *= Math.pow(Math.max(1, 8 * (originalSize - modifiedWord.length)), 1.6);
              }
              if (letterSkipMatch) {
                const originalWord = modifiedWord;
                modifiedWord = this.skipLetters(modifiedWord, letterSkipPercent);
                const diff = Array.from(originalWord).reduce((pv, v, idx) => pv + (modifiedWord[idx] !== v), 0);
                realTextDiffLSkip *= Math.pow(Math.max(1, 8 * diff), 1.6);
              }
            }

            if (letterReverseCheck && (!skipShuffleReverseRegex.test(word) || letterReverseSelectValue === 'all_letters')) {
              const parts = modifiedWord.split('-');
              modifiedWord = parts.map(part => {
                const threshold = letterReverseSelectValue === 'except_capitalized' || letterReverseSelectValue === 'all_letters'
                  ? 0
                  : letterReverseSelectValue === 'except_first' || letterReverseSelectValue === 'except_first_last'
                    ? 1
                    : 1;
                const suffixLength = letterReverseSelectValue === 'except_first_last' ? threshold : 0;
                const letters = [];
                for (const x of part) {
                  if (this.isLetter(x)) {
                    letters.push(x);
                  }
                }
                const firstLetters = letters.slice(0, threshold);
                const midLetters = letters.slice(threshold, letters.length - suffixLength);
                const lastLetters = letters.slice(letters.length - suffixLength);
                const originalMiddle = Array.from(midLetters);
                const originalMiddleSize = new Set(originalMiddle).size;
                midLetters.reverse();
                const k = (firstLetters.length ? 1.5 : 1) * (midLetters.length ? 1.5 : 1) * (lastLetters.length ? 1.5 : 1);
                realTextDiffLReverse *= Math.max(1, k * midLetters.length / parts.length);
                const reordered = [...firstLetters, ...midLetters, ...lastLetters];
                const result = [];
                let j = 0;
                for (const char of part) {
                  result.push(this.isLetter(char) ? reordered[j++] : char);
                }
                return result.join('');
              }).join('-');
            }

            if (letterShuffleCheck && (!skipShuffleReverseRegex.test(word) || letterShuffleSelectValue === 'all_letters')) {
              const parts = modifiedWord.split('-');
              modifiedWord = parts.map(part => {
                const threshold = letterShuffleSelectValue === 'except_capitalized' || letterShuffleSelectValue === 'all_letters'
                  ? 0
                  : letterShuffleSelectValue === 'except_first_last' || letterShuffleSelectValue === 'except_first'
                    ? 1
                    : Math.max(1, Math.floor(part.length / 3)); /* middle */
                const suffixLength = letterShuffleSelectValue === 'except_first' ? 0 : threshold;
                const letters = [];
                for (const x of part) {
                  if (this.isLetter(x)) {
                    letters.push(x);
                  }
                }
                const firstLetters = letters.slice(0, threshold);
                const midLetters = letters.slice(threshold, letters.length - suffixLength);
                const lastLetters = letters.slice(letters.length - suffixLength);
                const originalMiddle = Array.from(midLetters);
                const originalMiddleSize = new Set(originalMiddle).size;
                if (originalMiddleSize > 1) {
                  while (midLetters.join('') === originalMiddle.join('')) {
                    this.shuffleArray(midLetters);
                  }
                }
                let k = 1;
                if (letterShuffleSelectValue === 'all_letters') {
                  k = 2.6;
                }
                else if (letterShuffleSelectValue === 'except_capitalized') {
                  k = 2.5;
                }
                else if (letterShuffleSelectValue === 'except_first') {
                  k = 2.25;
                }
                else if (letterShuffleSelectValue === 'except_first_last') {
                  k = 2;
                }
                realTextDiffLShuffle *= Math.max(1, k * midLetters.length / parts.length);
                const reordered = [...firstLetters, ...midLetters, ...lastLetters];
                const result = [];
                let j = 0;
                for (const char of part) {
                  result.push(this.isLetter(char) ? reordered[j++] : char);
                }
                return result.join('');
              }).join('-');
            }

            if (shouldModify && rotNToggleValue && this.letterMapItemMaxLength > 0) {
              const charsList = [];
              for (let i = 0; i < modifiedWord.length;) {
                let currentLength = this.letterMapItemMaxLength;
                while (currentLength > 0) {
                  const part = modifiedWord.slice(i, i + currentLength);
                  if (this.rotNLetterMap.get(part)) {
                    break;
                  }
                  currentLength -= 1;
                }
                if (currentLength > 0) {
                  const variants = this.rotNLetterMap.get(modifiedWord.slice(i, i + currentLength));
                  const variantIndex = this.randomInt(0, Math.min(variants.length - 1, Math.floor((processedWordIndex + 1) / processedWordsLength * variants.length)));
                  charsList.push(variants[variantIndex]);
                  i += this.letterMapItemMaxLength;
                  realTextDiffLRot += variants.length * currentLength;
                }
                else {
                  charsList.push(modifiedWord[i]);
                  i += 1;
                }
              }
              if (realTextDiffLRot > 1) {
                realTextDiffLRot *= 9;
              }
              modifiedWord = charsList.join('');
            }

            const beforeFalseWordLength = modifiedWord.length;

            if (letterFalseMatch) {
              const newWordChars = Array.from(modifiedWord);
              const n = Math.floor(letterFalsePercent * modifiedWord.length);
              for (let i = 0; i < n; ++i) {
                const nextChar = textChars[this.randomInt(0, textChars.length - 1)];
                const randomPosition = this.randomInt(0, newWordChars.length);
                newWordChars.splice(randomPosition, 0, nextChar);
              }
              realTextDiffLFalse *= Math.max(1, 15.0 * n) * Math.max(1, realTextDiffLRot / 9);
              modifiedWord = newWordChars.join('');
            }

            const wordRotateSetting = textWordsRotateSetting
              ? textWordsRotateSetting
              : (settingRotate2
                  ? ([rotate1Class, rotateN1Class][this.randomInt(0, 1)])
                  : (settingRotate3
                      ? ([rotate181Class, rotateN181Class][this.randomInt(0, 1)])
                      : (settingRotate4
                          ? ([rotate2Class, rotateN2Class][this.randomInt(0, 1)])
                          : (settingRotate5
                              ? ([rotate182Class, rotateN182Class][this.randomInt(0, 1)])
                              : (settingRotate6
                                  ? ([rotate1Class, rotateN1Class, rotate181Class, rotateN181Class][this.randomInt(0, 3)])
                                  : (settingRotate7
                                      ? ([rotate180Class, ''][this.randomInt(0, 1)])
                                      : (settingRotate8
                                          ? ([([rotate1Class, rotateN1Class][this.randomInt(0, 1)]), ''][this.randomInt(0, 1)])
                                          : (settingRotate9
                                              ? ([([rotate181Class, rotateN181Class][this.randomInt(0, 1)]), ''][this.randomInt(0, 1)])
                                              : (settingRotate10
                                                  ? ([([rotate2Class, rotateN2Class][this.randomInt(0, 1)]), ''][this.randomInt(0, 1)])
                                                  : (settingRotate11
                                                      ? ([([rotate182Class, rotateN182Class][this.randomInt(0, 1)]), ''][this.randomInt(0, 1)])
                                                      : (settingRotate12
                                                          ? ([([rotate1Class, rotateN1Class, rotate181Class, rotateN181Class][this.randomInt(0, 3)]), ''][this.randomInt(0, 1)])
                                                          : '')))))))))))

            const wordMirrorSetting = textMirrorSetting
              ? textMirrorSetting
              : (settingMirror4
                  ? ([mirrorXClass, mirrorYClass][this.randomInt(0, 1)])
                  : (settingMirror5
                      ? ([mirrorXClass, mirrorYClass, mirrorXYClass][this.randomInt(0, 2)])
                      : (settingMirror6
                          ? ([mirrorXClass, ''][this.randomInt(0, 1)])
                          : (settingMirror7
                              ? ([mirrorYClass, ''][this.randomInt(0, 1)])
                              : (settingMirror8
                                  ? ([mirrorXYClass, ''][this.randomInt(0, 1)])
                                  : (settingMirror9
                                      ? ([([mirrorXClass, mirrorYClass][this.randomInt(0, 1)]), ''][this.randomInt(0, 1)])
                                      : (settingMirror10
                                          ? ([([mirrorXClass, mirrorYClass, mirrorXYClass][this.randomInt(0, 2)]), ''][this.randomInt(0, 1)])
                                          : '')))))));

            const wordSkewSetting = textSkewSetting
              ? textSkewSetting
              : (settingSkew2
                  ? getRandomSkewStyle()
                  : '');

            wordHint1Pre = false;
            wordHint2Pre = false;

            const finalWord = Array.from(modifiedWord).map((char) => {

              const letterRotateSetting = textLettersRotateSetting
              ? textLettersRotateSetting
              : (settingRotate16
                  ? ([rotate90Class, rotate270Class][this.randomInt(0, 1)])
                  : (settingRotate17
                      ? ([rotate180Class, rotate90Class, rotate270Class][this.randomInt(0, 2)])
                      : (settingRotate18
                          ? rotateRandom()
                          : (settingRotate19
                              ? ([rotate180Class, ''][this.randomInt(0, 1)])
                              : (settingRotate20
                                  ? ([rotate90Class, ''][this.randomInt(0, 1)])
                                  : (settingRotate21
                                      ? ([rotate270Class, ''][this.randomInt(0, 1)])
                                      : (settingRotate22
                                          ? ([([rotate90Class, rotate270Class][this.randomInt(0, 1)]), ''][this.randomInt(0, 1)])
                                          : (settingRotate23
                                              ? ([([rotate180Class, rotate90Class, rotate270Class][this.randomInt(0, 2)]), ''][this.randomInt(0, 1)])
                                              : (settingRotate24
                                                  ? ([rotateRandom(), ''][this.randomInt(0, 1)])
                                                  : '')))))))));

              const letterMirrorSetting = settingMirror11
                ? mirrorXClass
                : (settingMirror12
                    ? mirrorYClass
                    : (settingMirror13
                        ? mirrorXYClass
                        : (settingMirror14
                            ? ([mirrorXClass, mirrorYClass][this.randomInt(0, 1)])
                            : (settingMirror15
                                ? ([mirrorXClass, mirrorYClass, mirrorXYClass][this.randomInt(0, 2)])
                                : (settingMirror16
                                    ? ([mirrorXClass, ''][this.randomInt(0, 1)])
                                    : (settingMirror17
                                        ? ([mirrorYClass, ''][this.randomInt(0, 1)])
                                        : (settingMirror18
                                            ? ([mirrorXYClass, ''][this.randomInt(0, 1)])
                                            : (settingMirror19
                                                ? ([([mirrorXClass, mirrorYClass][this.randomInt(0, 1)]), ''][this.randomInt(0, 1)])
                                                : (settingMirror20
                                                    ? ([([mirrorXClass, mirrorYClass, mirrorXYClass][this.randomInt(0, 2)]), ''][this.randomInt(0, 1)])
                                                    : '')))))))));

              const letterSkewSetting = settingSkew3 ? getRandomSkewStyle() : '';

              let formatted = char;
              const newClasses = [''], newStyles = [], newTransforms = [];
              if (letterRotateSetting) {
                if (isRotateClass(letterRotateSetting)) {
                  newClasses.push(letterRotateSetting);
                }
                else {
                  newTransforms.push(letterRotateSetting);
                }
                realTextDiffRotate += 1;
              }
              if (letterMirrorSetting) {
                newClasses.push(letterMirrorSetting);
                realTextDiffMirror += 1;
              }
              if (letterSkewSetting) {
                newTransforms.push(letterSkewSetting);
                realTextDiffSkew += 1;
              }
              if (newTransforms.length) {
                newStyles.push('transform: ' + newTransforms.join(' '));
              }
              for (const [k, v] of Object.entries(colorize(char, formatted, modifiedWord))) {
                if (k === 'style') {
                  newStyles.push(v);
                }
                else if (k === 'class') {
                  newClasses.push(v);
                }
              }
              if (newClasses.length > 1 || newStyles.length > 0) {
                wordHint1Pre = true;
              }
              const newClassesString = newClasses.join(' ');
              const newStyleString = newStyles.length ? ` style="${newStyles.join(';')}"` : '';
              if (newClasses.length > 1 || newStyles.length > 0) {
                formatted = `<span class="marquee-letter-span${newClassesString}"${newStyleString}>${formatted}</span>`;
              }
              return formatted;
            }).join('');

            const newClasses = [''], newStyles = [], newTransforms = [];
            if (wordRotateSetting) {
              if (isRotateClass(wordRotateSetting)) {
                newClasses.push(wordRotateSetting);
              }
              else {
                newTransforms.push(wordRotateSetting);
              }
              realTextDiffRotate += modifiedWord.length;
            }
            if (wordMirrorSetting) {
              newClasses.push(wordMirrorSetting);
              realTextDiffMirror += modifiedWord.length;
            }
            if (wordSkewSetting) {
              newTransforms.push(wordSkewSetting);
              realTextDiffSkew += modifiedWord.length;
            }
            if (newTransforms.length) {
              newStyles.push('transform: ' + newTransforms.join(' '));
            }

            if (newClasses.length > 1 || newStyles.length > 0) {
              wordHint1Pre = true;
            }
            const currentRefWord = (processedRefWords[processedWordIndex] || word);
            const hasSpan = !shouldModify && processedWordIndex < wordsSpans.length;
            const hadNewWordMark = hasSpan && wordsSpans[processedWordIndex].classList.contains(this.newWordMark);
            const newWordMark = hadNewWordMark || currentRefWord.startsWith('- ') ? ` ${this.newWordMark}` : '';
            const newClassesString = newClasses.join(' ');
            const newStyleString = newStyles.length ? ` style="${newStyles.join(';')}"` : '';

            const onclickFromSpan = hasSpan ? (wordsSpans[processedWordIndex].getAttribute('onclick') || '') : '';
            let onclickParam = onclickFromSpan;
            if ((wordHint2 || wordHint2Pre) && modifiedWord !== currentRefWord) {
              if (finalWord !== modifiedWord) {
                onclickParam = ` onclick="MarqueeReader.showWordHint('${escapeString(modifiedWord)}', '${escapeString(currentRefWord)}')"`;
              }
              else {
                onclickParam = ` onclick="MarqueeReader.showWordHint(this, '${escapeString(currentRefWord)}')"`;
              }
            }
            else {
              if ((wordHint1 || wordHint1Pre) && finalWord !== currentRefWord) {
                onclickParam = ` onclick="MarqueeReader.showWordHint('${escapeString(currentRefWord)}')"`;
              }
              else {
                onclickParam = '';
              }
            }
            const realTextDiffL = (
              realTextDiffRotate + (realTextDiffRotate > 0) +
              realTextDiffMirror + (realTextDiffMirror > 0) +
              realTextDiffSkew + (realTextDiffSkew > 0) +
              Math.max(realTextDiffLEliminate - 1, realTextDiffLSkip - 1) +
              (realTextDiffLFalse - 1) +
              (realTextDiffLRot - 1) +
              Math.max(realTextDiffLReverse - 1, (realTextDiffLShuffle - 1) * 10)) / Math.max(1, beforeFalseWordLength);
            if (realTextDiffL > 1) {
              realTextDiffW += realTextDiffL;
            }
            if (processedWordIndex === processedWordsLength - 1 && realTextDiffW > 1) {
              this.realTextDiff += startDiffValue * realTextDiffW;
            }
            return `<span class="marquee-word-span${newWordMark}${newClassesString}"${newStyleString}${onclickParam}>${finalWord}</span>`;
          }).join(' ');
        })[0];
      },

      eliminateLetters(regex, word, percentOfLetters, onlyReturnIndices = false) {
        const lettersOnly = word.replace(/[^\p{L}]/ug, '');
        const matchIndices = [];
        let isFirstMatch = true;
        regex.lastIndex = 0;
        while (true) {
          const match = regex.exec(word);
          if (match === null) break;
          if (isFirstMatch) {
            isFirstMatch = false;
            if (lettersOnly[0] === word[match.index]) continue;
          }
          matchIndices.push(match.index);
        }
        regex.lastIndex = 0;
        if (matchIndices.length > 0 && word.length >= 2 && regex === this.letterPatternG) {
          const lastIndex = matchIndices[matchIndices.length - 1];
          if (!this.vowelPattern.test(word[lastIndex]) || (lastIndex > 0 && this.vowelPattern.test(word[lastIndex - 1]))) {
            matchIndices.pop();
          }
        }
        let effectiveLength = lettersOnly.length;
        if (regex === this.vowelPatternG) {
          let vowelCount = 0;
          for (const char of word) {
            this.vowelPattern.lastIndex = 0;
            if (this.vowelPattern.test(char)) {
              vowelCount++;
            }
          }
          effectiveLength = vowelCount;
        }
        const numToRemove = Math.min(Math.floor(effectiveLength * percentOfLetters), matchIndices.length);
        const shuffledIndices = Array.from(matchIndices);
        this.shuffleArray(shuffledIndices);
        const duplicateIndices = [];
        const vowelIndices = [];
        const otherIndices = [];
        for (const index of shuffledIndices) {
          if (index > 0 && word[index - 1] === word[index]) {
            duplicateIndices.push(index);
          } else if (this.vowelPattern.test(word[index])) {
            vowelIndices.push(index);
          } else {
            otherIndices.push(index);
          }
        }
        const cmp = (a, b) => b - a;
        otherIndices.sort(cmp);
        const indicesToRemove = [...duplicateIndices, ...vowelIndices, ...otherIndices].slice(0, numToRemove).sort((a, b) => a - b);
        if (onlyReturnIndices) {
          return indicesToRemove;
        }
        const wordParts = [];
        let start = 0;
        for (const removeIndex of indicesToRemove) {
          if (start < removeIndex) {
            wordParts.push(word.slice(start, removeIndex));
          }
          start = removeIndex + 1;
        }
        if (start < word.length) {
          wordParts.push(word.slice(start));
        }
        return wordParts.join('');
      },

      shuffleWordGroups(words, groupSize) {
        const shuffledIndices = [];
        for (let start = 0; start < words.length;) {
          let groupWords = [];
          if (groupSize < 0) {
            let end;
            for (end = start; end < words.length; ++end) {
              const word = words[end];
              if (word.indexOf('?') >= 0 || word.indexOf('!') >= 0 || word.indexOf('.') >= 0) {
                break;
              }
            }
            groupWords = words.slice(start, end + 1);
          }
          else {
            groupWords = words.slice(start, start + groupSize);
          }
          if (groupWords.length === 0) {
            break;
          }
          if (groupSize >= -1) {
            const subGroupWords = [groupWords[0]];
            const notLetter = this.notLetterPattern.test(groupWords[0]);
            for (let j = 1; j < groupWords.length; j++) {
              const word = groupWords[j];
              if (notLetter || this.notLetterPattern.test(word)) {
                break;
              }
              subGroupWords.push(word);
            }
            groupWords = subGroupWords;
          }
          const groupLength = groupWords.length;
          const shuffleableIndices = [];
          const fixedIndices = new Set();
          for (let j = 0; j < groupLength; j++) {
              const word = groupWords[j];
              if (!this.notLetterPattern.test(word) && this.wordPattern.test(word)
                || groupSize === -3 && !(word.indexOf('?') >= 0 || word.indexOf('!') >= 0 || word.indexOf('.') >= 0)
                || groupSize === -4) {
              shuffleableIndices.push(j);
            }
            else {
              fixedIndices.add(j);
            }
          }
          this.shuffleArray(shuffleableIndices);
          let shufflePosition = 0;
          for (let j = 0; j < groupLength; j++) {
            if (fixedIndices.has(j)) {
              shuffledIndices.push(start + j);
            } else {
              shuffledIndices.push(start + shuffleableIndices[shufflePosition]);
              shufflePosition++;
            }
          }
          start += groupLength;
        }
        return shuffledIndices;
      },

      maxDistanceIndexes(length) {
        if (length <= 0) return [];
        const result = [0];
        if (length === 1) return result;
        result.push(length - 1);
        const remaining = new Set();
        for (let i = 1; i < length - 1; i++) remaining.add(i);
        while (remaining.size > 0) {
          let maxMinDist = -1;
          let bestIdx = -1;
          const sortedResult = result.slice().sort((a, b) => a - b);
          for (const current of remaining) {
            let left = 0, right = sortedResult.length - 1;
            let minDist = Infinity;
            while (left <= right) {
              const mid = Math.floor((left + right) / 2);
              const dist = Math.abs(current - sortedResult[mid]);
              minDist = Math.min(minDist, dist);
              if (current < sortedResult[mid]) {
                right = mid - 1;
              } else {
                left = mid + 1;
              }
            }
            if (right >= 0) {
              minDist = Math.min(minDist, Math.abs(current - sortedResult[right]));
            }
            if (left < sortedResult.length) {
              minDist = Math.min(minDist, Math.abs(current - sortedResult[left]));
            }
            if (minDist > maxMinDist) {
              maxMinDist = minDist;
              bestIdx = current;
            }
          }
          result.push(bestIdx);
          remaining.delete(bestIdx);
        }
        return result;
      },

      makeDistantIndicesForWords(words) {
        let indices1 = [], indices2 = [];
        for (let i = 0; i < words.length; ++i) {
          (i % 2 ? indices2 : indices1).push(i)
        }
        const newIndices1 = this.maxDistanceIndexes(indices1.length);
        const newIndices2 = this.maxDistanceIndexes(indices2.length);
        return [[...newIndices1.map(i => indices1[i])], [...newIndices2.map(i => indices2[i])]];
      },

      skipWords(words, percent) {
        const wordsToSkip = Math.floor(words.filter((v, i) => this.wordPattern.test(v)).length * percent);
        const indicesN1N2 = this.makeDistantIndicesForWords(words);
        const indicesN1 = Math.random() < 0.5 ? indicesN1N2[0] : indicesN1N2[1];
        const indicesN2 = indicesN1 === indicesN1N2[0] ? indicesN1N2[1] : indicesN1N2[0];
        const indices = [...indicesN1, ...indicesN2].filter(value => this.wordPattern.test(words[value]));
        const newWords = words.slice();
        for (let i = 0, k = 0; i < indices.length && k < wordsToSkip; ++i) {
          const currentIndex = indices[i];
          const word = words[currentIndex];
          const newWord = word.replaceAll(this.wordPatternG, '_');
          if (word !== newWord) {
            newWords[currentIndex] = newWord;
            ++k;
          }
        }
        return newWords;
      },

      concatWords(words, refWords, percent) {
        const wordsToConcat = Math.floor(words.filter((v, i) => this.wordPattern.test(v)).length * percent);
        const indicesN1 = this.makeDistantIndicesForWords(words)[0];
        const newWordsIndexes = [];
        for (let i = 0, k = 0; i < indicesN1.length && k < wordsToConcat; ++i) {
          const currentIndex = indicesN1[i];
          const nextIndex = currentIndex + 1;
          if (nextIndex < words.length) {
            const word = words[currentIndex];
            const nextWord = words[nextIndex];
            const refWord = refWords[currentIndex];
            const refNextWord = refWords[nextIndex];
            if (this.wordPattern.test(word) && this.wordPattern.test(nextWord)) {
              newWordsIndexes.push([currentIndex, word.concat(nextWord), refWord.concat(' ').concat(refNextWord)]);
              ++k;
              ++k;
            }
          }
        }
        newWordsIndexes.sort((a, b) => b[0] - a[0]);
        const newWords = words.slice(), newRefWords = refWords.slice();
        for (const [newWordIndex, newWord2, newWord2Ref] of newWordsIndexes) {
          newWords.splice(newWordIndex, 2, newWord2);
          newRefWords.splice(newWordIndex, 2, newWord2Ref);
        }
        return [newWords, newRefWords];
      },

      falseWords(textWords, words, refWords, percent) {
        if (textWords.length <= 0) {
          return [words, refWords];
        }
        const wordsToFalse = Math.floor(words.filter((v, i) => this.wordPattern.test(v)).length * percent);
        const indicesN1N2 = this.makeDistantIndicesForWords(words);
        const indices = [...indicesN1N2[0], ...indicesN1N2[1]];
        const newWordsIndexes = [];
        for (let i = 0, k = 0; i < indices.length && k < wordsToFalse; ++i) {
          const currentIndex = indices[i];
          const textWord = textWords[this.randomInt(0, textWords.length - 1)];
          newWordsIndexes.push([currentIndex, textWord, `- [${textWord}]`]);
          ++k;
        }
        newWordsIndexes.sort((a, b) => b[0] - a[0]);
        const newWords = words.slice(), newRefWords = refWords.slice();
        for (const [newWordIndex, newWord, newWordRef] of newWordsIndexes) {
          newWords.splice(newWordIndex, 0, newWord);
          newRefWords.splice(newWordIndex, 0, newWordRef);
        }
        return [newWords, newRefWords];
      },

      skipLetters(word, percent) {
        const lettersIndices = this.eliminateLetters(this.letterPatternG, word, percent, true);
        return [...word].map((v, i) => lettersIndices.includes(i) ? '_' : v).join('');
      },

      isLetter(char) {
        return char.toLowerCase() !== char.toUpperCase() || (this.wordPattern && this.wordPattern.test(char));
      },

      shuffleArray(array, notOriginal = true) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + (1 - notOriginal)));
          [array[i], array[j]] = [array[j], array[i]];
        }
      },

      generateColors(count) {
        const colors = [];
        const isTooDarkOrLight = (r, g, b) => {
          const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
          return luminance < 0.2 || luminance > 0.8;
        };
        for (let i = 0; i < count; i++) {
          let r, g, b;
          do {
            r = Math.floor(Math.random() * 256);
            g = Math.floor(Math.random() * 256);
            b = Math.floor(Math.random() * 256);
          } while (isTooDarkOrLight(r, g, b));
          colors.push(`#${r.toString(16).padStart(2, '0')}${g.toString(16).padStart(2, '0')}${b.toString(16).padStart(2, '0')}`);
        }
        return colors;
      },

      formatTime(seconds) {
        if (seconds < 0) return '00:00:00';
        const hours = Math.floor(seconds / 3600);
        const minutes = Math.floor((seconds % 3600) / 60);
        const secs = Math.floor(seconds % 60);
        return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
      },

      switchTheme() {
        const current = this.themes.find(theme => this.elements.body.classList.contains(theme));
        const next = this.themes[(this.themes.indexOf(current) + 1) % this.themes.length] || this.themes[0];
        this.themes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(next);
        localStorage.setItem(this.settingsNames.theme, next);
      },

      toggleMarqueeTheme() {
        if (this.targetWordIndex == null) {
          this.targetWordIndex = this.getFirstVisibleWordIndex();
        }
        const newTheme = this.elements.marqueeThemeSelect.value;
        this.marqueeThemes.forEach(theme => this.elements.body.classList.remove(theme));
        this.elements.body.classList.add(newTheme);
        this.updateCachedSizes();
        if (this.targetWordIndex != null) {
          this.currentPosition = this.getPositionByWordIndex(this.targetWordIndex);
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        }
      },

      toggleFullSize() {
        const sizes = ['max-size', 'normal-size'];
        const container = this.elements.mainContainer;
        const current = sizes.find(size => container.classList.contains(size));
        const next = sizes[(sizes.indexOf(current) + 1) % sizes.length] || sizes[0];
        sizes.forEach(size => container.classList.remove(size));
        container.classList.add(next);
        localStorage.setItem(this.settingsNames.appSizeToggle, next);
        if (this.currentPosition !== null) {
          this.updateCachedSizes();
          this.savePosition();
        }
      },

      toggleTextView(savePosition = false) {
        if (!this.realText) {
          this.startAnimation(false, false);
        }
        if (!this.realText) {
          return;
        }
        if (this.isTextViewActive) {
          if (savePosition) {
            this.targetWordIndex = this.getFirstVerticalVisibleWordIndex() ?? this.targetWordIndex;
          }
          this.elements.marqueeContainer.style.overflow = '';
          this.elements.marqueeContainer.style.minHeight = '';
          this.elements.marqueeDisplay.style.whiteSpace = '';
          this.elements.marqueeDisplay.style.textAlign = '';
          this.elements.marqueeDisplay.style.left = '';
          this.elements.playPauseButton.style.display = '';
          this.elements.stopButton.style.display = '';
          this.elements.rewindButton.style.display = '';
          this.elements.fastForwardButton.style.display = '';
          this.elements.refreshSentences.style.display = '';
          this.elements.refreshWords.style.display = '';
          this.elements.refreshView.style.display = '';
          this.elements.refreshColors.style.display = '';
          this.elements.copyMarqueeText.style.display = '';
          this.elements.speakButton.style.display = '';
          this.elements.searchButton.style.display = '';
          this.elements.bookmarksButton.style.display = '';
          this.elements.controlsContainerFooter.style.display = '';
          this.elements.loopToggle.style.display = '';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = '';
          this.elements.tabContent.style.display = '';
          this.elements.progressBarContainer.style.display = '';
          this.elements.textViewContainer.removeChild(this.elements.textViewContainer.children[1]);
          this.elements.textViewButton.innerHTML = 'Text view';
          this.elements.marqueeDisplay.style.height = '';
          if (this.targetWordIndex != null) {
            this.currentPosition = this.getPositionByWordIndex(this.targetWordIndex);
            this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          }
        }
        else {
          this.elements.marqueeContainer.style.overflow = 'scroll';
          this.elements.marqueeContainer.style.minHeight = '75vh';
          this.elements.marqueeDisplay.style.whiteSpace = 'normal';
          this.elements.marqueeDisplay.style.textAlign = 'left';
          this.elements.marqueeDisplay.style.left = '0px';
          this.elements.playPauseButton.style.display = 'none';
          this.elements.stopButton.style.display = 'none';
          this.elements.rewindButton.style.display = 'none';
          this.elements.fastForwardButton.style.display = 'none';
          this.elements.refreshSentences.style.display = 'none';
          this.elements.refreshWords.style.display = 'none';
          this.elements.refreshView.style.display = 'none';
          this.elements.refreshColors.style.display = 'none';
          this.elements.copyMarqueeText.style.display = 'none';
          this.elements.speakButton.style.display = 'none';
          this.elements.searchButton.style.display = 'none';
          this.elements.bookmarksButton.style.display = 'none';
          this.elements.controlsContainerFooter.style.display = 'none';
          this.elements.loopToggle.style.display = 'none';
          this.elements.progressDisplay.style.display = 'none';
          this.elements.tabNavigation.style.display = 'none';
          this.elements.tabContent.style.display = 'none';
          this.elements.progressBarContainer.style.display = 'none';
          this.elements.textViewButton.innerHTML = 'Back to previous position';
          const backToCurrentButton = document.createElement('button');
          backToCurrentButton.style = this.elements.textViewButton.style;
          backToCurrentButton.innerHTML = 'Back to current position';
          backToCurrentButton.addEventListener('click', () => this.toggleTextView(true));
          this.elements.textViewContainer.appendChild(backToCurrentButton);
          const marqueeContainerRect = this.elements.marqueeContainer.getBoundingClientRect();
          const marqueeDisplayRect = this.elements.marqueeDisplay.getBoundingClientRect();
          this.elements.marqueeDisplay.style.height = `${marqueeContainerRect.height + marqueeDisplayRect.height}px`;
          if (this.targetWordIndex != null) {
            this.getWordItemByWordIndex(this.targetWordIndex)?.scrollIntoView();
          }
        }
        this.isTextViewActive = !this.isTextViewActive;
      },

      toggleAttemptMinTime() {
        const value = parseInt(this.elements.attemptMinTimeInput.value);
        if (value === value && value >= 1) {
          localStorage.setItem(this.settingsNames.attemptMinTime, value);
        }
        else {
          this.elements.attemptMinTimeInput.value = '1';
        }
      },

      toggleShowHideText() {
        const visible = this.elements.showHideTextToggle.checked;
        if (visible) {
          this.elements.textInput.style.display = '';
        }
        else {
          this.elements.textInput.style.display = 'none';
        }
        localStorage.setItem(this.settingsNames.showHideTextToggle, visible);
      },

      toggleTextDirection() {
        const textDirectionValue = this.elements.textDirectionSelect.value;
        if (textDirectionValue === 'ltr') {
          this.elements.progressBarContainer.style.direction = '';
          this.elements.controlsContainer.style.direction = '';
          this.elements.marqueeContainer.style.transform = '';
          this.elements.marqueeDisplay.style.transform = '';
          this.elements.marqueeDisplay.style.direction = 'ltr';
        }
        else if (textDirectionValue === 'rtl') {
          this.elements.progressBarContainer.style.direction = 'rtl';
          this.elements.controlsContainer.style.direction = 'rtl';
          this.elements.marqueeContainer.style.transform = 'scale(-1, 1)';
          this.elements.marqueeDisplay.style.transform = 'scale(-1, 1)';
          this.elements.marqueeDisplay.style.direction = 'rtl';
        }
      },

      fontInputChanged(selectPriority = false) {
        const currentValue = this.elements.fontFamilyInput.value;
        const options = this.elements.fontListSelect.options;
        let found = false;
        if (currentValue !== '-' || selectPriority) {
          for (let i = 0; i < options.length; ++i) {
            if (options[i].value === currentValue) {
              found = true;
              this.elements.fontListSelect.value = currentValue;
              break;
            }
          }
        }
        if (found || currentValue === '') {
          this.elements.fontListSelect.style.display = '';
          this.elements.fontFamilyInput.style.display = 'none';
        }
        else {
          this.elements.fontListSelect.style.display = 'none';
          this.elements.fontFamilyInput.style.display = '';
        }
      },

      fontListOptionSelected() {
        if (this.elements.fontListSelect.value === '-') {
          this.elements.fontListSelect.style.display = 'none';
          this.elements.fontFamilyInput.style.display = '';
        }
        this.elements.fontFamilyInput.value = this.elements.fontListSelect.value;
      },

      toggleFontFamily() {
        if (this.targetWordIndex == null) {
          this.targetWordIndex = this.getFirstVisibleWordIndex();
        }
        this.elements.fontListSelect.style.display = 'none';
        this.elements.fontFamilyInput.style.display = '';
        let fontFamilyValue = this.elements.fontFamilyInput.value;
        if (fontFamilyValue && fontFamilyValue !== '-') {
          if (![...this.elements.fontListSelect.options].some((t) => t.value === fontFamilyValue)) {
            fontFamilyValue = fontFamilyValue.split(/\s*?,\s*/).map((v) => [...this.elements.fontListSelect.options].some((t) => t.value === v) ? v : "'".concat(v.replace(/^["']+|["']+$/g, '')).concat("'")).join(', ');
          }
          this.elements.marqueeContainer.style.fontFamily = fontFamilyValue;
        }
        else {
          this.elements.marqueeContainer.style.fontFamily = "'Open Sans', sans-serif";
        }
        this.fontInputChanged(true);
        let fontStyleValue = this.elements.fontStyleSelect.value;
        if (fontStyleValue && fontStyleValue !== '-') {
          if (fontStyleValue.includes('bold')) {
            this.elements.marqueeContainer.style.fontWeight = 'bold';
          }
          else {
            this.elements.marqueeContainer.style.fontWeight = '';
          }
          if (fontStyleValue.includes('italic')) {
            this.elements.marqueeContainer.style.fontStyle = 'italic';
          }
          else {
            this.elements.marqueeContainer.style.fontStyle = '';
          }
        }
        else {
          this.elements.marqueeContainer.style.fontWeight = '';
          this.elements.marqueeContainer.style.fontStyle = '';
        }
        if (this.targetWordIndex != null) {
          this.currentPosition = this.getPositionByWordIndex(this.targetWordIndex);
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        }
      },

      toggleRemoveMarks() {
        const removeMarksToggleChecked = this.elements.removeMarksToggle.checked;
        localStorage.setItem(this.settingsNames.removeMarksToggle, removeMarksToggleChecked);
      },

      removeMarksIfNeeded(text) {
        const removeMarksToggleChecked = this.elements.removeMarksToggle.checked;
        if (removeMarksToggleChecked) {
          const newTextL = [];
          for (const ch of text) {
            newTextL.push(this.marksReplacementTrans[ch] || ch);
          }
          text = newTextL.join('').replace(/[\u0300\u0301\u030F\u030B\u0316\u0317\u0340\u0341]/ug, '').trim();
        }
        return text;
      },

      toggleLoop() {
        this.isLoopEnabled = !this.isLoopEnabled;
        this.elements.loopToggle.classList.toggle('active');
        localStorage.setItem(this.settingsNames.loop, this.isLoopEnabled);
      },

      toggleImportReplacement() {
        const importDataReplacementElem = this.elements.importDataReplacement.find((elem) => elem.checked);
        if (importDataReplacementElem) {
          localStorage.setItem(this.settingsNames.importDataReplacement, importDataReplacementElem.value);
        }
      },

      getImportReplacement() {
        const importDataReplacementElem = this.elements.importDataReplacement.find((elem) => elem.checked);
        if (importDataReplacementElem) {
          return importDataReplacementElem.value;
        }
        return this.importDataReplacementVariants.addAsNew;
      },

      getNextName(currentName, allNames) {
        let tmpName = currentName.trim();
        while (allNames.includes(tmpName)) {
          let number = 0;
          let prefix = tmpName;
          let found = false;
          for (const [open, close] of [['(', ')'], ['[', ']'], ['{', '}']]) {
            if (tmpName.endsWith(close)) {
              const lastOpen = tmpName.lastIndexOf(open);
              if (lastOpen !== -1) {
                const numStr = tmpName.slice(lastOpen + 1, -1);
                number = parseInt(numStr);
                if (number === number) {
                  prefix = tmpName.slice(0, lastOpen).trim();
                  found = true;
                  break;
                }
                else {
                  number = 0;
                }
              }
            }
          }
          if (found) {
            const nextNumber = number + 1;
            tmpName = `${prefix} (${nextNumber})`;
          } else {
            tmpName = `${tmpName} (1)`;
          }
        }
        return tmpName;
      },

      toggleFasterTransitions() {
        localStorage.setItem(this.settingsNames.fasterTransitionsToggle, this.elements.fasterTransitionsToggle.checked);
      },

      toggleSpeakWordByWord() {
        if (this.elements.speakWordByWordToggle.checked) {
          this.elements.speakSentenceBySentenceToggle.checked = false;
        }
        localStorage.setItem(this.settingsNames.speakWordByWordToggle, this.elements.speakWordByWordToggle.checked);
      },

      toggleSpeakSentenceBySentence() {
        if (this.elements.speakSentenceBySentenceToggle.checked) {
          this.elements.speakWordByWordToggle.checked = false;
        }
        localStorage.setItem(this.settingsNames.speakSentenceBySentenceToggle, this.elements.speakSentenceBySentenceToggle.checked);
      },

      toggleExportTextsWithBookmarks() {
        localStorage.setItem(this.settingsNames.exportTextsWithBookmarksToggle, this.elements.exportAllTextsWithBookmarksToggle.checked);
      },

      toggleExportHistory() {
        localStorage.setItem(this.settingsNames.exportHistoryToggle, this.elements.exportHistoryToggle.checked);
      },

      saveSentenceCountToGenerate() {
        localStorage.setItem(this.settingsNames.sentenceCountToGenerate, this.elements.sentenceCountInput.value);
      },

      saveWikiLang() {
        localStorage.setItem(this.settingsNames.wikiLang, this.elements.loadWikiLanguageSelect.value);
      },

      switchTab(button) {
        this.elements.tabButtons.forEach(btn => {
          btn.classList.remove('active');
          btn.setAttribute('aria-selected', 'false');
        });
        button.classList.add('active');
        button.setAttribute('aria-selected', 'true');
        const tabId = button.getAttribute('data-tab');
        this.elements.tabContents.forEach(content => {
          content.classList.toggle('active', content.id === tabId);
        });
        localStorage.setItem(this.settingsNames.activeTab, button.getAttribute('data-tab'))
      },

      restoreActiveTab() {
        const activeTab = localStorage.getItem(this.settingsNames.activeTab) || 'info-tab';
        if (activeTab) {
          var activeTabButton = document.querySelector(`.tab-button[data-tab="${activeTab}"]`);
          if (activeTabButton) {
            this.switchTab(activeTabButton);
          }
        }
      },

      adjustFontSize(value) {
        if (this.targetWordIndex == null) {
          this.targetWordIndex = this.getFirstVisibleWordIndex();
        }
        this.elements.fontSizeSlider.value = value;
        this.elements.fontSizeNumber.value = value;
        this.elements.marqueeDisplay.style.fontSize = `${value}px`;
        this.updateCachedSizes();
        if (this.targetWordIndex != null) {
          this.currentPosition = this.getPositionByWordIndex(this.targetWordIndex);
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        }
      },

      adjustRsvpPunctuationDelay(value) {
        this.elements.rsvpPunctuationDelayNumber.value = value;
        this.elements.rsvpPunctuationDelaySlider.value = value;
      },

      adjustSpeed(value) {
        if (value !== value) {
          value = 0;
        }
        const speed = Math.max(1, parseInt(value || this.elements.speedNumber.value || 0));
        this.elements.speedSlider.value = speed;
        this.elements.speedNumber.value = speed;

        const speedEntry = { stepSize: speed / 1000, stepDelay: 1 };
        const speedSmooth = this.elements.speedSmoothToggle.checked;
        const newStepSize = speedSmooth ? speedEntry.stepSize * 10 : speedEntry.stepSize;
        const newStepDelay = speedSmooth ? speedEntry.stepDelay : speedEntry.stepDelay;
        const newSpeed = speed;

        if (this.animationTimer != null) {
          this.newStepSize = newStepSize;
          this.newStepDelay = newStepDelay;
          this.newSpeed = newSpeed;
        } else {
          this.stepSize = newStepSize;
          this.stepDelay = newStepDelay;
          this.speed = newSpeed;
        }
      },

      rewind() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          if (this.elements.rsvpToggle.checked) {
            const containerRect = this.elements.marqueeContainer.getBoundingClientRect();
            const startPos = containerWidth;
            const endPos = -textWidth;
            const spans = Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span'));
            const shift = containerWidth * 0.5;
            let startSpanIndex = 0;
            for (let i = 0; i < spans.length; i++) {
              const currentSpanRect = spans[i].getBoundingClientRect();
              if (shift <= currentSpanRect.x + currentSpanRect.width - containerRect.x) {
                startSpanIndex = i - 1;
                break;
              }
            }
            startSpanIndex = Math.max(0, startSpanIndex);
            if (0 <= startSpanIndex && startSpanIndex < spans.length) {
              const spanRect = spans[startSpanIndex].getBoundingClientRect();
              const marqueeRect = this.elements.marqueeDisplay.getBoundingClientRect();
              const spanPos = -(spanRect.left - marqueeRect.left) + shift;
              this.currentPosition = Math.max(endPos, Math.min(startPos, spanPos));
            }
          }
          else {
            this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left) + Math.floor(containerWidth / 4)));
          }
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      fastForward() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          if (this.elements.rsvpToggle.checked) {
            const containerRect = this.elements.marqueeContainer.getBoundingClientRect();
            const startPos = containerWidth;
            const endPos = -textWidth;
            const spans = Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span'));
            const shift = containerWidth * 0.5;
            let startSpanIndex = 0;
            for (let i = 0; i < spans.length; i++) {
              const currentSpanRect = spans[i].getBoundingClientRect();
              if (shift <= currentSpanRect.x + currentSpanRect.width - containerRect.x) {
                startSpanIndex = i + 1;
                break;
              }
            }
            startSpanIndex = Math.min(spans.length - 1, startSpanIndex);
            if (0 <= startSpanIndex && startSpanIndex < spans.length) {
              const spanRect = spans[startSpanIndex].getBoundingClientRect();
              const marqueeRect = this.elements.marqueeDisplay.getBoundingClientRect();
              const spanPos = -(spanRect.left - marqueeRect.left) + shift;
              this.currentPosition = Math.max(endPos, Math.min(startPos, spanPos));
            }
          }
          else {
            this.currentPosition = Math.max(-textWidth, Math.min(containerWidth, parseInt(this.elements.marqueeDisplay.style.left) - Math.floor(containerWidth / 4)));
          }
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      goToStartPosition() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = containerWidth;
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      goToEndPosition() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          this.currentPosition = -textWidth;
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeSentences() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          this.realText = '';
          this.realText1List = [];
          this.realText1RefList = [];
          this.realText2List = [];
          this.startAnimation(false, false);
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeWords() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          this.textNeedsUpdate = true;
          this.startAnimation(false, false);
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeView() {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          this.wasColorTaskChecked = false;
          this.startAnimation(false, false);
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      refreshMarqueeColors(fullUpdate = true) {
        if (this.currentPosition !== null) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          if (fullUpdate && this.elements.colorEncoderToggle.checked) {
            this.colorMap.clear();
            this.colorList = [];
          }
          this.wasColorTaskChecked = false;
          this.startAnimation(false, false);
          this.savePosition();
          if (wasPlaying) this.startAnimation(true);
        }
      },

      copyMarqueeText() {
        if (this.currentPosition !== null) {
          navigator.clipboard.writeText(this.realText2List.join(' '));
        }
      },

      copyCurrentText() {
        navigator.clipboard.writeText(this.elements.textInput.value);
      },

      showHiddenContent1() {
        this.elements.hiddenContent1.style.display = this.elements.hiddenContent1.style.display ? '' : 'none';
      },

      toggleSkewing() {
        const isVisible = this.elements.skewingToggle.checked;
        this.elements.skewingOptions.style.display = isVisible ? '' : 'none';
        this.elements.skewingDiv.classList.remove('with-rounded-border');
        if (isVisible) {
          this.elements.skewingDiv.classList.add('with-rounded-border');
        }
      },

      toggleRotN() {
        const isVisible = this.elements.rotNToggle.checked;
        this.elements.rotNOptions.style.display = isVisible ? '' : 'none';
        this.elements.rotNDiv.classList.remove('with-rounded-border');
        if (isVisible) {
          this.elements.rotNDiv.classList.add('with-rounded-border');
        }
      },

      toggleRotNGenerate(onlyLoad = false) {
        const rotNToggleChecked = this.elements.rotNToggle.checked;
        const rotNNumberMinValue = parseInt(this.elements.rotNNumberMin.value || 0);
        const rotNNumberMaxValue = parseInt(this.elements.rotNNumberMax.value || 0);
        const rotNComplexityValue = parseInt(this.elements.rotNComplexity.value || 0);
        const rotNLanguageValue = this.elements.rotNLanguageSelect.value;
        const rotNExcludeZeroChecked = this.elements.rotNExcludeZero.checked;
        const rotNEachMappingChecked = this.elements.rotNEachMapping.checked;
        const rotNUpperCaseLowerCase = this.elements.rotNUpperCaseLowerCase.checked;
        if (onlyLoad) {
          this.letterMapItemMaxLength = 0;
          for (const key of this.rotNLetterMap.keys()) {
            this.letterMapItemMaxLength = Math.max(this.letterMapItemMaxLength, key.length);
          }
        }
        else {
          this.letterMapItemMaxLength = 0;
          this.rotNLetterMap = new Map();
          this.settingsProfileIsModified = true;
        }
        if (!onlyLoad && rotNToggleChecked && rotNNumberMinValue === rotNNumberMinValue &&
            rotNNumberMaxValue === rotNNumberMaxValue && rotNNumberMinValue <= rotNNumberMaxValue &&
            rotNComplexityValue === rotNComplexityValue &&
            rotNLanguageValue) {
          let alphabet1Options = false;
          for (const alphabet of this.alphabets) {
            if (alphabet[0] === rotNLanguageValue) {
              const alphabetVariants = alphabet[2];
              alphabet1Options = alphabetVariants.length;
              let rotNNumberGValue = this.randomInt(rotNNumberMinValue, rotNNumberMaxValue);
              if (rotNExcludeZeroChecked && rotNNumberMinValue !== rotNNumberMaxValue) {
                while (rotNNumberGValue === 0) {
                  rotNNumberGValue = this.randomInt(rotNNumberMinValue, rotNNumberMaxValue);
                }
              }
              let alphabetVariantIndex = 0;
              for (const alphabetVariant of alphabetVariants) {
                for (let i = 0; i < alphabetVariant.length; ++i) {
                  let rotNNumberValue = rotNEachMappingChecked ? this.randomInt(rotNNumberMinValue, rotNNumberMaxValue) : rotNNumberGValue;
                  if (rotNExcludeZeroChecked && rotNNumberMinValue !== rotNNumberMaxValue) {
                    while (rotNNumberValue === 0) {
                      rotNNumberValue = this.randomInt(rotNNumberMinValue, rotNNumberMaxValue);
                    }
                  }
                  let stdIndex = i + rotNNumberValue;
                  const position = (rotNNumberValue >= 0
                    ? stdIndex % alphabetVariant.length
                    : ((stdIndex % alphabetVariant.length) + alphabetVariant.length) % alphabetVariant.length);
                  let previousLetter = alphabetVariantIndex > 0 && rotNUpperCaseLowerCase ? alphabetVariants[alphabetVariantIndex - 1][i] : '';
                  this.rotNLetterMap.set(alphabetVariant[i], [alphabetVariant[position]]);
                  if (previousLetter) {
                    let previousLetterMapping = alphabetVariants[alphabetVariantIndex - 1][position];
                    if (previousLetterMapping && previousLetter !== previousLetterMapping) {
                      this.rotNLetterMap.set(previousLetter, [previousLetterMapping]);
                    }
                  }
                  this.letterMapItemMaxLength = Math.max(this.letterMapItemMaxLength, alphabetVariant[i].length);
                }
                alphabetVariantIndex += 1;
              }
              break;
            }
          }
          if (rotNComplexityValue > 0) {
            const variants = [];
            for (const alphabet of this.alphabets) {
              if (alphabet[0] === rotNLanguageValue) {
                const alphabetVariants = alphabet[2];
                for (const alphabetVariant of alphabetVariants) {
                  for (let i = 0; i < alphabetVariant.length; ++i) {
                    let cnt = 0;
                    for (let rotNNumberValue = rotNNumberMinValue; rotNNumberValue <= rotNNumberMaxValue; ++rotNNumberValue) {
                      if (rotNExcludeZeroChecked && rotNNumberValue === 0) {
                        continue;
                      }
                      const position = (rotNNumberValue >= 0
                        ? (i + rotNNumberValue) % alphabetVariant.length
                        : (((i + rotNNumberValue) % alphabetVariant.length) + alphabetVariant.length) % alphabetVariant.length);
                      if (!(this.rotNLetterMap.get(alphabetVariant[i]) || []).includes(alphabetVariant[position])) {
                        let alphabetVariantSi = [];
                        let alphabetVariantPositionSi = [];
                        if (rotNUpperCaseLowerCase) {
                          for (const alphabetVariantS of alphabetVariants) {
                            alphabetVariantSi.push(alphabetVariantS[i]);
                            alphabetVariantPositionSi.push(alphabetVariantS[position]);
                          }
                        }
                        else {
                          alphabetVariantSi.push(alphabetVariant[i]);
                          alphabetVariantPositionSi.push(alphabetVariant[position]);
                        }
                        variants.push([alphabetVariantSi, alphabetVariantPositionSi]);
                        cnt += 1;
                        if (variants.length > rotNComplexityValue && cnt > 5) {
                          break;
                        }
                      }
                    }
                  }
                  if (rotNUpperCaseLowerCase) {
                    break;
                  }
                }
                break;
              }
            }
            this.shuffleArray(variants);
            let n = rotNComplexityValue;
            for (const [variantsKey, variantsValue] of variants) {
              for (const variantKey of variantsKey) {
                let filteredVariantsValue = [];
                for (const variantValue of variantsValue) {
                  if (!rotNUpperCaseLowerCase || alphabet1Options === 1 && variantValue !== variantKey ||
                      variantKey !== variantKey.toLowerCase() &&
                      variantValue !== variantValue.toLowerCase() ||
                      variantKey !== variantKey.toUpperCase() &&
                      variantValue !== variantValue.toUpperCase()) {
                    filteredVariantsValue.push(variantValue);
                  }
                }
                n -= filteredVariantsValue.length;
                const newMapping = [...(this.rotNLetterMap.get(variantKey) || []), ...filteredVariantsValue];
                this.rotNLetterMap.set(variantKey, newMapping);
                if (n <= 0) {
                  break;
                }
              }
              if (n <= 0) {
                break;
              }
            }
          }
        }
        this.toggleRotNLanguageInfo(false);
      },

      toggleRotNLanguageInfo(elemUpdated = true) {
        const rotNToggleChecked = this.elements.rotNToggle.checked;
        const rotNNumberMinValue = parseInt(this.elements.rotNNumberMin.value || 0);
        const rotNNumberMaxValue = parseInt(this.elements.rotNNumberMax.value || 0);
        const rotNComplexityValue = parseInt(this.elements.rotNComplexity.value || 0);
        const rotNLanguageValue = this.elements.rotNLanguageSelect.value;
        if (!elemUpdated && rotNNumberMinValue === rotNNumberMinValue &&
            rotNNumberMaxValue === rotNNumberMaxValue && rotNNumberMinValue <= rotNNumberMaxValue &&
            rotNComplexityValue === rotNComplexityValue &&
            rotNLanguageValue) {
          const infoValue = [];
          let allEquals = true;
          let tmpValue = [];
          for (const alphabet of this.alphabets) {
            if (alphabet[0] === rotNLanguageValue) {
              const alphabetVariants = alphabet[2];
              for (const alphabetVariant of alphabetVariants) {
                if (infoValue.length > 0) {
                  infoValue.push(tmpValue.join(' '));
                  tmpValue = [];
                  infoValue.push("<hr>");
                }
                for (let i = 0; i < alphabetVariant.length; ++i) {
                  const variants = (this.rotNLetterMap.get(alphabetVariant[i]) || [alphabetVariant[i]]);
                  const variantsString = variants.join('|');
                  if (alphabetVariant[i] === variantsString) {
                    continue;
                  }
                  allEquals = false;
                  tmpValue.push(`<div class="translation"><span>${alphabetVariant[i]}</span> &#8594; <span>${variantsString}</span></div>`);
                  if (tmpValue.length >= 5) {
                    infoValue.push(tmpValue.join(' '));
                    tmpValue = [];
                  }
                }
              }
              break;
            }
          }
          if (tmpValue.length > 0) {
            infoValue.push(tmpValue.join(' '));
            tmpValue = [];
          }
          if (allEquals && infoValue.length === 0) {
            const alphabetName = Array.from(this.elements.rotNLanguageSelect).find(v => v.value === rotNLanguageValue).textContent;
            infoValue.push(`<div class="translation">${alphabetName}</div>`);
          }
          this.elements.rotNLanguageInfo.innerHTML = infoValue.join('');
        }
        else {
          this.elements.rotNLanguageInfo.innerHTML = '';
        }
      },

      toggleColorEncoder(updateMarqueeTextBlock = false) {
        const isVisible = this.elements.colorEncoderToggle.checked;
        this.elements.colorEncoderOptions.style.display = isVisible ? '' : 'none';
        this.elements.colorDetails.style.display = this.elements.showColorInfoToggle.checked && isVisible ? '' : 'none';
        this.elements.colorEncoderDiv.classList.remove('with-rounded-border');
        if (isVisible) {
          this.elements.colorEncoderDiv.classList.add('with-rounded-border');
        }
        if (updateMarqueeTextBlock) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();
          this.wasColorTaskChecked = false;
          if (this.elements.textInput.value) {
            this.startAnimation(false, false);
          }
          if (wasPlaying) this.startAnimation(true);
        }
      },

      toggleColorDetails() {
        const isVisible = this.elements.showColorInfoToggle.checked && this.elements.colorEncoderToggle.checked;
        this.elements.colorDetails.style.display = isVisible ? '' : 'none';
        localStorage.setItem(this.settingsNames.showColorInfoToggle, this.elements.showColorInfoToggle.checked);
      },

      toggleAppendText() {
        localStorage.setItem(this.settingsNames.appendTextToggle, this.elements.appendTextToggle.checked);
      },

      dumpColorMap() {
        const currentReader = this;
        currentReader.colorList.forEach(char => {
          const color = currentReader.hexToRgb(currentReader.colorMap.get(char));
          const entry = `${char} ${color}`;
          if (!currentReader.elements.colorInput.value.includes(entry)) {
            currentReader.elements.colorInput.value += (currentReader.elements.colorInput.value && !currentReader.elements.colorInput.value.endsWith('\n') ? '\n' : '') + entry + '\n';
          }
        });
      },

      clearInput() {
        this.elements.textInput.value = '';
        this.textIsModified = true;
      },

      fetchSentenceWordsmythBeginner() {
        if (this.animationTimer != null) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceWordsmyth1Generator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = this.removeMarksIfNeeded(/[.!?]$/.test(sentence) ? sentence : `${sentence}.`);
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchSentenceWordsmythIntermediate() {
        if (this.animationTimer != null) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceWordsmyth2Generator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = this.removeMarksIfNeeded(/[.!?]$/.test(sentence) ? sentence : `${sentence}.`);
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchSentenceWordsmythAdvanced() {
        if (this.animationTimer != null) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceWordsmyth3Generator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = this.removeMarksIfNeeded(/[.!?]$/.test(sentence) ? sentence : `${sentence}.`);
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchSentenceMerriamWebster() {
        if (this.animationTimer != null) {
          return;
        }
        const nSentences = Math.max(0, this.elements.sentenceCountInput.value);
        for (let i = 0; i < nSentences; ++i) {
          const next = this.sentenceMerriamWebsterGenerator.next();
          if (!next.done) {
            const sentence = next.value;
            if (sentence) {
              const text = this.removeMarksIfNeeded(/[.!?]$/.test(sentence) ? sentence : `${sentence}.`);
              this.elements.textInput.value = this.elements.appendTextToggle.checked ? `${this.elements.textInput.value}${this.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              this.textIsModified = true;
            }
          }
        }
      },

      fetchWikipedia(cycle = false) {
        if (this.animationTimer != null || this.elements.sentenceCountInput.value <= 0) {
          return;
        }
        const currentReader = this;
        const currentHash = cycle ? currentReader.sentenceHash : (currentReader.sentenceHash += 1);
        if (!cycle) {
          currentReader.sentenceInitCount = currentReader.elements.sentenceCountInput.value - 1;
          currentReader.sentenceCounter = currentReader.sentenceInitCount;
        }
        const lang = currentReader.elements.loadWikiLanguageSelect.value;
        if (lang) {
          fetch(`https://${lang}.wikipedia.org/api/rest_v1/page/random/summary`)
          .then(response => response.json())
          .then(data => {
            const text = this.removeMarksIfNeeded(data.extract.trim());
            currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
            currentReader.textIsModified = true;
            if (currentHash === currentReader.sentenceHash && currentReader.sentenceCounter > 0) {
              currentReader.sentenceCounter = Math.max(0, currentReader.sentenceCounter - 1);
              setTimeout(() => currentReader.fetchWikipedia(true), currentReader.sentenceDownloadDelay);
            }
            else if (currentHash === currentReader.sentenceHash && currentReader.sentenceInitCount >= 1 && currentReader.sentenceCounter <= 0) {
              setTimeout(() => alert('Download completed!'), 1);
            }
          })
          .catch(() => alert('[Wiki] Data fetching error'));
        }
      },

      fetchUnderthekey(cycle = false) {
        if (this.animationTimer != null || this.elements.sentenceCountInput.value <= 0) {
          return;
        }
        const currentReader = this;
        const currentHash = cycle ? currentReader.sentenceHash : (currentReader.sentenceHash += 1);
        if (!cycle) {
          currentReader.sentenceInitCount = currentReader.elements.sentenceCountInput.value - 1;
          currentReader.sentenceCounter = currentReader.sentenceInitCount;
        }
        fetch('https://sentence.underthekey.com/language?language=eng')
          .then(response => response.json())
          .then(data => {
            for (const sentence of data) {
              const text = this.removeMarksIfNeeded(sentence['content'].trim());
              currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              currentReader.textIsModified = true;
            }
            if (currentHash === currentReader.sentenceHash && currentReader.sentenceCounter > 0) {
              currentReader.sentenceCounter = Math.max(0, currentReader.sentenceCounter - 1);
              setTimeout(() => currentReader.fetchUnderthekey(true), currentReader.sentenceDownloadDelay);
            }
            else if (currentHash === currentReader.sentenceHash && currentReader.sentenceInitCount >= 1 && currentReader.sentenceCounter <= 0) {
              setTimeout(() => alert('Download completed!'), 1);
            }
          })
          .catch(() => alert('[Underthekey] Data fetching error'));
      },

      fetchMetaphorpsum(cycle = false) {
        if (this.animationTimer != null || this.elements.sentenceCountInput.value <= 0) {
          return;
        }
        const currentReader = this;
        const currentHash = cycle ? currentReader.sentenceHash : (currentReader.sentenceHash += 1);
        if (!cycle) {
          currentReader.sentenceInitCount = currentReader.elements.sentenceCountInput.value - 1;
          currentReader.sentenceCounter = currentReader.sentenceInitCount;
        }
        fetch('http://metaphorpsum.com/sentences/1')
          .then(response => response.text())
          .then(data => {
            const text = this.removeMarksIfNeeded(data.trim());
            currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
            currentReader.textIsModified = true;
            if (currentHash === currentReader.sentenceHash && currentReader.sentenceCounter > 0) {
              currentReader.sentenceCounter = Math.max(0, currentReader.sentenceCounter - 1);
              setTimeout(() => currentReader.fetchMetaphorpsum(true), currentReader.sentenceDownloadDelay);
            }
            else if (currentHash === currentReader.sentenceHash && currentReader.sentenceInitCount >= 1 && currentReader.sentenceCounter <= 0) {
              setTimeout(() => alert('Download completed!'), 1);
            }
          })
          .catch(() => alert('[Metaphorpsum] Data fetching error'));
      },

      loadFromFile() {
        if (this.animationTimer != null) {
          return;
        }
        const currentReader = this;
        const input = document.createElement('input');
        input.type = 'file';
        input.onchange = e => {
          const file = e.target.files[0];
          if (file) {
            const reader = new FileReader();
            reader.onload = event => {
              const text = this.removeMarksIfNeeded(event.target.result.trim());
              currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
              currentReader.textIsModified = true;
            };
            reader.readAsText(file);
          }
        };
        this.elements.body.appendChild(input);
        input.click();
        this.elements.body.removeChild(input);
      },

      loadGemini() {
        if (this.animationTimer != null || this.elements.geminiModelSelect.value.length === 0 || this.elements.geminiKeyInput.value.length === 0 || this.elements.geminiQueryInput.value.length === 0) {
          return;
        }
        const currentReader = this;
        const url = 'https://generativelanguage.googleapis.com/v1beta/models/'.concat(this.elements.geminiModelSelect.value).concat(':generateContent?key=').concat(this.elements.geminiKeyInput.value);
        const headers = {
          'Content-Type': 'application/json'
        };
        const data = {
          contents: [
            {
              parts: [
                {
                  text: this.elements.geminiQueryInput.value
                }
              ]
            }
          ]
        };
        fetch(url, {
          method: 'POST',
          headers: headers,
          body: JSON.stringify(data)
        })
          .then(response => response.json())
          .then(data => {
            const text = this.removeMarksIfNeeded(data.candidates[0].content.parts.map(t => t.text).join('\n').trim());
            currentReader.elements.textInput.value = currentReader.elements.appendTextToggle.checked ? `${currentReader.elements.textInput.value}${currentReader.elements.textInput.value ? '\n\n' : ''}${text}` : text;
            currentReader.textIsModified = true;
          })
          .catch(() => alert('[Gemini] Data fetching error'));
      },

      shuffleParagraphsInText() {
        const currentReader = this;
        const text = this.elements.textInput.value;
        const paragraphs = text.split('\n').filter(p => p.trim());
        currentReader.shuffleArray(paragraphs);
        this.elements.textInput.value = paragraphs.join('\n\n');
        this.textIsModified = true;
      },

      splitIntoSentences(paragraph) {
        paragraph = paragraph.split('\n').filter(p => p.trim()).join(' ');
        const sentences = [];
        let currentSentence = '';
        let lastWordCapitalized = true;
        for (let i = 0; i < paragraph.length; i++) {
          const char = paragraph[i];
          currentSentence += char;
          if (this.spacePattern.test(char)) {
            lastWordCapitalized = false;
            continue;
          }
          else if (i > 0 && this.spacePattern.test(paragraph[i - 1]) && char !== char.toLowerCase()) {
            lastWordCapitalized = true;
            continue;
          }
          else if (char === '.' || char === '!' || char === '?') {
            if (i === paragraph.length - 1 || this.spacePattern.test(paragraph[i + 1]) && (char !== '.' || !lastWordCapitalized)) {
              sentences.push(currentSentence.trim());
              currentSentence = '';
              i++;
            }
          }
        }
        currentSentence = currentSentence.trim();
        if (currentSentence) {
          const lastChar = currentSentence[currentSentence.length - 1];
          if (!(lastChar === '.' || lastChar === '!' || lastChar === '?')) {
            currentSentence = currentSentence.concat('.');
          }
          sentences.push(currentSentence);
        }
        return sentences;
      },

      shuffleSentencesInText() {
        const currentReader = this;
        const text = this.elements.textInput.value;
        const paragraphs = text.split('\n').filter(p => p.trim());
        const processedParagraphs = paragraphs.map(paragraph => {
          const sentences = currentReader.splitIntoSentences(paragraph);
          currentReader.shuffleArray(sentences);
          return sentences.join(' ');
        });
        this.elements.textInput.value = processedParagraphs.join('\n\n');
        this.textIsModified = true;
      },

      splitIntoParagraphsInText() {
        const currentReader = this;
        const text = this.elements.textInput.value;
        const sentences = this.splitIntoSentences(text);
        this.elements.textInput.value = sentences.join('\n\n');
        this.textIsModified = true;
      },

      shuffleSentences(text, referenceText, sentenceShuffleNumber) {
        const textSentences = this.splitIntoSentences(text);
        const referenceTextSentences = this.splitIntoSentences(referenceText);
        if (textSentences.length === referenceTextSentences.length) {
          if (sentenceShuffleNumber < 0) {
            sentenceShuffleNumber = textSentences.length;
          }
          const newTextSentences = [], newReferenceTextSentences = [];
          for (let i = 0; i < textSentences.length;) {
            const textSentencesPart = textSentences.slice(i, i + sentenceShuffleNumber);
            const referenceTextSentencesPart = referenceTextSentences.slice(i, i + sentenceShuffleNumber);
            const sentencesParts = [];
            for (let j = 0; j < textSentencesPart.length; ++j) {
              sentencesParts.push([textSentencesPart[j], referenceTextSentencesPart[j]]);
            }
            this.shuffleArray(sentencesParts);
            for (let j = 0; j < sentencesParts.length; ++j) {
              newTextSentences.push(sentencesParts[j][0]);
              newReferenceTextSentences.push(sentencesParts[j][1]);
            }
            i += sentenceShuffleNumber;
          }
          text = newTextSentences.join(' ');
          referenceText = newReferenceTextSentences.join(' ');
        }
        return [text, referenceText];
      },

      getProgressByPosition(position = null) {
        if (position == null) {
          position = this.currentPosition;
        }
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        if (position == null || containerWidth == null || textWidth == null) {
          return 0;
        }
        const startPos = containerWidth;
        const endPos = -textWidth;
        return Math.max(0, Math.min(100, (position - startPos) * 100 / (endPos - startPos)));
      },

      getPositionByProgress(positionPercent = null) {
        if (positionPercent == null) {
          positionPercent = this.getProgressByPosition();
        }
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        if (positionPercent == null || containerWidth == null || textWidth == null) {
          return null;
        }
        const startPos = containerWidth;
        const endPos = -textWidth;
        return Math.max(endPos, Math.min(startPos, positionPercent * (endPos - startPos) / 100 + startPos));
      },

      getFirstVisibleWordIndex() {
        const containerRect = this.elements.marqueeContainer.getBoundingClientRect();
        let wordIndex = 0, targetWordIndex = -1;
        for (const elem of this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')) {
          if (elem.classList.contains(this.newWordMark)) {
            continue;
          }
          const rect = elem.getBoundingClientRect();
          if (0 <= rect.x + rect.width - containerRect.x) {
            targetWordIndex = wordIndex;
            break;
          }
          wordIndex += 1;
        }
        return targetWordIndex !== -1 ? targetWordIndex : null;
      },

      getFirstVerticalVisibleWordIndex() {
        const containerRect = this.elements.marqueeContainer.getBoundingClientRect();
        let wordIndex = 0, targetWordIndex = -1;
        for (const elem of this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')) {
          if (elem.classList.contains(this.newWordMark)) {
            continue;
          }
          targetWordIndex = wordIndex;
          const rect = elem.getBoundingClientRect();
          if (0 <= rect.y + rect.height * 1 / 2 - containerRect.y) {
            break;
          }
          wordIndex += 1;
        }
        return targetWordIndex !== -1 ? targetWordIndex : null;
      },

      getScreenRectByWordIndex(targetWordIndex) {
        let wordIndex = 0;
        for (const elem of this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')) {
          if (elem.classList.contains(this.newWordMark)) {
            continue;
          }
          if (wordIndex === targetWordIndex) {
            return elem.getBoundingClientRect();
          }
          wordIndex += 1;
        }
        return null;
      },

      getWordItemByWordIndex(targetWordIndex) {
        let wordIndex = 0;
        for (const elem of this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')) {
          if (elem.classList.contains(this.newWordMark)) {
            continue;
          }
          if (wordIndex === targetWordIndex) {
            return elem;
          }
          wordIndex += 1;
        }
        return null;
      },

      getPositionByWordIndex(targetWordIndex) {
        if (targetWordIndex == null) {
          return null;
        }
        let wordIndex = 0;
        for (const elem of this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')) {
          if (elem.classList.contains(this.newWordMark)) {
            continue;
          }
          const position = elem.offsetLeft;
          if (wordIndex === targetWordIndex) {
            return -position;
          }
          wordIndex += 1;
        }
        return null;
      },

      savePosition() {
        if (!this.constructed) {
          return;
        }
        this.updateProgressBar();
        const currentTextName = this.currentTextName;
        const lastPosition = this.currentPosition;
        const cachedContainerWidth = this.cachedContainerWidth;
        const cachedTextWidth = this.cachedTextWidth;
        const animationTimer = this.animationTimer;
        if (lastPosition !== null && (cachedContainerWidth == null || -cachedTextWidth < lastPosition && lastPosition < cachedContainerWidth)) {
          localStorage.setItem(this.settingsNames.lastPosition, lastPosition);
          if (animationTimer == null) {
            this.elements.playPauseButton.innerHTML = 'Continue';
            this.elements.playPauseButton.classList.add('pause');
          }
          else {
            this.elements.playPauseButton.innerHTML = 'Pause';
            this.elements.playPauseButton.classList.add('pause');
          }
          const wIndex = this.getFirstVisibleWordIndex();
          this.targetWordIndex = wIndex != null ? wIndex : this.targetWordIndex;
          this.textsLastPositions[currentTextName] = {
            position: lastPosition,
            wordIndex: this.targetWordIndex
          };
        } else {
          if (animationTimer == null) {
            this.elements.playPauseButton.innerHTML = 'Play <kbd>Space</kbd>';
            this.elements.playPauseButton.classList.remove('pause');
          }
          else {
            this.elements.playPauseButton.innerHTML = 'Pause';
            this.elements.playPauseButton.classList.add('pause');
          }
          localStorage.removeItem(this.settingsNames.lastPosition);
          delete this.textsLastPositions[currentTextName];
          this.targetWordIndex = null;
        }
        localStorage.setItem(this.settingsNames.textsLastPositions, JSON.stringify(this.textsLastPositions));
      },

      reloadPosition() {
        const currentTextName = this.currentTextName;
        this.cachedContainerWidth = null;
        this.currentPosition = (this.textsLastPositions[currentTextName] ?? {})['position'] || null;
        this.targetWordIndex = (this.textsLastPositions[currentTextName] ?? {})['wordIndex'] || null;
        if (this.currentPosition != null || this.targetWordIndex != null) {
          this.fromContinue = true;
        }
        this.savePosition();
      },

      updateAnimationInfoCycle() {
        this.updateProgressBar();
        const s = this.formatTime(this.infoSecondsRemaining).concat(`<br>WPM: ${this.infoWPM}`).concat(this.infoProgress ? `<br>Progress: ${(0.0 + this.infoProgress).toFixed(1)}%` : '');
        if (s !== this.elements.progressDisplay.innerHTML) {
          this.elements.progressDisplay.innerHTML = s;
        }
        if (this.database && this.currentTextName === this.defaultTextName && this.elements.textInput.value.length > this.defaultTextUpperLimit) {
          this.elements.textInput.value = this.elements.textInput.value.slice(0, this.defaultTextUpperLimit);
          setTimeout(() => alert(`The Default text cannot contain more than ${this.defaultTextUpperLimit} characters (and is originally intended for fallback in case the database is unavailable). Create a new text for a larger available size.`));
        }
        setTimeout(() => this.updateAnimationInfoCycle(), this.animationInfoUpdateDelay);
      },

      showWordHint(shuffled, original = null) {
        if (shuffled != null && !(typeof shuffled === 'string')) {
          shuffled = shuffled.textContent;
        }
        if (original != null && !(typeof original === 'string')) {
          original = original.textContent;
        }
        if (original) {
          const r = /\s\[[^\]]*?\]$/.exec(original);
          if (r) {
            shuffled += original.slice(original.length - r[0].length);
            original = original.slice(0, original.length - r[0].length);
          }
        }
        if (original) {
          alert(`${shuffled} → ${original}`);
        }
        else {
          alert(`${shuffled}`);
        }
      },

      hexToRgb(hex) {
        if (!/^#[a-f0-9]{3,6}$/i.test(hex)) return hex;
        hex = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (_, r, g, b) => r + r + g + g + b + b);
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? `rgb(${parseInt(result[1], 16)}, ${parseInt(result[2], 16)}, ${parseInt(result[3], 16)})` : hex;
      },

      handleKeyPress(event) {
        if (['INPUT', 'TEXTAREA', 'SELECT'].includes(event.target.tagName)) return;
        let preventDefault = true;
        switch (event.key) {
          case ' ': this.togglePlayback(); break;
          case 'ArrowUp': this.goToEndPosition(); break;
          case 'ArrowDown': this.goToStartPosition(); break;
          case 'ArrowLeft': this.rewind(); break;
          case 'ArrowRight': this.fastForward(); break;
          case 'l':
          case 'L': this.toggleLoop(); break;
          case 'e':
          case 'E': this.elements.colorEncoderToggle.click(); this.toggleColorEncoder(true); break;
          case 's':
          case 'S': this.stopPlayback(); break;
          case '+': this.adjustSpeed(parseInt(this.elements.speedNumber.value || 0) + 1); break;
          case '-': this.adjustSpeed(parseInt(this.elements.speedNumber.value || 0) - 1); break;
          case 'w':
          case 'W': this.refreshMarqueeWords(); break;
          case 'v':
          case 'V': this.refreshMarqueeView(); break;
          case 'Escape': this.elements.showColorInfoToggle.click(); break;
          default: preventDefault = false; break;
        }
        if (preventDefault) {
          event.preventDefault();
        }
      },

      updateProgressBar(updateSearchMarks = false) {
        const currentReader = this;
        const containerWidth = this.cachedContainerWidth;
        if (updateSearchMarks) {
          const searchMarks = this.elements.progressBarContainer.querySelectorAll('.search-mark');
          searchMarks.forEach(mark => mark.remove());
        }
        if (this.currentPosition !== null && containerWidth != null && this.realText) {
          const progress = this.getProgressByPosition();
          this.elements.progressBar.style.width = `${progress}%`;
          if (updateSearchMarks && this.searchMatches.length > 0) {
            this.searchMatches.forEach((match, index) => {
              const matchProgress = this.getProgressByPosition(match.position);
              const mark = document.createElement('div');
              mark.className = `search-mark ${index === currentReader.currentMatchIndex ? 'active' : ''}`;
              mark.style.left = `${matchProgress}%`;
              mark.addEventListener('click', (event) => {
                event.stopPropagation();
                currentReader.goToMatch(index);
              });
              currentReader.elements.progressBarContainer.appendChild(mark);
            });
          }
        } else {
          this.elements.progressBar.style.width = '0%';
        }
      },

      handleProgressBarClick(event) {
        const containerWidth = this.cachedContainerWidth;
        if (this.currentPosition !== null && containerWidth != null && this.realText) {
          const wasPlaying = this.animationTimer != null;
          if (wasPlaying) this.pauseAnimation();

          const rect = this.elements.progressBarContainer.getBoundingClientRect();
          const scrollbarWidth = wasPlaying ? window.innerWidth - document.documentElement.clientWidth : 0;
          const clickX = event.clientX - rect.left - Math.min(20, Math.max(0, scrollbarWidth));

          const containerWidth = this.cachedContainerWidth;
          const textWidth = this.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;

          const progress = (this.elements.progressBarContainer.style.direction === 'rtl' ? rect.width - clickX : clickX) / rect.width;
          this.currentPosition = this.getPositionByProgress(progress * 100);
          this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
          this.savePosition();

          if (wasPlaying) this.startAnimation(true);
        }
      },

      switchSettingsProfile(callback = null) {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentSettingsProfileName;
        if (!currentReader.database) {
          currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
          return;
        }
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and switch settings profile?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        currentReader.pauseAnimation();
        const selectedSettingsProfileName = currentReader.elements.settingsProfileSelect.value;
        if (selectedSettingsProfileName === currentReader.defaultSettingsProfileName) {
          currentReader.setSettingsProfile(JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfile) || '{}'));
          currentReader.currentSettingsProfileName = selectedSettingsProfileName;
          localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
          currentReader.settingsProfileIsModified = false;
          currentReader.forceNewHistoryItem = true;
          if (callback) {
            return callback();
          }
        } else {
          const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readonly');
          const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
          const request = objectStore.get(selectedSettingsProfileName);
          request.onsuccess = () => {
            const data = request.result;
            currentReader.setSettingsProfile(JSON.parse(data && data.settings ? data.settings : '{}'));
            currentReader.currentSettingsProfileName = selectedSettingsProfileName;
            localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
            currentReader.settingsProfileIsModified = false;
            currentReader.forceNewHistoryItem = true;
            if (callback) {
              return callback();
            }
          };
          request.onerror = () => {
            currentReader.currentSettingsProfileName = currentReader.defaultSettingsProfileName;
            localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
            currentReader.locationReload();
          };
        }
      },

      switchText(callback = null) {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (!currentReader.database) {
          currentReader.elements.textSelect.value = currentTextName;
          return;
        }
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and switch the text?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        currentReader.stopPlayback(true);
        const selectedTextName = currentReader.elements.textSelect.value;
        if (selectedTextName === currentReader.defaultTextName) {
          currentReader.currentTextBookmarks = JSON.parse(localStorage.getItem(currentReader.settingsNames.textBookmarks) || '[]');
          currentReader.elements.textInput.value = localStorage.getItem(currentReader.settingsNames.text) || '';
          currentReader.currentTextName = selectedTextName;
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
          currentReader.textIsModified = false;
          currentReader.reloadPosition();
          currentReader.forceNewHistoryItem = true;
          if (callback) {
            return callback();
          }
        } else {
          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readonly');
          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
          const request = objectStore.get(selectedTextName);
          request.onsuccess = () => {
            const data = request.result;
            currentReader.currentTextBookmarks = data && data.bookmarks ? JSON.parse(data.bookmarks) : [];
            currentReader.elements.textInput.value = data && data.content ? data.content : '';
            currentReader.currentTextName = selectedTextName;
            localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
            currentReader.textIsModified = false;
            currentReader.reloadPosition();
            currentReader.forceNewHistoryItem = true;
            if (callback) {
              return callback();
            }
          };
          request.onerror = () => {
            currentReader.currentTextName = currentReader.defaultTextName;
            localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
            currentReader.locationReload();
          };
        }
      },

      createNewSettingsProfile(settingsProfile = null) {
        const currentReader = this;
        const currentSettingsProfileName = currentReader.currentSettingsProfileName;
        if (!settingsProfile) {
          settingsProfile = currentReader.getDefaultSettingsProfile();
        }
        const newSettingsProfile = JSON.stringify(settingsProfile);
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and create a new settings profile?')) {
            currentReader.elements.settingsProfileSelect.value = currentSettingsProfileName;
            return;
          }
        }
        let name;
        do {
          name = prompt('Enter a unique name for the new settings profile:');
          if (!name) return;
          const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
          if (settingsProfiles.includes(name) || name === currentReader.defaultSettingsProfileName) {
            alert('This settings profile name already exists. Choose another one.');
            name = null;
          }
        } while (!name);
        currentReader.pauseAnimation();
        const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
        settingsProfiles.push(name);
        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
        objectStore.add({ name: name, settings: newSettingsProfile });
        transaction.oncomplete = () => {
          localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          currentReader.elements.settingsProfileSelect.appendChild(option);
          currentReader.elements.settingsProfileSelect.value = name;
          currentReader.settingsProfileIsModified = false;
          currentReader.switchSettingsProfile();
        };
        transaction.onabort = () => {
          console.error(transaction.error);
          alert(transaction.error);
        };
      },

      duplicateSettingsProfile() {
        this.createNewSettingsProfile(this.getCurrentSettingsProfile());
      },

      createNewText(defaultContent = '', defaultBookmarks = []) {
        const currentReader = this;
        const currentTextName = currentReader.currentTextName;
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and create a new text?')) {
            currentReader.elements.textSelect.value = currentTextName;
            return;
          }
        }
        let name;
        do {
          name = prompt('Enter a unique name for the new text:');
          if (!name) return;
          const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          if (texts.includes(name) || name === this.defaultTextName) {
            alert('This text name already exists. Choose another one.');
            name = null;
          }
        } while (!name);
        currentReader.stopPlayback(true);
        const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
        texts.push(name);
        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
        const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
        objectStore.add({ title: name, content: defaultContent, bookmarks: JSON.stringify(defaultBookmarks) });
        transaction.oncomplete = () => {
          localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
          const option = document.createElement('option');
          option.value = name;
          option.textContent = name;
          currentReader.elements.textSelect.appendChild(option);
          currentReader.elements.textSelect.value = name;
          currentReader.textIsModified = false;
          currentReader.switchText();
        };
        transaction.onabort = () => {
          console.error(transaction.error);
          alert(transaction.error);
        };
      },

      duplicateText() {
        this.createNewText(this.elements.textInput.value, this.currentTextBookmarks);
      },

      saveCurrentSettingsProfile() {
        const currentReader = this;
        try {
          const currentSettings = JSON.stringify(currentReader.getCurrentSettingsProfile());
          if (currentReader.currentSettingsProfileName === currentReader.defaultSettingsProfileName) {
            localStorage.setItem(currentReader.settingsNames.settingsProfile, currentSettings);
            currentReader.settingsProfileIsModified = false;
          } else if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
            const request = objectStore.put({ name: currentReader.currentSettingsProfileName, settings: currentSettings });
            request.onsuccess = () => {
              currentReader.settingsProfileIsModified = false;
            };
          }
          localStorage.setItem(currentReader.settingsNames.currentSettingsProfile, currentReader.currentSettingsProfileName);
        }
        catch (err) {
          console.error(err);
          alert(err);
        }
      },

      saveCurrentText() {
        const currentReader = this;
        try {
          if (currentReader.currentTextName === currentReader.defaultTextName) {
            currentReader.elements.textInput.value = currentReader.elements.textInput.value.slice(0, currentReader.defaultTextUpperLimit);
            localStorage.setItem(currentReader.settingsNames.text, currentReader.elements.textInput.value);
            localStorage.setItem(currentReader.settingsNames.textBookmarks, JSON.stringify(currentReader.currentTextBookmarks));
            currentReader.textIsModified = false;
          } else if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
            const request = objectStore.put({
              title: currentReader.currentTextName,
              content: currentReader.elements.textInput.value,
              bookmarks: JSON.stringify(currentReader.currentTextBookmarks),
            });
            request.onsuccess = () => {
              currentReader.textIsModified = false;
            };
          }
          localStorage.setItem(currentReader.settingsNames.currentTextName, currentReader.currentTextName);
        }
        catch (err) {
          console.error(err);
          alert(err);
        }
      },

      resetCurrentSettingsProfile() {
        this.setSettingsProfile(this.getDefaultSettingsProfile());
        this.settingsProfileIsModified = true;
      },

      deleteCurrentSettingsProfile() {
        const currentReader = this;
        if (currentReader.currentSettingsProfileName === currentReader.defaultSettingsProfileName) {
          alert(`Cannot delete the "${currentReader.defaultSettingsProfileName}" settings profile`);
          return;
        }
        if (confirm(`Are you sure you want to delete the settings profile "${currentReader.currentSettingsProfileName}"?`)) {
          currentReader.pauseAnimation();
          const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
          const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
          objectStore.delete(currentReader.currentSettingsProfileName);
          transaction.oncomplete = () => {
            let settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
            settingsProfiles = settingsProfiles.filter(profileName => profileName !== currentReader.currentSettingsProfileName);
            localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
            const option = currentReader.elements.settingsProfileSelect.querySelector(`option[value="${currentReader.currentSettingsProfileName}"]`);
            if (option) option.remove();
            currentReader.elements.settingsProfileSelect.value = currentReader.defaultSettingsProfileName;
            currentReader.settingsProfileIsModified = false;
            currentReader.switchSettingsProfile();
          };
          transaction.onabort = () => {
            console.error(transaction.error);
            alert(transaction.error);
          };
        }
      },

      deleteCurrentText() {
        const currentReader = this;
        if (currentReader.currentTextName === currentReader.defaultTextName) {
          alert(`Cannot delete the "${currentReader.defaultTextName}" text`);
          return;
        }
        if (confirm(`Are you sure you want to delete the text "${currentReader.currentTextName}"? This action will also remove all associated bookmarks.`)) {
          currentReader.stopPlayback(true);
          const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
          const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
          objectStore.delete(currentReader.currentTextName);
          transaction.oncomplete = () => {
            let texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
            texts = texts.filter(text => text !== currentReader.currentTextName);
            localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
            const option = currentReader.elements.textSelect.querySelector(`option[value="${currentReader.currentTextName}"]`);
            if (option) option.remove();
            delete currentReader.textsLastPositions[currentReader.currentTextName];
            currentReader.currentTextName = currentReader.defaultTextName;
            currentReader.elements.textSelect.value = currentReader.currentTextName;
            currentReader.textIsModified = false;
            currentReader.reloadPosition();
            currentReader.switchText();
          };
          transaction.onabort = () => {
            console.error(transaction.error);
            alert(transaction.error);
          };
        }
      },

      deleteAllSettingsProfiles(callback = null) {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all settings profiles?')) {
          if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
            const request = objectStore.clear();
            transaction.oncomplete = () => {
              localStorage.removeItem(currentReader.settingsNames.settingsProfile);
              localStorage.removeItem(currentReader.settingsNames.settingsProfiles);
              if (callback) {
                return callback();
              }
              currentReader.locationReload();
            };
            transaction.onabort = () => {
              console.error(transaction.error);
              alert(transaction.error);
            };
          }
          else {
            localStorage.removeItem(currentReader.settingsNames.settingsProfile);
            if (callback) {
              return callback();
            }
            currentReader.locationReload();
          }
        }
        else {
          currentReader.deleteAllDataViewCounter += 1;
          if (currentReader.deleteAllDataViewCounter >= currentReader.deleteAllDataViewMax) {
            currentReader.elements.deleteAllData.style.display = '';
          }
        }
      },

      deleteAllTexts(callback = null) {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all texts? This action will also remove all bookmarks.')) {
          if (currentReader.database) {
            const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite');
            const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
            const request = objectStore.clear();
            transaction.oncomplete = () => {
              currentReader.currentPosition = null;
              localStorage.removeItem(currentReader.settingsNames.lastPosition);
              currentReader.textsLastPositions = {};
              currentReader.savePosition();
              localStorage.removeItem(currentReader.settingsNames.text);
              localStorage.removeItem(currentReader.settingsNames.texts);
              localStorage.removeItem(currentReader.settingsNames.textBookmarks);
              if (callback) {
                return callback();
              }
              currentReader.locationReload();
            };
            transaction.onabort = () => {
              console.error(transaction.error);
              alert(transaction.error);
            };
          }
          else {
            currentReader.currentPosition = null;
            localStorage.removeItem(currentReader.settingsNames.lastPosition);
            currentReader.textsLastPositions = {};
            currentReader.savePosition();
            localStorage.removeItem(currentReader.settingsNames.text);
            localStorage.removeItem(currentReader.settingsNames.textBookmarks);
            if (callback) {
              return callback();
            }
            currentReader.locationReload();
          }
        }
        else {
          currentReader.deleteAllDataViewCounter += 1;
          if (currentReader.deleteAllDataViewCounter >= currentReader.deleteAllDataViewMax) {
            currentReader.elements.deleteAllData.style.display = '';
          }
        }
      },

      deleteHistory(callback = null) {
        const currentReader = this;
        if (currentReader.database && confirm('Are you sure you want to delete the history?')) {
          this.history = [];
          this.saveHistory(() => {
            if (callback) {
              return callback();
            }
            currentReader.locationReload();
          });
        }
      },

      deleteAllData(callback = null) {
        const currentReader = this;
        if (confirm('Are you sure you want to delete all data? This action will also remove all texts and non-profile settings.')) {
          if (currentReader.database) {
            currentReader.database.close();
            const request = indexedDB.deleteDatabase(currentReader.databaseName);
            request.onsuccess = () => {
              currentReader.currentPosition = null;
              localStorage.removeItem(currentReader.settingsNames.lastPosition);
              currentReader.textsLastPositions = {};
              currentReader.savePosition();
              for (const settingName of Object.values(currentReader.settingsNames)) {
                localStorage.removeItem(settingName);
              }
              if (callback) {
                return callback();
              }
              currentReader.locationReload();
            };
            request.onerror = (event) => {
              console.error(event.target.error);
              alert(event.target.error);
            };
            request.onblocked = (event) => {
              console.error(event.type);
              alert(event.type);
            };
          }
          else {
            currentReader.currentPosition = null;
            localStorage.removeItem(currentReader.settingsNames.lastPosition);
            currentReader.textsLastPositions = {};
            currentReader.savePosition();
            for (const settingName of Object.values(currentReader.settingsNames)) {
              localStorage.removeItem(settingName);
            }
            if (callback) {
              return callback();
            }
            currentReader.locationReload();
          }
        }
      },

      importAllSettingsProfilesAux(data, callback = null) {
        const currentReader = this;
        try {
          const jsonParsed = JSON.parse(data), newSettingsProfiles = [];
          for (const jsonObject of (jsonParsed[currentReader.settingsNames.settingsProfiles] || [])) {
            const name = jsonObject['name'], settings = JSON.stringify(jsonObject['settings']);
            if (name && settings) {
              newSettingsProfiles.push({
                'name': name,
                'settings': settings
              });
            }
          }
          const settingsProfiles = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfiles) || '[]');
          if (newSettingsProfiles.length > 0) {
            currentReader.pauseAnimation();
            const currentReplacement = currentReader.getImportReplacement();
            const addAsNew = currentReplacement === currentReader.importDataReplacementVariants.addAsNew;
            const appendOnly = currentReplacement === currentReader.importDataReplacementVariants.appendOnly;
            const replaceIfProvided = currentReplacement === currentReader.importDataReplacementVariants.replaceIfProvided;
            const transaction = currentReader.database ? currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readwrite') : null;
            const objectStore = currentReader.database ? transaction.objectStore(currentReader.settingsNames.settingsProfiles) : null;
            for (const newSettingsProfile of newSettingsProfiles) {
              let name = newSettingsProfile['name'];
              const settings = newSettingsProfile['settings'];
              if (addAsNew) {
                name = currentReader.getNextName(name, [...settingsProfiles, currentReader.defaultSettingsProfileName]);
              }
              else if (!appendOnly && !replaceIfProvided) {
                continue;
              }
              if (name === currentReader.defaultSettingsProfileName) {
                if (replaceIfProvided) {
                  localStorage.setItem(currentReader.settingsNames.settingsProfile, settings);
                }
              }
              else if (currentReader.database) {
                const included = settingsProfiles.includes(name);
                if (!included) {
                  settingsProfiles.push(name);
                }
                const data = { name: name, settings: settings };
                if (replaceIfProvided) {
                  objectStore.put(data);
                }
                else if (!included) {
                  objectStore.add(data);
                }
              }
            }
            if (currentReader.database) {
              transaction.oncomplete = () => {
                localStorage.setItem(currentReader.settingsNames.settingsProfiles, JSON.stringify(settingsProfiles));
                if (callback) {
                  return callback(jsonParsed);
                }
                currentReader.locationReload();
              };
              transaction.onabort = () => {
                console.error(transaction.error);
                alert(transaction.error);
              };
            }
            else {
              if (callback) {
                return callback(jsonParsed);
              }
              currentReader.locationReload();
            }
          }
          else {
            if (callback) {
              return callback(jsonParsed);
            }
            alert('No settings profiles found in the file');
          }
        }
        catch (err) {
          console.error(err);
          alert(`Error importing settings profiles: ${err}`);
        }
      },

      importAllSettingsProfiles(callback = null) {
        const currentReader = this;
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new settings profiles?')) {
            return;
          }
        }
        const element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            const f = event.target.files[0];
            if (f) {
              const r = new FileReader;
              r.addEventListener("load", (function (event) {
                return currentReader.importAllSettingsProfilesAux(event.target.result, callback);
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality is not supported by your browser")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAllTextsAux(data, callback = null) {
        const currentReader = this;
        try {
          const jsonParsed = JSON.parse(data), newTexts = [];
          for (const jsonObject of (jsonParsed[currentReader.settingsNames.texts] || [])) {
            const title = jsonObject['title'], content = jsonObject['content'], bookmarks = jsonObject['bookmarks'];
            if (title && content) {
              newTexts.push({
                'title': title,
                'content': content,
                'bookmarks': JSON.stringify(bookmarks || [])
              });
            }
          }
          const texts = JSON.parse(localStorage.getItem(currentReader.settingsNames.texts) || '[]');
          if (newTexts.length > 0) {
            currentReader.stopPlayback(true);
            const currentReplacement = currentReader.getImportReplacement();
            const addAsNew = currentReplacement === currentReader.importDataReplacementVariants.addAsNew;
            const appendOnly = currentReplacement === currentReader.importDataReplacementVariants.appendOnly;
            const replaceIfProvided = currentReplacement === currentReader.importDataReplacementVariants.replaceIfProvided;
            const transaction = currentReader.database ? currentReader.database.transaction([currentReader.settingsNames.texts], 'readwrite') : null;
            const objectStore = currentReader.database ? transaction.objectStore(currentReader.settingsNames.texts) : null;
            for (const newText of newTexts) {
              let title = newText['title'];
              const content = newText['content'];
              const bookmarks = newText['bookmarks'];
              if (addAsNew) {
                title = currentReader.getNextName(title, [...texts, currentReader.defaultTextName]);
              }
              else if (!appendOnly && !replaceIfProvided) {
                continue;
              }
              if (title === currentReader.defaultTextName) {
                if (replaceIfProvided) {
                  localStorage.setItem(currentReader.settingsNames.text, content);
                  localStorage.setItem(currentReader.settingsNames.textBookmarks, bookmarks);
                  delete currentReader.textsLastPositions[currentReader.currentTextName];
                  if (currentReader.currentTextName === currentReader.defaultTextName) {
                    currentReader.currentPosition = null;
                    localStorage.removeItem(currentReader.settingsNames.lastPosition);
                  }
                  currentReader.savePosition();
                }
              }
              else if (currentReader.database) {
                const included = texts.includes(title);
                if (!included) {
                  texts.push(title);
                }
                const data = {
                  title: title,
                  content: content,
                  bookmarks: bookmarks,
                };
                let changed = false;
                if (replaceIfProvided) {
                  objectStore.put(data);
                  changed = true;
                }
                else if (!included) {
                  objectStore.add(data);
                  changed = true;
                }
                if (changed) {
                  delete currentReader.textsLastPositions[title];
                }
                if (changed && currentReader.currentTextName === title) {
                  currentReader.currentPosition = null;
                  localStorage.removeItem(currentReader.settingsNames.lastPosition);
                }
                currentReader.savePosition();
              }
            }
            if (currentReader.database) {
              transaction.oncomplete = () => {
                localStorage.setItem(currentReader.settingsNames.texts, JSON.stringify(texts));
                if (callback) {
                  return callback(jsonParsed);
                }
                currentReader.locationReload();
              };
              transaction.onabort = () => {
                console.error(transaction.error);
                alert(transaction.error);
              };
            }
            else {
              if (callback) {
                return callback(jsonParsed);
              }
              currentReader.locationReload();
            }
          }
          else {
            if (callback) {
              return callback(jsonParsed);
            }
            alert('No texts found in the file');
          }
        }
        catch (err) {
          console.error(err);
          alert(`Error importing texts: ${err}`);
        }
      },

      importHistoryAux(data, callback = null) {
        const currentReader = this;
        try {
          const jsonParsed = (typeof data === 'string' ? JSON.parse(data) : data), newHistoryItems = [];
          for (const jsonObject of (jsonParsed[currentReader.settingsNames.history] || [])) {
            if (jsonObject) {
              newHistoryItems.push(jsonObject);
            }
          }
          const historyItems = this.history;
          if (newHistoryItems.length > 0) {
            const currentReplacement = currentReader.getImportReplacement();
            const addAsNew = currentReplacement === currentReader.importDataReplacementVariants.addAsNew;
            const appendOnly = currentReplacement === currentReader.importDataReplacementVariants.appendOnly;
            const replaceIfProvided = currentReplacement === currentReader.importDataReplacementVariants.replaceIfProvided;
            const newHistory = [];
            for (const newHistoryItem of newHistoryItems) {
              let found = false;
              for (const historyItem of this.history) {
                if (newHistoryItem.timestamp === historyItem.timestamp) {
                  if (addAsNew) {
                    newHistory.push(historyItem);
                    break;
                  }
                  if (appendOnly) {
                    found = true;
                    break;
                  }
                  if (replaceIfProvided) {
                    break;
                  }
                  break;
                }
              }
              if (!found) {
                newHistory.push(newHistoryItem);
              }
            }
            this.history = newHistory.sort((a, b) => b.timestamp - a.timestamp);
            this.saveHistory();
            if (callback) {
              return callback(jsonParsed);
            }
            this.locationReload();
          }
          else {
            if (callback) {
              return callback(jsonParsed);
            }
            alert('No history found in the file');
          }
        }
        catch (err) {
          console.error(err);
          alert(`Error importing history: ${err}`);
        }
      },

      importAllTexts(callback = null) {
        const currentReader = this;
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new texts?')) {
            return;
          }
        }
        const element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            const f = event.target.files[0];
            if (f) {
              const r = new FileReader;
              r.addEventListener("load", (function (event) {
                return currentReader.importAllTextsAux(event.target.result, callback);
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality is not supported by your browser")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAllSettingsProfilesAndTexts(afterSuccessCallback = null) {
        const currentReader = this;
        if (currentReader.settingsProfileIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new settings profiles?')) {
            return;
          }
        }
        if (currentReader.textIsModified) {
          if (!confirm('You have unsaved changes. Are you sure you want to discard the changes and import new texts?')) {
            return;
          }
        }
        const element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            const f = event.target.files[0];
            if (f) {
              const r = new FileReader;
              r.addEventListener("load", (function (event) {
                currentReader.importAllSettingsProfilesAux(event.target.result, (jsonParsed1) => {
                  currentReader.importAllTextsAux(event.target.result, (jsonParsed2) => {
                    if (afterSuccessCallback) {
                      return afterSuccessCallback(jsonParsed2);
                    }
                    currentReader.locationReload();
                  });
                });
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality is not supported by your browser")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importHistory(afterSuccessCallback = null) {
        const currentReader = this;
        const element = document.createElement('input');
        element.id = 'file_upload';
        element.type = 'file';
        element.onchange = function (event) {
          if (window.File && window.FileReader && window.FileList && window.Blob) {
            const f = event.target.files[0];
            if (f) {
              const r = new FileReader;
              r.addEventListener("load", (function (event) {
                currentReader.importHistoryAux(event.target.result, (jsonParsed) => {
                  if (afterSuccessCallback) {
                    return afterSuccessCallback(jsonParsed);
                  }
                  currentReader.locationReload();
                });
              }));
              r.readAsText(f);
            }
          } else {
            alert("This functionality is not supported by your browser")
          }
        }
        document.body.appendChild(element);
        element.click();
        document.body.removeChild(element);
      },

      importAll() {
        const currentReader = this;
        const currentReplacement = currentReader.getImportReplacement();
        const addAsNew = currentReplacement === currentReader.importDataReplacementVariants.addAsNew;
        const appendOnly = currentReplacement === currentReader.importDataReplacementVariants.appendOnly;
        const replaceIfProvided = currentReplacement === currentReader.importDataReplacementVariants.replaceIfProvided;
        currentReader.importAllSettingsProfilesAndTexts((jsonParsed1) => {
          currentReader.importHistoryAux(jsonParsed1, (jsonParsed2) => {
              for (const [k, v] of Object.entries(jsonParsed2)) {
                if (k == null || v == null) {
                  continue;
                }
                if (
                  k !== currentReader.settingsNames.history &&
                  k !== currentReader.settingsNames.textBookmarks &&
                  k !== currentReader.settingsNames.texts &&
                  k !== currentReader.settingsNames.text &&
                  k !== currentReader.settingsNames.settingsProfiles &&
                  k !== currentReader.settingsNames.settingsProfile
                ) {
                  const included = (localStorage.getItem(k) || null) == null;
                  if (replaceIfProvided || !included && (addAsNew || appendOnly)) {
                    localStorage.setItem(k, v);
                  }
                }
            }
            currentReader.locationReload();
          });
        });
      },

      exportAllSettingsProfiles(callback = null) {
        const currentReader = this;
        const defaultSettingsProfile = JSON.parse(localStorage.getItem(currentReader.settingsNames.settingsProfile) || '{}');
        const settingsProfilesKey = currentReader.settingsNames.settingsProfiles;
        const exportData = {};
        exportData[settingsProfilesKey] = [];
        exportData[settingsProfilesKey].push({
          name: currentReader.defaultSettingsProfileName,
          settings: defaultSettingsProfile
        });
        if (!currentReader.database) {
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData);
          return;
        }
        const transaction = currentReader.database.transaction([currentReader.settingsNames.settingsProfiles], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.settingsProfiles);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const profiles = request.result;
          profiles.forEach(profile => {
            exportData[settingsProfilesKey].push({
              name: profile.name,
              settings: JSON.parse(profile.settings)
            });
          });
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData, 'settings_profiles');
        };
        request.onerror = (event) => {
          const message = `Error exporting settings profiles: ${event.target.error}`;
          console.error(event.target.error);
          alert(message);
        };
      },

      exportAllTexts(callback = null) {
        const currentReader = this;
        const defaultText = localStorage.getItem(currentReader.settingsNames.text) || '';
        const defaultTextBookmarks = JSON.parse(localStorage.getItem(currentReader.settingsNames.textBookmarks) || '[]');
        const textsKey = currentReader.settingsNames.texts;
        const exportData = {};
        exportData[textsKey] = [];
        exportData[textsKey].push({
          title: currentReader.defaultTextName,
          content: defaultText,
          bookmarks: currentReader.elements.exportAllTextsWithBookmarksToggle.checked ? defaultTextBookmarks : []
        });
        if (!currentReader.database) {
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData);
          return;
        }
        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.texts);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          const texts = request.result;
          texts.forEach(text => {
            exportData[textsKey].push({
              title: text.title,
              content: text.content,
              bookmarks: currentReader.elements.exportAllTextsWithBookmarksToggle.checked ? JSON.parse(text.bookmarks || '[]') : [],
            });
          });
          if (callback) {
            return callback(exportData);
          }
          currentReader.downloadExportFile(exportData, 'texts');
        };
        request.onerror = () => {
          const message = `Error exporting texts: ${event.target.error}`;
          console.error(event.target.error);
          alert(message);
        };
      },

      exportHistory(callback = null) {
        const currentReader = this;
        const historyKey = currentReader.settingsNames.history;
        const exportData = {};
        exportData[historyKey] = this.history;
        if (callback) {
          return callback(exportData);
        }
        currentReader.downloadExportFile(exportData, 'history');
      },

      exportAllSettingsProfilesAndTexts(afterSuccessCallback = null) {
        const currentReader = this;
        currentReader.exportAllSettingsProfiles((exportData1) => {
          return currentReader.exportAllTexts((exportData2) => {
            const name = 'settings_profiles_and_texts';
            const exportData = {
              ...exportData1,
              ...exportData2,
            };
            const newName = afterSuccessCallback ? afterSuccessCallback(exportData) : '';
            currentReader.downloadExportFile(exportData, newName ? newName : name);
          });
        });
      },

      exportAll() {
        const currentReader = this;
        return currentReader.exportHistory((exportData1) => {
          return currentReader.exportAllSettingsProfilesAndTexts((exportData) => {
            if (currentReader.elements.exportHistoryToggle.checked) {
              for (const [key, value] of Object.entries(exportData1)) {
                exportData[key] = value;
              }
            }
            for (const localStorageSettingName of Object.values(currentReader.settingsNames)) {
              const localStorageSettingValue = localStorage.getItem(localStorageSettingName);
              if (localStorageSettingValue == null) {
                continue;
              }
              if (
                localStorageSettingName !== currentReader.settingsNames.history &&
                localStorageSettingName !== currentReader.settingsNames.textBookmarks &&
                localStorageSettingName !== currentReader.settingsNames.texts &&
                localStorageSettingName !== currentReader.settingsNames.text &&
                localStorageSettingName !== currentReader.settingsNames.settingsProfiles &&
                localStorageSettingName !== currentReader.settingsNames.settingsProfile
              ) {
                exportData[localStorageSettingName] = localStorageSettingValue;
              }
            }
            return 'all';
          });
        });
      },

      getStrDateTime(timestamp = null) {
        let datetimeValue = null;
        if (timestamp != null) {
          datetimeValue = new Date((new Date(timestamp).setHours(new Date(timestamp).getHours() - (new Date().getTimezoneOffset() / 60))));
        }
        if (datetimeValue == null) {
          datetimeValue = new Date((new Date().setHours(new Date().getHours() - (new Date().getTimezoneOffset() / 60))));
        }
        return datetimeValue.toISOString().replace('T', ' ').replaceAll('-', '.').slice(0, 19);
      },

      downloadExportFile(data, dataInfoTag) {
        try {
          const jsonString = JSON.stringify(data, null, 2);
          const blob = new Blob([jsonString], { type: 'application/json' });
          const reader = new FileReader();

          reader.onloadend = () => {
            const base64data = reader.result.split(',')[1];
            const datetimeString = this.getStrDateTime().replaceAll(':', '.').replaceAll(' ', '_');
            const fileName = `reading_${dataInfoTag}_${datetimeString}.json`;

            if (window.Android) {
              window.Android.startDownload(fileName, base64data, 'application/json');
            } else {
              const url = window.URL.createObjectURL(blob);
              const link = document.createElement('a');
              link.href = url;
              link.download = fileName;
              document.body.appendChild(link);
              link.click();
              setTimeout(() => {
                document.body.removeChild(link);
                window.URL.revokeObjectURL(url);
              }, 0);
            }
          };
          reader.readAsDataURL(blob);
        } catch (e) {
          console.error("Download error: ", e);
        }
      },

      locationReload() {
        this.settingsProfileIsModified = false;
        this.textIsModified = false;
        setTimeout(function () {
          location.reload();
        }, 1);
      },

      adjustSpeechRate(value) {
        this.speechRate = parseFloat(value || 100);
        this.elements.speechRateSlider.value = value;
        this.elements.speechRateNumber.value = value;
        localStorage.setItem(this.settingsNames.voiceSpeechRate, this.speechRate);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      adjustSpeechPitch(value) {
        this.speechPitch = parseFloat(value || 100);
        this.elements.speechPitchSlider.value = value;
        this.elements.speechPitchNumber.value = value;
        localStorage.setItem(this.settingsNames.voiceSpeechPitch, this.speechPitch);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      adjustSpeechVolume(value) {
        this.speechVolume = parseFloat(value || 100);
        this.elements.speechVolumeSlider.value = value;
        this.elements.speechVolumeNumber.value = value;
        localStorage.setItem(this.settingsNames.voiceSpeechVolume, this.speechVolume);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      loadVoices() {
        if (!this.speechSynthesis) {
          return;
        }
        const updateVoices = () => {
          this.voices = this.speechSynthesis.getVoices();
          this.elements.voiceSelect.innerHTML = this.voices.map((voice, index) =>
            `<option value="${index}">[${voice.lang}] ${voice.name}</option>`
          ).join('');
        };
        this.speechSynthesis.onvoiceschanged = updateVoices;
        updateVoices();
      },

      updateVoice() {
        localStorage.setItem(this.settingsNames.voice, this.elements.voiceSelect.value);
        if (this.isSpeaking) {
          this.toggleSpeech();
        }
      },

      toggleSpeechButton() {
        this.elements.textToSpeechContainer.style.display = this.elements.showSpeakButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.voiceButton, this.elements.showSpeakButtonToggle.checked);
      },

      toggleSearchButton() {
        this.elements.searchContainer.style.display = this.elements.showSearchButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.searchButton, this.elements.showSearchButtonToggle.checked);
      },

      toggleBookmarksButton() {
        this.elements.bookmarksContainer.style.display = this.elements.showBookmarksButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.bookmarksButton, this.elements.showBookmarksButtonToggle.checked);
      },

      toggleTextViewButton() {
        this.elements.textViewContainer.style.display = this.elements.showTextViewButtonToggle.checked ? '' : 'none';
        localStorage.setItem(this.settingsNames.textViewButton, this.elements.showTextViewButtonToggle.checked);
      },

      toggleHistoryEnable() {
        this.historyStatus = this.elements.historyEnableToggle.checked;
        localStorage.setItem(this.settingsNames.historyStatus, this.historyStatus);
      },

      toggleSpeech() {
        if (!this.speechSynthesis) return;

        const currentReader = this;

        const startUpdate = function () {
          currentReader.isSpeaking = true;
          currentReader.elements.speakButton.textContent = 'Stop';
          currentReader.elements.playPauseButton.disabled = true;
          currentReader.elements.stopButton.disabled = true;
          currentReader.elements.rewindButton.disabled = true;
          currentReader.elements.fastForwardButton.disabled = true;
          currentReader.elements.refreshSentences.disabled = true;
          currentReader.elements.refreshWords.disabled = true;
          currentReader.elements.refreshView.disabled = true;
          currentReader.elements.refreshColors.disabled = true;
          currentReader.elements.copyMarqueeText.disabled = true;
          currentReader.elements.searchButton.style.display = 'none';
          currentReader.elements.bookmarksButton.style.display = 'none';
          currentReader.elements.textViewButton.style.display = 'none';
          currentReader.elements.controlsContainerFooter.style.display = '';
          currentReader.elements.loopToggle.style.display = 'none';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = 'none';
          currentReader.elements.tabContent.style.display = 'none';
          currentReader.animationStartTime = Date.now();
          currentReader.isSpeaking = true;
          currentReader.savePosition();
          currentReader.startProgress = currentReader.getProgressByPosition();
          currentReader.endProgress = currentReader.startProgress;
          currentReader.amendHistoryItem();
          currentReader.wasStarted = true;
        };

        const stopUpdate = function () {
          currentReader.speechSynthesis.cancel();
          currentReader.elements.speakButton.textContent = 'Speak';
          currentReader.elements.playPauseButton.disabled = false;
          currentReader.elements.stopButton.disabled = false;
          currentReader.elements.rewindButton.disabled = false;
          currentReader.elements.fastForwardButton.disabled = false;
          currentReader.elements.refreshSentences.disabled = false;
          currentReader.elements.refreshWords.disabled = false;
          currentReader.elements.refreshView.disabled = false;
          currentReader.elements.refreshColors.disabled = false;
          currentReader.elements.copyMarqueeText.disabled = false;
          currentReader.elements.searchButton.style.display = '';
          currentReader.elements.bookmarksButton.style.display = '';
          currentReader.elements.textViewButton.style.display = '';
          currentReader.elements.controlsContainerFooter.style.display = '';
          currentReader.elements.loopToggle.style.display = '';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = '';
          currentReader.elements.tabContent.style.display = '';
          const speakMarks = currentReader.elements.progressBarContainer.querySelectorAll('.speak-mark');
          speakMarks.forEach(mark => mark.remove());
          currentReader.savePosition();
          currentReader.endProgress = currentReader.getProgressByPosition();
          currentReader.amendHistoryItem();
          currentReader.isSpeaking = false;
          currentReader.wasStarted = false;
          currentReader.currentWordIndexToSpeech = 0;
        };

        if (this.isSpeaking) {
          stopUpdate();
          return;
        }

        this.startAnimation(false, false);
        if (!this.realText1List.length || !this.realText2List.length) {
          return;
        }
        const words = (this.elements.fasterTransitionsToggle.checked ? this.realText1List.map(v => v.replaceAll('.', ';')) : this.realText1List);

        this.updateCachedSizes();
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const shift = containerWidth * Math.max(0, Math.min(0.5, containerWidth / 100 - 5));
        const containerRect = this.elements.marqueeContainer.getBoundingClientRect();

        let startSpanIndex = 0;
        const spans = Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')).filter(x => !x.classList.contains(this.newWordMark));
        if (this.currentPosition !== null) {
          for (let i = 0; i < spans.length; i++) {
            const currentSpanRect = spans[i].getBoundingClientRect();
            if (shift <= currentSpanRect.x + currentSpanRect.width - containerRect.x) {
              startSpanIndex = i;
              break;
            }
          }
        }

        if (spans.length <= startSpanIndex || spans.length !== words.length) {
          return;
        }
        const wordsFromIndex = words.slice(startSpanIndex);
        const realTextFromIndex = wordsFromIndex.join(' ');
        const wordCount = words.length - startSpanIndex;
        const utterance = new SpeechSynthesisUtterance(realTextFromIndex);
        const selectedVoiceIndex = parseInt(this.elements.voiceSelect.value || 0);
        if (this.voices[selectedVoiceIndex]) {
          utterance.voice = this.voices[selectedVoiceIndex];
        }
        utterance.rate = this.speechRate / 100;
        utterance.pitch = this.speechPitch / 100;
        utterance.volume = this.speechVolume / 100;

        const wordsPositions = wordsFromIndex.reduce((indexes, word, i) => {
            if (i === 0) {
                indexes.push(0);
            } else {
                indexes.push(indexes[i-1] + wordsFromIndex[i-1].length + 1);
            }
            return indexes;
        }, []);

        const spanPositions = spans.slice(startSpanIndex).map(span => {
          const spanRect = span.getBoundingClientRect();
          const marqueeRect = this.elements.marqueeDisplay.getBoundingClientRect();
          return -(spanRect.left - marqueeRect.left);
        });

        const mark = document.createElement('div');
        mark.className = `speak-mark`;
        mark.style.left = Math.max(0, Math.min(100, (shift * 100 / containerWidth))) + '%';
        mark.addEventListener('click', (event) => {
          event.stopPropagation();
        });
        let markAdded = false;

        const wordByWord = this.elements.speakWordByWordToggle.checked;
        const sentenceBySentence = this.elements.speakSentenceBySentenceToggle.checked;

        const updateWordUI = (wordIndex) => {
          const spanIndex = Math.min(wordIndex, spanPositions.length - 1);
          const startPos = containerWidth;
          const endPos = -textWidth;

          currentReader.currentPosition = Math.max(endPos, Math.min(startPos, spanPositions[spanIndex] + shift));
          currentReader.elements.marqueeDisplay.style.left = `${currentReader.currentPosition}px`;

          const relWordN = wordIndex + 1;
          const newLastUpdateTime = Date.now();
          const elapsedTime = (newLastUpdateTime - currentReader.animationStartTime) / 1000;
          const wordsPerSecond = elapsedTime > 1 ? relWordN / elapsedTime : relWordN / 60;
          const remainingWords = wordCount - wordIndex - 1;
          const secondsRemaining = wordsPerSecond > 0 ? (remainingWords / wordsPerSecond) : 0;

          currentReader.infoSecondsRemaining = secondsRemaining;
          currentReader.infoWPM = Math.floor(wordsPerSecond * 60);
          currentReader.infoProgress = currentReader.getProgressByPosition();

          if (!markAdded) {
            currentReader.elements.progressBarContainer.appendChild(mark);
            markAdded = true;
          }
        };

        const completeSpeech = () => {
          const isSpeaking = this.isSpeaking;
          if (isSpeaking) {
            currentReader.currentPosition = -textWidth;
            currentReader.elements.marqueeDisplay.style.left = `${currentReader.currentPosition}px`;
            currentReader.infoSecondsRemaining = 0;
            currentReader.infoWPM = Math.floor(wordCount / ((Date.now() - currentReader.animationStartTime) / 1000) * 60);
            currentReader.infoProgress = currentReader.getProgressByPosition();
          }
          if (markAdded) {
            mark.remove();
            markAdded = false;
          }
          stopUpdate();
          if (isSpeaking) {
            if (currentReader.elements.loopToggle.classList.contains('active')) {
              currentReader.currentPosition = null;
              setTimeout(() => currentReader.toggleSpeech(), 50);
            }
          }
        };

        if (sentenceBySentence) {
          const speakSentence = (wordIndex) => {
            if (wordIndex >= wordCount || !currentReader.isSpeaking) {
              completeSpeech();
              return;
            }
            let endIndex = wordIndex;
            for (let i = wordIndex; i < wordsFromIndex.length; ++i) {
              endIndex = i;
              if (wordsFromIndex[i].indexOf('!') >= 0 || wordsFromIndex[i].indexOf('?') >= 0 || wordsFromIndex[i].indexOf('.') >= 0) {
                break;
              }
            }
            const utterance = new SpeechSynthesisUtterance(wordsFromIndex.slice(wordIndex, endIndex + 1).join(' '));
            if (this.voices[selectedVoiceIndex]) {
              utterance.voice = this.voices[selectedVoiceIndex];
            }
            utterance.rate = this.speechRate / 100;
            utterance.pitch = this.speechPitch / 100;
            utterance.volume = this.speechVolume / 100;
            updateWordUI(wordIndex);
            utterance.onend = () => {
              currentReader.currentWordIndexToSpeech = endIndex + 1;
              speakSentence(currentReader.currentWordIndexToSpeech);
            };
            currentReader.speechSynthesis.speak(utterance);
          };

          currentReader.currentWordIndexToSpeech = 0;
          startUpdate();
          speakSentence(currentReader.currentWordIndexToSpeech);
        }
        else if (wordByWord) {
          const speakWord = (wordIndex) => {
            if (wordIndex >= wordCount || !currentReader.isSpeaking) {
              completeSpeech();
              return;
            }
            const utterance = new SpeechSynthesisUtterance(wordsFromIndex[wordIndex]);
            if (this.voices[selectedVoiceIndex]) {
              utterance.voice = this.voices[selectedVoiceIndex];
            }
            utterance.rate = this.speechRate / 100;
            utterance.pitch = this.speechPitch / 100;
            utterance.volume = this.speechVolume / 100;
            updateWordUI(wordIndex);
            utterance.onend = () => {
              currentReader.currentWordIndexToSpeech = wordIndex + 1;
              speakWord(currentReader.currentWordIndexToSpeech);
            };
            currentReader.speechSynthesis.speak(utterance);
          };

          currentReader.currentWordIndexToSpeech = 0;
          startUpdate();
          speakWord(currentReader.currentWordIndexToSpeech);
        } else {
          const utterance = new SpeechSynthesisUtterance(realTextFromIndex);
          if (this.voices[selectedVoiceIndex]) {
            utterance.voice = this.voices[selectedVoiceIndex];
          }
          utterance.rate = this.speechRate / 100;
          utterance.pitch = this.speechPitch / 100;
          utterance.volume = this.speechVolume / 100;

          utterance.onboundary = (event) => {
            if (event.name === 'word') {
              const wordIndex = wordsPositions.findIndex((v) => v > event.charIndex) - 1;
              updateWordUI(wordIndex);
            }
          };

          utterance.onend = () => {
            completeSpeech();
          };

          startUpdate();
          this.speechSynthesis.speak(utterance);
        }
      },

      toggleSearch() {
        const currentReader = this;

        if (this.animationTimer != null || this.isSpeaking) {
          alert('Stop animation or speech first');
          return;
        }

        this.startAnimation(false, false);
        if (!this.realText2List.length) {
          return;
        }

        this.isSearchActive = !this.isSearchActive;
        this.elements.searchButton.textContent = this.isSearchActive ? 'Close' : 'Search';
        this.elements.searchControls.style.display = this.isSearchActive ? 'block' : 'none';

        if (this.isSearchActive) {
          currentReader.elements.playPauseButton.disabled = true;
          currentReader.elements.stopButton.disabled = true;
          currentReader.elements.rewindButton.disabled = false;
          currentReader.elements.fastForwardButton.disabled = false;
          currentReader.elements.refreshSentences.disabled = true;
          currentReader.elements.refreshWords.disabled = true;
          currentReader.elements.refreshView.disabled = true;
          currentReader.elements.refreshColors.disabled = true;
          currentReader.elements.copyMarqueeText.disabled = true;
          currentReader.elements.speakButton.style.display = 'none';
          currentReader.elements.textViewButton.style.display = 'none';
          currentReader.elements.bookmarksButton.style.display = 'none';
          currentReader.elements.controlsContainerFooter.style.display = '';
          currentReader.elements.loopToggle.style.display = 'none';
          currentReader.elements.progressDisplay.style.display = 'none';
          currentReader.elements.tabNavigation.style.display = 'none';
          currentReader.elements.tabContent.style.display = 'none';
          currentReader.elements.searchInput.focus();
          currentReader.handleSearchInput(currentReader.elements.searchInput.value);
        } else {
          currentReader.elements.playPauseButton.disabled = false;
          currentReader.elements.stopButton.disabled = false;
          currentReader.elements.rewindButton.disabled = false;
          currentReader.elements.fastForwardButton.disabled = false;
          currentReader.elements.refreshSentences.disabled = false;
          currentReader.elements.refreshWords.disabled = false;
          currentReader.elements.refreshView.disabled = false;
          currentReader.elements.refreshColors.disabled = false;
          currentReader.elements.copyMarqueeText.disabled = false;
          currentReader.elements.speakButton.style.display = '';
          currentReader.elements.textViewButton.style.display = '';
          currentReader.elements.bookmarksButton.style.display = '';
          currentReader.elements.controlsContainerFooter.style.display = '';
          currentReader.elements.loopToggle.style.display = '';
          currentReader.elements.progressDisplay.style.display = '';
          currentReader.elements.tabNavigation.style.display = '';
          currentReader.elements.tabContent.style.display = '';
          currentReader.clearSearch();
        }
      },

      handleSearchInput(query) {
        this.searchQuery = query.trim();
        this.searchMatches = [];
        this.currentMatchIndex = -1;

        if (!this.searchQuery || !this.realText2List.length) {
          this.updateProgressBar(true);
          return;
        }

        this.updateCachedSizes();
        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = 0;
        const endPos = containerWidth - textWidth;
        const caseInsensitive = this.searchQuery === this.searchQuery.toLowerCase();

        const spans = Array.from(this.elements.marqueeDisplay.querySelectorAll('.marquee-word-span')).filter(x => !x.classList.contains(this.newWordMark));
        const queryWords = this.searchQuery.split(/\s+/).filter(word => word);
        for (let i = 0; i <= spans.length - queryWords.length; i++) {
          const matchSpans = [];
          let isMatch = true;
          let matchText = '';
          for (let j = 0; j < queryWords.length; j++) {
            const span = spans[i + j];
            const spanText = caseInsensitive ? span.textContent.toLowerCase() : span.textContent;
            matchText += (j > 0 ? ' ' : '') + spanText;
            if (!spanText.includes(queryWords[j])) {
              isMatch = false;
              break;
            }
            matchSpans.push(span);
          }
          if (isMatch && matchText.includes(this.searchQuery)) {
            const firstSpanRect = matchSpans[0].getBoundingClientRect();
            const marqueeRect = this.elements.marqueeDisplay.getBoundingClientRect();
            const position = -(firstSpanRect.left - marqueeRect.left);
            this.searchMatches.push({ spanElements: matchSpans, position });
          }
        }

        this.updateProgressBar(true);
        if (this.searchMatches.length > 0) {
            this.currentMatchIndex = 0;
            this.goToMatch(this.currentMatchIndex);
        }
      },

      goToMatch(index) {
        if (index < 0 || index >= this.searchMatches.length) return;

        this.currentMatchIndex = index;
        const match = this.searchMatches[this.currentMatchIndex];

        this.currentPosition = match.position;

        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.savePosition();
      },

      goToNextMatch() {
        if (this.searchMatches.length === 0) return;
        const nextIndex = (this.currentMatchIndex + 1) % this.searchMatches.length;
        this.goToMatch(nextIndex);
      },

      goToPreviousMatch() {
        if (this.searchMatches.length === 0) return;
        const prevIndex = this.currentMatchIndex - 1 < 0 ? this.searchMatches.length - 1 : this.currentMatchIndex - 1;
        this.goToMatch(prevIndex);
      },

      clearSearch() {
        this.searchQuery = '';
        this.searchMatches = [];
        this.currentMatchIndex = -1;
        this.elements.searchInput.value = '';
        this.updateProgressBar(true);
      },

      toggleBookmarks() {
        if (this.animationTimer != null || this.isSpeaking) {
          alert("Stop animation or speech first");
          return;
        }

        this.startAnimation(false, false);
        if (!this.realText2List.length) {
          return;
        }

        this.isBookmarksActive = !this.isBookmarksActive;

        if (this.isBookmarksActive) {
          this.tmpBookmarks = JSON.parse(JSON.stringify(this.currentTextBookmarks));
          this.elements.bookmarksButton.style.display = "none";
          this.elements.bookmarksControls.style.display = "";
          this.elements.playPauseButton.disabled = true;
          this.elements.stopButton.disabled = true;
          this.elements.rewindButton.disabled = false;
          this.elements.fastForwardButton.disabled = false;
          this.elements.refreshSentences.disabled = true;
          this.elements.refreshWords.disabled = true;
          this.elements.refreshView.disabled = true;
          this.elements.refreshColors.disabled = true;
          this.elements.copyMarqueeText.disabled = true;
          this.elements.speakButton.style.display = 'none';
          this.elements.textViewButton.style.display = 'none';
          this.elements.searchButton.style.display = 'none';
          this.elements.controlsContainerFooter.style.display = '';
          this.elements.loopToggle.style.display = 'none';
          this.elements.progressDisplay.style.display = 'none';
          this.elements.tabNavigation.style.display = 'none';
          this.elements.tabContent.style.display = 'none';
          this.loadBookmarks();
        } else {
          this.tmpBookmarks = [];
          this.elements.bookmarksButton.style.display = "";
          this.elements.bookmarksControls.style.display = "none";
          this.elements.playPauseButton.disabled = false;
          this.elements.stopButton.disabled = false;
          this.elements.rewindButton.disabled = false;
          this.elements.fastForwardButton.disabled = false;
          this.elements.refreshSentences.disabled = false;
          this.elements.refreshWords.disabled = false;
          this.elements.refreshView.disabled = false;
          this.elements.refreshColors.disabled = false;
          this.elements.copyMarqueeText.disabled = false;
          this.elements.speakButton.style.display = '';
          this.elements.textViewButton.style.display = '';
          this.elements.searchButton.style.display = '';
          this.elements.controlsContainerFooter.style.display = '';
          this.elements.loopToggle.style.display = '';
          this.elements.progressDisplay.style.display = '';
          this.elements.tabNavigation.style.display = '';
          this.elements.tabContent.style.display = '';
          const bookmarkMarks = this.elements.progressBarContainer.querySelectorAll(".bookmark-mark");
          bookmarkMarks.forEach(mark => mark.remove());
          this.updateProgressBar(true);
        }
      },

      loadBookmarks() {
        const currentReader = this;
        currentReader.elements.bookmarksList.innerHTML = "";
        const bookmarks = currentReader.tmpBookmarks.sort((a, b) => a.wordIndex - b.wordIndex);
        bookmarks.forEach((bookmark, index) => {
          const bookmarkDiv = document.createElement("div");
          bookmarkDiv.className = "bookmark-item with-rounded-border";

          const progress = currentReader.getProgressByPosition(currentReader.getPositionByWordIndex(bookmark.wordIndex)) || bookmark.progress;
          const nameElem = document.createElement("div");
          nameElem.textContent = bookmark.name;
          nameElem.innerHTML += '<br>' + progress.toFixed(2) + '%';
          nameElem.className = "bookmark-name";
          nameElem.onclick = () => currentReader.goToBookmark(progress, bookmark.wordIndex);

          const removeButton = document.createElement("button");
          removeButton.textContent = "Remove";
          removeButton.className = "bookmark-remove-button dark-button";
          removeButton.onclick = () => currentReader.removeBookmark(index);

          bookmarkDiv.appendChild(nameElem);
          bookmarkDiv.appendChild(removeButton);
          currentReader.elements.bookmarksList.appendChild(bookmarkDiv);
        });
        currentReader.updateBookmarkMarks();
      },

      addBookmark() {
        const name = this.elements.bookmarkNameInput.value.trim();
        if (!name) {
          alert("The bookmark name is empty");
          return;
        }
        if (this.currentPosition === null) return;

        const containerWidth = this.cachedContainerWidth;
        const textWidth = this.cachedTextWidth;
        const startPos = containerWidth;
        const endPos = -textWidth;
        const progress = this.getProgressByPosition();
        const wordIndex = this.getFirstVisibleWordIndex();
        this.tmpBookmarks.push({ name, progress, wordIndex });
        this.elements.bookmarkNameInput.value = "";
        this.loadBookmarks();
      },

      removeBookmark(index) {
        this.tmpBookmarks.splice(index, 1);
        this.loadBookmarks();
      },

      goToBookmark(progress, wordIndex) {
        this.currentPosition = this.getPositionByWordIndex(wordIndex) || this.getPositionByProgress(progress);
        this.elements.marqueeDisplay.style.left = `${this.currentPosition}px`;
        this.savePosition();
      },

      saveBookmarksToDB() {
        const currentReader = this;

        if (!currentReader.database) return;

        const bookmarks = (this.isBookmarksActive ? this.tmpBookmarks : this.currentTextBookmarks).sort((a, b) => a.wordIndex - b.wordIndex);

        if (currentReader.currentTextName === currentReader.defaultTextName) {
          localStorage.setItem(currentReader.settingsNames.textBookmarks, JSON.stringify(bookmarks));
          currentReader.currentTextBookmarks = bookmarks;
          currentReader.toggleBookmarks();
          return;
        }

        const transaction = currentReader.database.transaction([currentReader.settingsNames.texts], "readwrite");
        const store = transaction.objectStore(currentReader.settingsNames.texts);
        const request = store.get(currentReader.currentTextName);
        request.onsuccess = () => {
          const data = request.result;
          const updatedData = {
            ...data,
            bookmarks: JSON.stringify(bookmarks)
          };
          const nextRequest = store.put(updatedData);
          nextRequest.onsuccess = () => {
            currentReader.currentTextBookmarks = bookmarks;
            currentReader.toggleBookmarks();
          };
          nextRequest.onerror = (event) => {
            const message = `Failed to save bookmarks to database: ${event.target.error}`;
            console.error(event.target.error);
            alert(message);
          };
        };
        request.onerror = () => {
          const message = `Failed to save bookmarks to database: ${event.target.error}`;
          console.error(event.target.error);
          alert(message);
        };
      },

      updateBookmarkMarks() {
        const currentReader = this;
        const bookmarks = (currentReader.isBookmarksActive ? currentReader.tmpBookmarks : currentReader.currentTextBookmarks).sort((a, b) => a.progress - b.progress);
        const bookmarkMarks = currentReader.elements.progressBarContainer.querySelectorAll(".bookmark-mark");
        bookmarkMarks.forEach(mark => mark.remove());
        bookmarks.forEach(bookmark => {
          const containerWidth = currentReader.cachedContainerWidth;
          const textWidth = currentReader.cachedTextWidth;
          const startPos = containerWidth;
          const endPos = -textWidth;
          const progress = currentReader.getProgressByPosition(currentReader.getPositionByWordIndex(bookmark.wordIndex)) || bookmark.progress;
          const mark = document.createElement("div");
          mark.className = "bookmark-mark";
          mark.style.left = `${progress}%`;
          mark.title = bookmark.name;
          mark.addEventListener("click", (event) => {
            event.stopPropagation();
            currentReader.goToBookmark(bookmark.progress, bookmark.wordIndex);
          });
          currentReader.elements.progressBarContainer.appendChild(mark);
        });
      },

      calcShannonEntropy(words) {
        if (!words || words.length === 0) {
          return 0;
        }

        const unigrams = new Map(), bigrams = new Map();
        let totalChars = 0;
        for (const w of words) {
          const word = Array.from(w.toLowerCase()).filter(ch => this.letterPattern.test(ch));
          for (const char of word) {
            unigrams.set(char, (unigrams.get(char) || 0) + 1);
            totalChars++;
          }
          for (let i = 0; i < word.length - 1; i++) {
            const bigram = word[i] + word[i + 1];
            bigrams.set(bigram, (bigrams.get(bigram) || 0) + 1);
          }
        }

        const pUnigrams = new Map();
        for (const char of unigrams.keys()) {
          pUnigrams.set(char, unigrams.get(char) / totalChars);
        }

        const pBigrams = new Map();
        for (const bigram of bigrams.keys()) {
          const firstChar = bigram[0];
          pBigrams.set(bigram, bigrams.get(bigram) / unigrams.get(firstChar));
        }

        let conditionalEntropy = 0;
        for (const firstChar of unigrams.keys()) {
          let innerSum = 0;
          for (const secondChar of unigrams.keys()) {
            const bigram = firstChar + secondChar;
            const pBigram = pBigrams.get(bigram);
            if (pBigram) {
              const pBigramX = pBigram * Math.log2(pBigram);
              if (isFinite(pBigramX)) {
                innerSum -= pBigramX;
              }
            }
          }
          conditionalEntropy += pUnigrams.get(firstChar) * innerSum;
        }

        return conditionalEntropy;
      },

      calculateTextParameters() {
        if (!this.realText1List.length) {
          return {
            shannonEntropyMin: 0,
            shannonEntropyMax: 0,
            wordCount: 0,
            avgWordLength: 0,
            avgWordFrequency: 0,
            uniqueWords: 0,
            uniqueWordsPercent: 0,
            complexity: 0,
            alphabetLetters: 0,
            alphabetLettersPercent: 0,
            allCharsCount: 0
          };
        }

        /* Number of words */
        const words = this.realText2List.filter(w => this.wordPattern.test(w));
        const wordCount = words.length;

        /* Average word length */
        const totalWordLength = words.reduce((sum, w) => sum + w.length, 0);
        const avgWordLength = (wordCount ? (totalWordLength / wordCount) : 0).toFixed(1);

        /* Average word frequency */
        const wordFreqMap = new Map();
        words.forEach(word => {
          const key = word.toLowerCase();
          wordFreqMap.set(key, (wordFreqMap.get(key) || 0) + 1);
        });
        const uniqueWordCount = wordFreqMap.size;
        const avgWordFrequency = (uniqueWordCount ? (wordCount / uniqueWordCount) : 0).toFixed(1);

        /* Unique words (number/percent) */
        const uniqueWords = uniqueWordCount;
        const uniqueWordsPercent = (wordCount ? (uniqueWords / wordCount * 100) : 0).toFixed(1);

        /* Text complexity after manipulations */
        const complexity = this.realTextDiff.toFixed(1);

        /* Alphabet letters (number/percent) */
        const allChars = this.realText2List.join('').split('');
        const allCharsCount = allChars.length;
        const allLetters = allChars.filter(c => this.letterPattern.test(c));
        const allLowercasedLetters = allLetters.map(c => c.toLowerCase());
        const uniqueLetters = new Set(allLowercasedLetters);
        const alphabetLetters = uniqueLetters.size;
        const alphabetLettersPercent = (alphabetLetters ? (allLetters.length / allCharsCount * 100) : 0).toFixed(1);
        const shannonEntropyMin = this.calcShannonEntropy(this.realText2List).toFixed(1);
        const shannonEntropyMax = (alphabetLetters ? Math.log2(alphabetLetters) : 0).toFixed(1);

        return {
          shannonEntropyMin,
          shannonEntropyMax,
          wordCount,
          avgWordLength,
          avgWordFrequency,
          uniqueWords,
          uniqueWordsPercent,
          complexity,
          alphabetLetters,
          alphabetLettersPercent,
          allCharsCount
        };
      },

      calculateTextViewParameters() {
        /* Colored symbols (number/percent) */
        const allChars = this.realText2List.join('').split('');
        const coloredLettersValue = this.elements.colorEncoderToggle.checked && this.elements.textBackgroundColoringToggle.checked ? this.colorList.length : 0;
        const coloredLetters = coloredLettersValue;
        const coloredLettersPercent = (coloredLettersValue ? (allChars.filter(c => this.colorMap.get(c)).length / allChars.length * 100) : 0).toFixed(1);
        return {
          coloredLetters,
          coloredLettersPercent,
        };
      },

      updateTextStats() {
        this.textParameters = {
          ...this.textParameters,
          ...this.calculateTextParameters()
        };
        this.elements.textParameterShannonEntropyNumber.textContent = `${this.textParameters.shannonEntropyMin}/${this.textParameters.shannonEntropyMax}`;
        this.elements.textParameterWordsNumber.textContent = this.textParameters.wordCount;
        this.elements.textParameterUniqueWordsNumber.textContent = this.textParameters.uniqueWords;
        this.elements.textParameterUniqueWordsPercent.textContent = `${this.textParameters.uniqueWordsPercent}%`;
        this.elements.textParameterAverageWordLength.textContent = this.textParameters.avgWordLength;
        this.elements.textParameterAverageWordFrequency.textContent = this.textParameters.avgWordFrequency;
        this.elements.textParameterAfterManipulationsComplexity.textContent = `${this.textParameters.complexity}`;
        this.elements.textParameterAllSymbolsNumber.textContent = this.textParameters.allCharsCount;
        this.elements.textParameterAlphabetLettersNumber.textContent = this.textParameters.alphabetLetters;
        this.elements.textParameterAlphabetLettersPercent.textContent = `${this.textParameters.alphabetLettersPercent}%`;
        this.updateTextViewStats();
      },

      updateTextViewStats() {
        this.textParameters = {
          ...this.textParameters,
          ...this.calculateTextViewParameters()
        };
        this.elements.textParameterLettersColoredNumber.textContent = this.textParameters.coloredLetters;
        this.elements.textParameterLettersColoredPercent.textContent = `${this.textParameters.coloredLettersPercent}%`;
      },

      loadHistory(callback = null) {
        const currentReader = this;
        if (!this.database) return;
        const transaction = currentReader.database.transaction([currentReader.settingsNames.history], 'readonly');
        const objectStore = transaction.objectStore(currentReader.settingsNames.history);
        const request = objectStore.getAll();
        request.onsuccess = () => {
          currentReader.history = (request.result || []).sort((a, b) => b.timestamp - a.timestamp);
          currentReader.renderHistory();
          currentReader.updateReport();
          if (callback) {
            callback();
          }
        };
        request.onerror = (event) => {
          const message = `Error importing history: ${event.target.error}`;
          console.error(event.target.error);
          alert(message);
        };
      },

      saveHistory(callback = null) {
        const currentReader = this;
        if (!this.database) return;
        const transaction = currentReader.database.transaction([currentReader.settingsNames.history], 'readwrite');
        const objectStore = transaction.objectStore(currentReader.settingsNames.history);
        objectStore.clear();
        const minTimeValue = Math.max(1, parseInt(currentReader.elements.attemptMinTimeInput.value || 1));
        this.history.forEach(item => {
          if (item.timeSpent <= minTimeValue) {
            return;
          }
          if (parseFloat(item.maxProgress) <= 0) {
            return;
          }
          objectStore.add(item);
        });
        transaction.oncomplete = () => {
          if (callback) {
            callback();
          }
        };
        transaction.onabort = () => {
          console.error(transaction.error);
          alert(transaction.error);
        };
      },

      prevHistoryItem() {
        const currentIndex = parseInt(this.elements.historyIndex.value || 1);
        const prevIndex = Math.max(1, Math.min(this.history.length, currentIndex - 1));
        this.elements.historyIndex.value = prevIndex;
        this.renderHistory(true);
      },

      nextHistoryItem() {
        const currentIndex = parseInt(this.elements.historyIndex.value || 1);
        const nextIndex = Math.max(1, Math.min(this.history.length, currentIndex + 1));
        this.elements.historyIndex.value = nextIndex;
        this.renderHistory(true);
      },

      renderHistory(afterUpdate = false) {
        if (!afterUpdate) {
          this.elements.historyIndex.value = '1';
        }
        const currentIndex = parseInt(this.elements.historyIndex.value || 1);
        const existingIndex = Math.max(1, Math.min(this.history.length, currentIndex));
        this.elements.historyIndex.value = '' + existingIndex;
        const historyList = this.elements.historyList;
        const r = [];
        let index = 0;
        for (const item of this.history) {
          const datetime = this.getStrDateTime(new Date(parseInt(item.timestamp)));
          const shannonEntropy = (item.textParameters.shannonEntropy ? item.textParameters.shannonEntropy : `${item.textParameters.shannonEntropyMin}/${item.textParameters.shannonEntropyMax}`);
          if (index + 1 === existingIndex) {
            r.push(`
      <div class="history-row with-rounded-border">
        <div>
          <span>Date-Time</span>
          <span>${datetime}</span>
        </div>
        <div>
          <span>Type</span>
          <span>${item.type}</span>
        </div>
        <div>
          <span>Time spent</span>
          <span>${this.formatTime(item.timeSpent)}</span>
        </div>
        <div>
          <span>Max progress</span>
          <span>${item.maxProgress.toFixed(1)}%</span>
        </div>
        <div>
          <span>Text</span>
          <span>${item.textName}</span>
        </div>
        <div>
          <span>Settings profile</span>
          <span>${item.settingsProfileName}</span>
        </div>
        <div>
          <span>Shannon entropy</span>
          <span>${shannonEntropy}</span>
        </div>
        <div>
          <span>Words</span>
          <span>${item.textParameters.wordCount}</span>
        </div>
        <div>
          <span>Unique words</span>
          <span>${item.textParameters.uniqueWords} (${item.textParameters.uniqueWordsPercent}%)</span>
        </div>
        <div>
          <span>Average word length</span>
          <span>${item.textParameters.avgWordLength}</span>
        </div>
        <div>
          <span>Average word frequency</span>
          <span>${item.textParameters.avgWordFrequency}</span>
        </div>
        <div>
          <span>Complexity</span>
          <span>${item.textParameters.complexity}</span>
        </div>
        <div>
          <span>All symbols</span>
          <span>${item.textParameters.allCharsCount}</span>
        </div>
        <div>
          <span>Unique letters</span>
          <span>${item.textParameters.alphabetLetters} (${item.textParameters.alphabetLettersPercent}%)</span>
        </div>
        <div>
          <span>Colored unique symbols</span>
          <span>${item.textParameters.coloredLetters} (${item.textParameters.coloredLettersPercent}%)</span>
        </div>
        <div>
          <span class="mob-ta-center"><button class="delete-attempt dark-button mob-w30" data-index="${index}">Delete</button></span>
        </div>
      </div>
    `);
          }
          index += 1;
        }
        historyList.innerHTML = r.join('');
        document.querySelectorAll('.delete-attempt').forEach(button => {
          button.addEventListener('click', () => this.deleteHistoryItem(parseInt(button.dataset.index)));
        });
      },

      amendHistoryItemAux() {
        if (!this.historyStatus) {
          this.saveHistory(() => {
            this.updateReport();
            this.renderHistory(true);
          });
          return true;
        }
        if (!this.realText || !this.textParameters) {
          return null;
        }
        if (!this.history.length || this.forceNewHistoryItem) {
          return false;
        }
        const lastItem = this.history[0];
        if (lastItem == null) {
          return false;
        }
        if (this.currentTextName !== lastItem.textName || this.currentSettingsProfileName !== lastItem.settingsProfileName) {
          return false;
        }
        if (this.isSpeaking && lastItem.type !== this.historyTypes.speak || !this.isSpeaking && lastItem.type === this.historyTypes.speak) {
          return false;
        }
        const timeSpent = lastItem.timeSpent + (this.animationStartTime ? Math.floor((Date.now() - this.animationStartTime) / 1000) : 0);
        const newMaxProgress = Math.max(0, Math.min(100, lastItem.maxProgress + Math.max(0, this.endProgress - this.startProgress)));
        const item = {
          timestamp: lastItem.timestamp,
          type: lastItem.type,
          timeSpent: timeSpent,
          maxProgress: newMaxProgress,
          textName: lastItem.textName,
          settingsProfileName: lastItem.settingsProfileName,
          textParameters: this.textParameters
        };
        this.history.shift();
        this.history.unshift(item);
        this.saveHistory(() => {
          this.updateReport();
          this.renderHistory();
        });
        return true;
      },

      amendHistoryItem() {
        const r = this.amendHistoryItemAux();
        if (r === false) {
          this.forceNewHistoryItem = false;
          return this.addHistoryItem(this.isSpeaking ? this.historyTypes.speak : this.historyTypes.play);
        }
      },

      addHistoryItemAux(type) {
        if (!this.historyStatus) {
          return this.saveHistory(() => {
            this.updateReport();
            this.renderHistory(true);
          });
        }
        if (!this.textParameters) {
          return;
        }
        const item = {
          timestamp: Date.now(),
          type: type,
          timeSpent: this.animationStartTime ? Math.floor((Date.now() - this.animationStartTime) / 1000) : 0,
          maxProgress: 0,
          settingsProfileName: this.currentSettingsProfileName,
          textName: this.currentTextName,
          textParameters: this.textParameters
        };
        this.history.unshift(item);
        this.saveHistory(() => {
          this.updateReport();
          this.renderHistory();
        });
      },

      addHistoryItem(type) {
        this.addHistoryItemAux(type || (this.isSpeaking ? this.historyTypes.speak : this.historyTypes.play));
      },

      deleteHistoryItem(index) {
        this.history.splice(index, 1);
        this.saveHistory(() => {
          this.updateReport();
          this.renderHistory(true);
        });
      },

      renderReport() {
        this.elements.reportTodayAttempts.textContent = this.report.today.attempts;
        this.elements.reportTodayTime.textContent = this.formatTime(this.report.today.time);
        this.elements.report3DaysAttempts.textContent = this.report.last3Days.attempts;
        this.elements.report3DaysTime.textContent = this.formatTime(this.report.last3Days.time);
        this.elements.reportWeekAttempts.textContent = this.report.thisWeek.attempts;
        this.elements.reportWeekTime.textContent = this.formatTime(this.report.thisWeek.time);
        this.elements.reportPrevWeekAttempts.textContent = this.report.prevWeek.attempts;
        this.elements.reportPrevWeekTime.textContent = this.formatTime(this.report.prevWeek.time);
        this.elements.reportMonthAttempts.textContent = this.report.thisMonth.attempts;
        this.elements.reportMonthTime.textContent = this.formatTime(this.report.thisMonth.time);
        this.elements.reportPrevMonthAttempts.textContent = this.report.prevMonth.attempts;
        this.elements.reportPrevMonthTime.textContent = this.formatTime(this.report.prevMonth.time);
      },

      updateReport() {
        const now = new Date();
        const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
        const threeDaysAgo = new Date(today.getTime() - 3 * 24 * 60 * 60 * 1000);
        const weekStart = new Date(today.getTime() - today.getDay() * 24 * 60 * 60 * 1000);
        const lastWeekStart = new Date(weekStart.getTime() - 7 * 24 * 60 * 60 * 1000);
        const monthStart = new Date(now.getFullYear(), now.getMonth(), 1);
        const lastMonthStart = new Date(now.getFullYear(), now.getMonth() - 1, 1);

        this.report = {
          today: { attempts: 0, time: 0 },
          last3Days: { attempts: 0, time: 0 },
          thisWeek: { attempts: 0, time: 0 },
          prevWeek: { attempts: 0, time: 0 },
          thisMonth: { attempts: 0, time: 0 },
          prevMonth: { attempts: 0, time: 0 }
        };

        this.history.forEach(item => {
          const attemptDate = new Date(item.timestamp);
          if (attemptDate >= today) {
            this.report.today.attempts++;
            this.report.today.time += item.timeSpent;
          }
          if (attemptDate >= threeDaysAgo) {
            this.report.last3Days.attempts++;
            this.report.last3Days.time += item.timeSpent;
          }
          if (attemptDate >= weekStart) {
            this.report.thisWeek.attempts++;
            this.report.thisWeek.time += item.timeSpent;
          }
          if (attemptDate >= lastWeekStart && attemptDate < weekStart) {
            this.report.prevWeek.attempts++;
            this.report.prevWeek.time += item.timeSpent;
          }
          if (attemptDate >= monthStart) {
            this.report.thisMonth.attempts++;
            this.report.thisMonth.time += item.timeSpent;
          }
          if (attemptDate >= lastMonthStart && attemptDate < monthStart) {
            this.report.prevMonth.attempts++;
            this.report.prevMonth.time += item.timeSpent;
          }
        });
        
        this.renderReport();
      },

      generateChart() {
        if (!this.history.length) {
          return;
        }
        if (window.myChart instanceof Chart) {
          window.myChart.destroy();
          window.myChart = null;
          this.elements.generateChartButton.innerHTML = 'Generate';
          this.elements.chartContainer.style.display = 'none';
          return;
        }
        this.elements.generateChartButton.innerHTML = 'Hide';
        this.elements.chartContainer.style.display = '';

        const ctx = this.elements.chartObject.getContext('2d');

        const timeRangeType = this.elements.chartTimeRangeSelect.value;

        const selectedMetrics = [
          'timeSpent',
          'allCharsCount',
          'wordCount',
          'complexity',
          'shannonEntropyMax',
          'shannonEntropyMin',
          'maxProgress',
          'minProgress'
        ];
        const selectedMetricsLabels = [
          'Time spent (minutes)',
          'Symbols*Progress',
          'Words*Progress',
          'Complexity*Progress',
          'Shannon entropy^Max',
          'Shannon entropy^Min',
          'Progress^Max',
          'Progress^Min'
        ];

        if (selectedMetrics.length === 0) {
          alert('Please select at least one metric.');
          return;
        }

        const dailyData = {};
        this.history.forEach(item => {
          const progress = item.maxProgress;
          const floatProgress = parseFloat(progress);
          if (!(floatProgress === floatProgress && floatProgress > 0)) {
            return;
          }
          let date = this.getStrDateTime(item.timestamp).slice(0, 16);
          if (timeRangeType === 'hour') {
            date = date.slice(0, 13).concat(':00');
          }
          else if (timeRangeType === 'day') {
            date = date.slice(0, 11);
          }
          else if (timeRangeType === 'month') {
            date = date.slice(0, 7);
          }
          if (!dailyData[date]) {
            dailyData[date] = {};
            selectedMetrics.forEach(metric => {
              dailyData[date][metric] = 0;
            });
          }
          selectedMetrics.forEach(metric => {
            if (metric === 'timeSpent') {
              dailyData[date][metric] += Math.ceil(item[metric] / 60);
            } else {
              const value = metric.includes('shannonEntropy') ? (item.textParameters['shannonEntropy'] ? item.textParameters['shannonEntropy'] : item.textParameters['shannonEntropyMin']) :
                (metric === 'minProgress' || metric === 'maxProgress' ? floatProgress : item.textParameters[metric]);
              if (value == null) {
                return;
              }
              const floatValue = parseFloat(value);
              const intValue = parseInt(value);
              const rValue = floatValue === floatValue && floatValue >= 0 ? Math.ceil(floatValue * floatProgress / 100) : (
                intValue === intValue && intValue >= 0 ? Math.ceil(intValue * floatProgress / 100) : value
              );
              if (metric === 'shannonEntropyMin') {
                dailyData[date][metric] = Math.min(dailyData[date][metric] || floatValue, floatValue);
              }
              else if (metric === 'shannonEntropyMax') {
                dailyData[date][metric] = Math.max(dailyData[date][metric] || floatValue, floatValue);
              }
              else if (metric === 'minProgress') {
                dailyData[date][metric] = Math.min(dailyData[date][metric] || floatProgress, floatProgress);
              }
              else if (metric === 'maxProgress') {
                dailyData[date][metric] = Math.max(dailyData[date][metric] || floatProgress, floatProgress);
              }
              else {
                dailyData[date][metric] += rValue;
              }
            }
          });
        });

        const labels = Object.keys(dailyData).sort();
        const datasets = selectedMetrics.map((metric, index) => ({
          label: selectedMetricsLabels[index],
          data: labels.map(date => dailyData[date][metric]),
          borderColor: `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 1)`,
          backgroundColor: `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.2)`,
          fill: true,
          tension: 0.3,
          hidden: metric !== 'timeSpent'
        }));

        if (window.myChart instanceof Chart) {
          window.myChart.destroy();
          window.myChart = null;
        }

        window.myChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels: labels,
            datasets: datasets
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: {
                  display: true,
                  text: 'Date',
                },
              },
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: 'Value',
                },
              }
            },
            plugins: {
              zoom: {
                pan: {
                  enabled: true,
                  mode: 'x',
                  scaleMode: 'x',
                },
                zoom: {
                  wheel: {
                    enabled: true,
                  },
                  pinch: {
                    enabled: true,
                  },
                  mode: 'x',
                  scaleMode: 'x',
                },
              },
            }
          }
        });
      },

      toggleGeminiKey() {
        localStorage.setItem(this.settingsNames.geminiKey, this.elements.geminiKeyInput.value);
      },

      toggleGeminiQuery() {
        localStorage.setItem(this.settingsNames.geminiQuery, this.elements.geminiQueryInput.value);
      },

      toggleGeminiModel() {
        localStorage.setItem(this.settingsNames.geminiModel, this.elements.geminiModelSelect.value);
      }
    };

    document.addEventListener('DOMContentLoaded', () => {
      if (window.speechSynthesis) {
        window.speechSynthesis.cancel();
      }
      MarqueeReader.initialize();
    });
  </script>
</body>
</html>